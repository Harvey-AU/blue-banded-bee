#!/bin/bash
# Pre-commit hook to automatically format files before committing
# This hook runs gofmt on Go files and prettier on docs/config files
# Compatible with: Mac, Linux, Windows (Git Bash)

set -e

echo "Running pre-commit formatting checks..."

# Detect if we're on Windows (Git Bash)
IS_WINDOWS=false
if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "win32" ]]; then
    IS_WINDOWS=true
fi

# Colours for output (disable on Windows if needed)
if [ "$IS_WINDOWS" = true ]; then
    RED=''
    GREEN=''
    YELLOW=''
    NC=''
else
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    NC='\033[0m'
fi

# Track if any files were formatted
FILES_FORMATTED=false

# === CHECK FOR AI ATTRIBUTION IN COMMIT MESSAGE ===
echo ""
echo "ü§ñ Checking commit message for AI attribution..."

# Get the commit message from the commit-msg file (will be created by git)
# For pre-commit, we check if user is trying to use -m flag with banned content
# Note: This catches most cases, but commit-msg hook is more thorough
COMMIT_MSG_FILE=".git/COMMIT_EDITMSG"
if [ -f "$COMMIT_MSG_FILE" ]; then
    # Filter out comment lines (those starting with #)
    COMMIT_MSG=$(grep -v '^#' "$COMMIT_MSG_FILE" || true)

    # Check for common AI attribution patterns (case-insensitive)
    if echo "$COMMIT_MSG" | grep -iE '(chatgpt|gpt-|copilot|Generated with|Co-Authored-By: Claude)' > /dev/null; then
        echo -e "${RED}‚ùå ERROR: Commit message contains AI attribution${NC}"
        echo ""
        echo "Found banned terms in commit message:"
        echo "$COMMIT_MSG" | grep -iE '(chatgpt|gpt-|copilot|Generated with|Co-Authored-By: Claude)'
        echo ""
        echo "Please remove AI attribution from your commit message."
        echo "See CLAUDE.md for commit message guidelines."
        exit 1
    fi
fi

echo "  ‚úÖ No AI attribution found"

# === FORMAT GO FILES ===
echo ""
echo "üìù Formatting Go files..."

# Get list of staged Go files
STAGED_GO_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.go$' || true)

if [ -n "$STAGED_GO_FILES" ]; then
    echo "Found Go files to format:"
    echo "$STAGED_GO_FILES"

    # Format each file
    for file in $STAGED_GO_FILES; do
        if [ -f "$file" ]; then
            gofmt -w "$file"
            git add "$file"
            echo "  ‚úÖ Formatted: $file"
            FILES_FORMATTED=true
        fi
    done
else
    echo "  ‚ÑπÔ∏è  No Go files to format"
fi

# === LINT GO FILES ===
echo ""
echo "üîç Linting Go files..."

# Resolve a compatible golangci-lint binary for this repository's Go version.
resolve_golangci_lint() {
    local required_go
    required_go=$(awk '/^go / {print $2; exit}' go.mod 2>/dev/null)
    if [ -z "$required_go" ]; then
        required_go=$(go env GOVERSION 2>/dev/null | sed -E 's/^go//')
    fi

    local candidates=()
    local default_lint
    default_lint=$(command -v golangci-lint 2>/dev/null || true)
    if [ -n "$default_lint" ] && [ -x "$default_lint" ]; then
        candidates+=("$default_lint")
    fi

    local go_bin_lint
    go_bin_lint="$(go env GOPATH 2>/dev/null)/bin/golangci-lint"
    if [ -x "$go_bin_lint" ]; then
        candidates+=("$go_bin_lint")
    fi

    if [ "${#candidates[@]}" -eq 0 ]; then
        return 1
    fi

    # De-duplicate while preserving order.
    local unique=()
    local c
    for c in "${candidates[@]}"; do
        local seen=false
        local u
        for u in "${unique[@]}"; do
            if [ "$u" = "$c" ]; then
                seen=true
                break
            fi
        done
        if [ "$seen" = false ]; then
            unique+=("$c")
        fi
    done

    local selected="${unique[0]}"
    local found_compatible=false
    if [ -n "$required_go" ]; then
        for c in "${unique[@]}"; do
            local built_with
            built_with=$("$c" version 2>/dev/null | sed -nE 's/.*built with go([0-9]+(\.[0-9]+){1,2}).*/\1/p' | head -n 1)
            if [ -z "$built_with" ]; then
                echo "  ‚ö†Ô∏è  Could not parse golangci-lint build Go version: $c" >&2
                continue
            fi
            # Compatible when built_with >= required_go (version-sort aware).
            if [ "$(printf '%s\n%s\n' "$built_with" "$required_go" | sort -V | tail -n 1)" = "$built_with" ]; then
                selected="$c"
                found_compatible=true
                break
            fi
        done

        if [ "$found_compatible" = false ]; then
            echo "  ‚ö†Ô∏è  No compatible golangci-lint found for go$required_go; using $selected" >&2
        fi
    fi

    echo "$selected"
    return 0
}

LINT_BIN=$(resolve_golangci_lint || true)

# Check if golangci-lint is installed
if [ -z "$LINT_BIN" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  golangci-lint not installed. Install with: go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest${NC}"
    echo "Skipping linting... (CI will still check)"
elif [ -n "$STAGED_GO_FILES" ]; then
    # Run golangci-lint on staged files only
    echo "Running golangci-lint on staged files..."
    echo "Using: $LINT_BIN"

    # Run linter with same config as CI (package-aware so type info isn't lost)
    if ! "$LINT_BIN" run --config .golangci.yml --modules-download-mode=mod; then
        echo ""
        echo -e "${RED}‚ùå Linting failed${NC}"
        echo ""
        echo "Fix the issues above or use 'git commit --no-verify' to skip checks"
        exit 1
    fi

    echo "  ‚úÖ Linting passed"
else
    echo "  ‚ÑπÔ∏è  No Go files to lint"
fi

# === FORMAT DOCS/CONFIG FILES ===
echo ""
echo "üìù Formatting docs and config files..."

# Check if prettier is installed
if ! command -v prettier &> /dev/null; then
    echo -e "${YELLOW}‚ö†Ô∏è  Prettier not installed. Install with: npm install -g prettier${NC}"
    echo "Skipping prettier formatting..."
else
    # Get list of staged markdown/YAML/JSON/HTML/CSS/JS files
    STAGED_DOC_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(md|yml|yaml|json|html|css|js)$' || true)

    if [ -n "$STAGED_DOC_FILES" ]; then
        echo "Found docs/config files to format:"
        echo "$STAGED_DOC_FILES"

        # Format files with prettier (suppress warnings)
        echo "$STAGED_DOC_FILES" | xargs prettier --write --log-level warn 2>/dev/null || \
        echo "$STAGED_DOC_FILES" | xargs prettier --write

        # Re-add formatted files
        echo "$STAGED_DOC_FILES" | xargs git add

        echo "  ‚úÖ Formatted with prettier"
        FILES_FORMATTED=true
    else
        echo "  ‚ÑπÔ∏è  No docs/config files to format"
    fi
fi



# === SECURITY CHECKS ===
echo ""
echo "üõ°Ô∏è  Running Security Checks..."

# 1. Govulncheck (Fast dependency scanning)
if command -v govulncheck &> /dev/null; then
    echo "  Running govulncheck..."
    if ! govulncheck ./... > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Govulncheck failed (Vulnerabilities found)${NC}"
        echo "Run './scripts/security-check.sh' for details."
        exit 1
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  govulncheck not found (Skipping)${NC}"
fi

# 2. Trivy (Secrets & Config)
if command -v trivy &> /dev/null; then
    echo "  Running Trivy (Secrets & Config)..."
    # Run only on staged files/changes would be ideal, but for now we scan the repo (ignoring worktrees)
    if ! trivy fs --scanners secret,misconfig --severity HIGH,CRITICAL --ignore-unfixed --skip-dirs .worktrees . > /dev/null 2>&1; then
        echo -e "${RED}‚ùå Trivy found secrets or misconfigurations${NC}"
        echo "Run './scripts/security-check.sh' for details."
        exit 1
    fi
else
    echo -e "${YELLOW}‚ö†Ô∏è  trivy not found (Skipping)${NC}"
fi

# 3. ESLint Security (Frontend)
if [ -f "eslint.config.mjs" ] && command -v npx &> /dev/null; then
    echo "  Running ESLint Security..."
    if ! npx eslint "web/**/*.js" > /dev/null 2>&1; then
        echo -e "${RED}‚ùå ESLint found security issues${NC}"
        echo "Run './scripts/security-check.sh' for details."
        exit 1
    fi
elif [ -f "eslint.config.mjs" ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  npx not found (Skipping ESLint Security)${NC}"
fi

# === SUMMARY ===
echo ""
if [ "$FILES_FORMATTED" = true ]; then
    echo -e "${GREEN}‚ú® Files formatted successfully!${NC}"
    echo "Changes have been staged. Your commit will now proceed."
else
    echo -e "${GREEN}‚úÖ All staged files were already formatted${NC}"
fi

echo ""
exit 0
