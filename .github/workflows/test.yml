name: Run Tests
on:
  pull_request:
    branches:
      - main
      - test-branch
    paths-ignore:
      - "**.md"
      - "docs/**"
      - "LICENSE"
      - ".gitignore"
      - "CHANGELOG.md"
      - "SECURITY.md"
      - "Roadmap.md"
      - "QandA.md"
  push:
    branches:
      - main
    paths-ignore:
      - "**.md"
      - "docs/**"
      - "LICENSE"
      - ".gitignore"
      - "CHANGELOG.md"
      - "SECURITY.md"
      - "Roadmap.md"
      - "QandA.md"

jobs:
  lint:
    name: Lint
    runs-on: blacksmith-4vcpu-ubuntu-2404
    env:
      GOFLAGS: "-mod=mod"
      GOPROXY: "https://proxy.golang.org,direct"
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
          cache: true

      - name: Determine Go cache paths
        id: go-env
        run: |
          echo "gomodcache=$(go env GOMODCACHE)" >> $GITHUB_OUTPUT
          echo "gocache=$(go env GOCACHE)" >> $GITHUB_OUTPUT

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.go-env.outputs.gomodcache }}
            ${{ steps.go-env.outputs.gocache }}
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Download dependencies
        run: go mod download

      - name: Prime module graph (test + prod)
        run: go list -deps -test ./...

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v4
        with:
          version: v1.59.0
          args: --config .golangci.yml --modules-download-mode=mod --out-format=colored-line-number

  unit-tests:
    name: Unit Tests
    runs-on: blacksmith-4vcpu-ubuntu-2404
    needs: lint
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
          cache: true

      - name: Run unit tests
        run: |
          echo "=== Running Unit Tests ==="
          go test -race -short -shuffle=on -covermode=atomic -coverprofile=coverage-unit.out -coverpkg=./... ./... || \
          go test -v -race -short -shuffle=on -covermode=atomic -coverprofile=coverage-unit.out -coverpkg=./... ./...

      - name: Upload unit test coverage
        uses: actions/upload-artifact@v4
        with:
          name: coverage-unit
          path: coverage-unit.out

      - name: Upload unit test coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage-unit.out
          flags: unit
          name: unit-tests
          fail_ci_if_error: false

  integration-tests:
    name: Integration Tests
    runs-on: blacksmith-4vcpu-ubuntu-2404
    needs: lint
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
          cache: true

      - name: Skip database setup for dynamic preview branches
        run: |
          echo "Skipping database setup - using Supabase preview branches per PR"
          echo "Integration tests will run on deployed review apps with their own database"

      - name: Run integration tests
        run: |
          echo "=== Running Integration Tests ==="
          go test -race -covermode=atomic -coverprofile=coverage-integration.out -coverpkg=./... -tags=integration ./... -json > test-output.json || \
          go test -v -race -covermode=atomic -coverprofile=coverage-integration.out -coverpkg=./... -tags=integration ./... -json > test-output.json

          # Show test results summary
          echo "=== Test Results ==="
          if grep -q '"Action":"fail"' test-output.json; then
            echo "❌ Found test failures:"
            grep -E '"Action":"fail"' test-output.json | head -10 || true
          else
            echo "✅ All integration tests passed!"
          fi

      - name: Generate JUnit report
        if: always()
        run: |
          go install github.com/jstemmer/go-junit-report/v2@latest
          $(go env GOPATH)/bin/go-junit-report -parser gojson < test-output.json > junit.xml

      - name: Upload integration test coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-integration
          path: coverage-integration.out

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: junit.xml

      - name: Upload integration test coverage to Codecov
        if: always()
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage-integration.out
          flags: integration
          name: integration-tests
          fail_ci_if_error: false

      - name: Upload test results to Codecov
        if: always()
        uses: codecov/test-results-action@v1
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./junit.xml

  coverage-report:
    name: Coverage Report
    runs-on: blacksmith-4vcpu-ubuntu-2404
    needs: [unit-tests, integration-tests]
    if: always()
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.25"
          cache: true

      - name: Download coverage files
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          merge-multiple: true

      - name: Merge coverage reports
        run: |
          echo "=== Merging Coverage Reports ==="
          
          # Simple approach - use unit tests coverage primarily  
          if [ -f coverage-unit.out ]; then
            echo "Using unit coverage as primary"
            cp coverage-unit.out coverage.out
          elif [ -f coverage-integration.out ]; then
            echo "Using integration coverage as fallback"  
            cp coverage-integration.out coverage.out
          else
            echo "No coverage files found"
            exit 1
          fi

          # Show total coverage
          if [ -f coverage.out ]; then
            echo "=== Total Coverage ==="
            go tool cover -func=coverage.out | tail -1
          fi

      - name: Check coverage floors
        run: |
          echo "=== Checking Coverage Floors ==="

          # Extract coverage percentages for critical packages
          if [ -f coverage.out ]; then
            # Calculate package-level coverage from function-level coverage
            DB_FUNCTIONS=$(go tool cover -func=coverage.out | grep "github.com/Harvey-AU/blue-banded-bee/internal/db/")
            JOBS_FUNCTIONS=$(go tool cover -func=coverage.out | grep "github.com/Harvey-AU/blue-banded-bee/internal/jobs/")
            
            # Calculate weighted average coverage for each package
            if [ ! -z "$DB_FUNCTIONS" ]; then
              DB_COVERAGE=$(echo "$DB_FUNCTIONS" | awk '{sum += $3; count++} END {if(count > 0) print sum/count; else print 0}' | sed 's/%//')
            else
              DB_COVERAGE=0
            fi
            
            if [ ! -z "$JOBS_FUNCTIONS" ]; then
              JOBS_COVERAGE=$(echo "$JOBS_FUNCTIONS" | awk '{sum += $3; count++} END {if(count > 0) print sum/count; else print 0}' | sed 's/%//')
            else
              JOBS_COVERAGE=0
            fi
            
            echo "DB Package Coverage: ${DB_COVERAGE}%"
            echo "Jobs Package Coverage: ${JOBS_COVERAGE}%"
            
            # Set minimum coverage floors
            DB_MIN=10
            JOBS_MIN=15
            
            # Check if coverage meets minimum requirements
            if [ ! -z "$DB_COVERAGE" ] && [ "$DB_COVERAGE" != "0" ]; then
              if (( $(echo "$DB_COVERAGE < $DB_MIN" | bc -l) )); then
                echo "❌ DB package coverage ${DB_COVERAGE}% is below minimum ${DB_MIN}%"
                exit 1
              else
                echo "✅ DB package coverage ${DB_COVERAGE}% meets minimum ${DB_MIN}%"
              fi
            else
              echo "⚠️ DB package coverage could not be calculated or is 0%"
            fi
            
            if [ ! -z "$JOBS_COVERAGE" ] && [ "$JOBS_COVERAGE" != "0" ]; then
              if (( $(echo "$JOBS_COVERAGE < $JOBS_MIN" | bc -l) )); then
                echo "❌ Jobs package coverage ${JOBS_COVERAGE}% is below minimum ${JOBS_MIN}%"
                exit 1
              else
                echo "✅ Jobs package coverage ${JOBS_COVERAGE}% meets minimum ${JOBS_MIN}%"
              fi
            else
              echo "⚠️ Jobs package coverage could not be calculated or is 0%"
            fi
          fi

      - name: Upload combined coverage to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          files: ./coverage.out
          flags: all
          name: all-tests
          fail_ci_if_error: false

      - name: Upload static analysis to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_STATIC_TOKEN }}
          flags: static-analysis
          name: static-analysis
          fail_ci_if_error: false
