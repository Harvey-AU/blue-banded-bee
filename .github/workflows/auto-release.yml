name: Auto Release

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  auto-tag:
    name: Auto Tag Release
    # Only run if PR was merged and does NOT have no-release label
    if: |
      github.event.pull_request.merged == true &&
      !contains(github.event.pull_request.labels.*.name, 'no-release')
    runs-on: blacksmith-4vcpu-ubuntu-2404
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check changelog for release marker
        id: check
        run: |
          # Check if CHANGELOG.md has [Unreleased:*] or content under [Unreleased]
          if grep -q "^## \[Unreleased" CHANGELOG.md; then
            # Extract the release type from changelog
            CHANGELOG_HEADER=$(grep "^## \[Unreleased" CHANGELOG.md | head -1)

            if echo "$CHANGELOG_HEADER" | grep -qi "\[Unreleased:major\]"; then
              RELEASE_TYPE="major"
            elif echo "$CHANGELOG_HEADER" | grep -qi "\[Unreleased:minor\]"; then
              RELEASE_TYPE="minor"
            else
              # Default to patch for [Unreleased] or [Unreleased:patch]
              RELEASE_TYPE="patch"
            fi

            # Check if there's actual content under Unreleased section
            # Extract content between [Unreleased] and next version header
            UNRELEASED_CONTENT=$(sed -n '/^## \[Unreleased/,/^## \[0-9/p' CHANGELOG.md | sed '$d' | tail -n +2)

            if [ -z "$(echo "$UNRELEASED_CONTENT" | grep -v '^[[:space:]]*$')" ]; then
              echo "should_release=false" >> $GITHUB_OUTPUT
              echo "No content under [Unreleased] - skipping release"
            else
              echo "should_release=true" >> $GITHUB_OUTPUT
              echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
              echo "Detected release type: $RELEASE_TYPE"
            fi
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "No [Unreleased] section found - skipping release"
          fi

      - name: Determine version bump
        if: steps.check.outputs.should_release == 'true'
        id: bump
        run: |
          # Get current version (strip 'v' prefix and any suffix)
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.6.4")
          CURRENT_VERSION=${CURRENT_TAG#v}
          CURRENT_VERSION=${CURRENT_VERSION%%-*}

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Determine bump type from changelog
          RELEASE_TYPE="${{ steps.check.outputs.release_type }}"

          if [ "$RELEASE_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$RELEASE_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            # Default: patch bump
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEW_VERSION"

      - name: Update changelog
        if: steps.check.outputs.should_release == 'true'
        run: |
          NEW_VERSION="${{ steps.bump.outputs.new_version }}"
          VERSION_NO_V="${NEW_VERSION#v}"
          TODAY=$(date +%Y-%m-%d)

          # Replace [Unreleased*] with versioned header and add new [Unreleased] section
          # Use perl for cross-platform compatibility
          perl -i -pe "s/^## \[Unreleased[^\]]*\]/## [Unreleased]\n\n## [$VERSION_NO_V] â€“ $TODAY/" CHANGELOG.md

          echo "Updated CHANGELOG.md with version $VERSION_NO_V"

      - name: Commit changelog update
        if: steps.check.outputs.should_release == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          git commit -m "Update changelog for ${{ steps.bump.outputs.new_version }}"
          git push origin main

      - name: Create and push tag
        if: steps.check.outputs.should_release == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.bump.outputs.new_version }}" -m "Release ${{ steps.bump.outputs.new_version }}"
          git push origin "${{ steps.bump.outputs.new_version }}"

      - name: Extract changelog content
        if: steps.check.outputs.should_release == 'true'
        id: changelog
        run: |
          VERSION_NO_V="${{ steps.bump.outputs.new_version }}"
          VERSION_NO_V="${VERSION_NO_V#v}"

          # Extract content for this version from updated CHANGELOG.md
          # Get content between this version header and the next version header
          CHANGELOG_CONTENT=$(sed -n "/^## \[$VERSION_NO_V\]/,/^## \[/p" CHANGELOG.md | sed '$d' | tail -n +2)

          # Save to file to preserve newlines
          echo "$CHANGELOG_CONTENT" > /tmp/changelog_extract.md

          echo "Extracted changelog content for $VERSION_NO_V"

      - name: Create GitHub Release
        if: steps.check.outputs.should_release == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const newVersion = '${{ steps.bump.outputs.new_version }}';
            const prNumber = context.payload.pull_request.number;
            const prTitle = context.payload.pull_request.title;

            // Read changelog content
            let changelogContent = '';
            try {
              changelogContent = fs.readFileSync('/tmp/changelog_extract.md', 'utf8').trim();
            } catch (err) {
              console.log('Could not read changelog extract:', err);
              changelogContent = `Automated release from PR #${prNumber}: ${prTitle}`;
            }

            // Build release body
            const releaseBody = changelogContent || `Automated release from PR #${prNumber}: ${prTitle}`;

            github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: newVersion,
              name: newVersion,
              body: releaseBody,
              draft: false,
              prerelease: true
            });
