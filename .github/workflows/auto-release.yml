name: Auto Release

# This workflow automatically creates releases when commits land on main.
# It uses a fine-grained Personal Access Token (PAT_TOKEN) to bypass branch protection.
#
# PAT Configuration:
# - Name: "Blue Banded Bee Release Automation"
# - Type: Fine-grained token
# - Expiration: 365 days (expires ~1 year from creation)
# - Repository: Harvey-AU/blue-banded-bee
# - Permissions: Contents (read/write), Pull requests (read/write)
# - Location: https://github.com/settings/tokens?type=beta
# - Secret: https://github.com/Harvey-AU/blue-banded-bee/settings/secrets/actions
#
# When to renew:
# - GitHub will email you before expiration
# - Create new token with same permissions
# - Update PAT_TOKEN secret with new value

on:
  push:
    branches:
      - main

jobs:
  auto-tag:
    name: Auto Tag Release
    runs-on: blacksmith-4vcpu-ubuntu-2404
    permissions:
      contents: write
      pull-requests: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.PAT_TOKEN }}

      - name: Check for no-release label
        id: skip
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const sha = context.sha;
            let shouldSkip = false;

            try {
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: sha
              });

              if (prs && prs.length > 0) {
                shouldSkip = prs.some(pr =>
                  pr.labels && pr.labels.some(label => label.name === 'no-release')
                );
              }
            } catch (error) {
              core.warning(`Could not check PR labels: ${error.message}`);
            }

            core.setOutput('should_skip', shouldSkip ? 'true' : 'false');

      - name: Check changelog for release marker
        id: check
        run: |
          # Check if CHANGELOG.md has [Unreleased:*] and non-empty content under it
          if grep -q "^## \[Unreleased" CHANGELOG.md; then
            # Extract the release type from changelog
            CHANGELOG_HEADER=$(grep "^## \[Unreleased" CHANGELOG.md | head -1)

            if echo "$CHANGELOG_HEADER" | grep -qi "\[Unreleased:major\]"; then
              RELEASE_TYPE="major"
            elif echo "$CHANGELOG_HEADER" | grep -qi "\[Unreleased:minor\]"; then
              RELEASE_TYPE="minor"
            else
              # Default to patch for [Unreleased] or [Unreleased:patch]
              RELEASE_TYPE="patch"
            fi

            # Extract content between [Unreleased] and next version header
            UNRELEASED_CONTENT=$(awk '/^## \[Unreleased/ {flag=1; next} /^## \[[0-9]/ {flag=0} flag' CHANGELOG.md)

            # Only create release when there is actual content (non-blank)
            if [ -z "$(echo "$UNRELEASED_CONTENT" | grep -v '^[[:space:]]*$')" ]; then
              echo "should_release=false" >> $GITHUB_OUTPUT
              echo "Unreleased section is empty - skipping release"
            else
              echo "should_release=true" >> $GITHUB_OUTPUT
              echo "release_type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
              echo "Detected release type: $RELEASE_TYPE"
            fi
          else
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "No [Unreleased] section found - skipping release"
          fi

      - name: Determine version bump
        if:
          steps.check.outputs.should_release == 'true' &&
          steps.skip.outputs.should_skip != 'true'
        id: bump
        run: |
          # Get current version (strip 'v' prefix and any suffix)
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.6.4")
          CURRENT_VERSION=${CURRENT_TAG#v}
          CURRENT_VERSION=${CURRENT_VERSION%%-*}

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

          # Determine bump type from changelog
          RELEASE_TYPE="${{ steps.check.outputs.release_type }}"

          if [ "$RELEASE_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$RELEASE_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            # Default: patch bump
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEW_VERSION"

      - name: Update changelog
        if:
          steps.check.outputs.should_release == 'true' &&
          steps.skip.outputs.should_skip != 'true'
        run: |
          NEW_VERSION="${{ steps.bump.outputs.new_version }}"
          VERSION_NO_V="${NEW_VERSION#v}"
          TODAY=$(date +%Y-%m-%d)

          # Replace [Unreleased*] with versioned header and add new [Unreleased] section
          # Use perl for cross-platform compatibility
          perl -i -pe "s/^## \[Unreleased[^\]]*\]/## [Unreleased]\n\n## [$VERSION_NO_V] â€“ $TODAY/" CHANGELOG.md

          echo "Updated CHANGELOG.md with version $VERSION_NO_V"

      - name: Commit changelog update
        if:
          steps.check.outputs.should_release == 'true' &&
          steps.skip.outputs.should_skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add CHANGELOG.md
          # Amend the merge commit to include changelog update
          git commit --amend --no-edit
          git push --force-with-lease origin main

      - name: Create and push tag
        if:
          steps.check.outputs.should_release == 'true' &&
          steps.skip.outputs.should_skip != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "${{ steps.bump.outputs.new_version }}" -m "Release ${{ steps.bump.outputs.new_version }}"
          git push origin "${{ steps.bump.outputs.new_version }}"

      - name: Extract changelog content
        if:
          steps.check.outputs.should_release == 'true' &&
          steps.skip.outputs.should_skip != 'true'
        id: changelog
        run: |
          VERSION_NO_V="${{ steps.bump.outputs.new_version }}"
          VERSION_NO_V="${VERSION_NO_V#v}"

          # Extract content for this version from updated CHANGELOG.md
          # Get content between this version header and the next version header
          # Use awk to stop before the next version header (more reliable than sed)
          CHANGELOG_CONTENT=$(awk "/^## \[$VERSION_NO_V\]/ {flag=1; next} /^## \[/ {flag=0} flag" CHANGELOG.md)

          # Save to file to preserve newlines
          echo "$CHANGELOG_CONTENT" > /tmp/changelog_extract.md

          echo "Extracted changelog content for $VERSION_NO_V"

      - name: Create GitHub Release
        if:
          steps.check.outputs.should_release == 'true' &&
          steps.skip.outputs.should_skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const newVersion = '${{ steps.bump.outputs.new_version }}';
            const prNumber = context.payload.pull_request && context.payload.pull_request.number;
            const prTitle = context.payload.pull_request && context.payload.pull_request.title;
            const commitSha = context.sha;
            const commitMessage = context.payload.head_commit && context.payload.head_commit.message;

            // Read changelog content
            let changelogContent = '';
            try {
              changelogContent = fs.readFileSync('/tmp/changelog_extract.md', 'utf8').trim();
            } catch (err) {
              console.log('Could not read changelog extract:', err);
              changelogContent = `Automated release from PR #${prNumber}: ${prTitle}`;
            }

            // Build release body
            const fallback = prNumber
              ? `Automated release from PR #${prNumber}: ${prTitle}`
              : `Automated release from ${commitSha}: ${commitMessage || 'Update'}`;

            const releaseBody = changelogContent || fallback;

            github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: newVersion,
              name: newVersion,
              body: releaseBody,
              draft: false,
              prerelease: true
            });
