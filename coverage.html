
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/Harvey-AU/blue-banded-bee/cmd/app/main.go (12.3%)</option>
				
				<option value="file1">github.com/Harvey-AU/blue-banded-bee/cmd/test_jobs/main.go (0.0%)</option>
				
				<option value="file2">github.com/Harvey-AU/blue-banded-bee/internal/api/admin.go (40.0%)</option>
				
				<option value="file3">github.com/Harvey-AU/blue-banded-bee/internal/api/auth.go (41.4%)</option>
				
				<option value="file4">github.com/Harvey-AU/blue-banded-bee/internal/api/errors.go (100.0%)</option>
				
				<option value="file5">github.com/Harvey-AU/blue-banded-bee/internal/api/handlers.go (86.0%)</option>
				
				<option value="file6">github.com/Harvey-AU/blue-banded-bee/internal/api/jobs.go (82.2%)</option>
				
				<option value="file7">github.com/Harvey-AU/blue-banded-bee/internal/api/middleware.go (100.0%)</option>
				
				<option value="file8">github.com/Harvey-AU/blue-banded-bee/internal/api/response.go (94.1%)</option>
				
				<option value="file9">github.com/Harvey-AU/blue-banded-bee/internal/api/test_mocks.go (58.9%)</option>
				
				<option value="file10">github.com/Harvey-AU/blue-banded-bee/internal/auth/config.go (100.0%)</option>
				
				<option value="file11">github.com/Harvey-AU/blue-banded-bee/internal/auth/middleware.go (48.1%)</option>
				
				<option value="file12">github.com/Harvey-AU/blue-banded-bee/internal/cache/cache.go (100.0%)</option>
				
				<option value="file13">github.com/Harvey-AU/blue-banded-bee/internal/crawler/config.go (100.0%)</option>
				
				<option value="file14">github.com/Harvey-AU/blue-banded-bee/internal/crawler/crawler.go (51.9%)</option>
				
				<option value="file15">github.com/Harvey-AU/blue-banded-bee/internal/crawler/robots.go (82.9%)</option>
				
				<option value="file16">github.com/Harvey-AU/blue-banded-bee/internal/crawler/sitemap.go (80.3%)</option>
				
				<option value="file17">github.com/Harvey-AU/blue-banded-bee/internal/db/dashboard.go (20.2%)</option>
				
				<option value="file18">github.com/Harvey-AU/blue-banded-bee/internal/db/db.go (56.8%)</option>
				
				<option value="file19">github.com/Harvey-AU/blue-banded-bee/internal/db/dsn_helper.go (100.0%)</option>
				
				<option value="file20">github.com/Harvey-AU/blue-banded-bee/internal/db/health.go (0.0%)</option>
				
				<option value="file21">github.com/Harvey-AU/blue-banded-bee/internal/db/pages.go (0.0%)</option>
				
				<option value="file22">github.com/Harvey-AU/blue-banded-bee/internal/db/queue.go (89.5%)</option>
				
				<option value="file23">github.com/Harvey-AU/blue-banded-bee/internal/db/users.go (0.0%)</option>
				
				<option value="file24">github.com/Harvey-AU/blue-banded-bee/internal/jobs/manager.go (48.8%)</option>
				
				<option value="file25">github.com/Harvey-AU/blue-banded-bee/internal/jobs/test_helpers.go (31.0%)</option>
				
				<option value="file26">github.com/Harvey-AU/blue-banded-bee/internal/jobs/worker.go (26.9%)</option>
				
				<option value="file27">github.com/Harvey-AU/blue-banded-bee/internal/mocks/auth_client.go (0.0%)</option>
				
				<option value="file28">github.com/Harvey-AU/blue-banded-bee/internal/mocks/crawler.go (16.7%)</option>
				
				<option value="file29">github.com/Harvey-AU/blue-banded-bee/internal/mocks/db.go (0.0%)</option>
				
				<option value="file30">github.com/Harvey-AU/blue-banded-bee/internal/mocks/db_queue.go (16.7%)</option>
				
				<option value="file31">github.com/Harvey-AU/blue-banded-bee/internal/mocks/http_client.go (0.0%)</option>
				
				<option value="file32">github.com/Harvey-AU/blue-banded-bee/internal/mocks/worker_pool.go (0.0%)</option>
				
				<option value="file33">github.com/Harvey-AU/blue-banded-bee/internal/testutil/testutil.go (0.0%)</option>
				
				<option value="file34">github.com/Harvey-AU/blue-banded-bee/internal/util/url.go (86.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "net"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "sync"
        "syscall"
        "time"

        "runtime/trace"

        "github.com/Harvey-AU/blue-banded-bee/internal/api"
        "github.com/Harvey-AU/blue-banded-bee/internal/crawler"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/Harvey-AU/blue-banded-bee/internal/jobs"
        "github.com/getsentry/sentry-go"
        "github.com/joho/godotenv"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
        "golang.org/x/time/rate"
)

// Config holds the application configuration loaded from environment variables
type Config struct {
        Port                  string // HTTP port to listen on
        Env                   string // Environment (development/production)
        SentryDSN             string // Sentry DSN for error tracking
        LogLevel              string // Log level (debug, info, warn, error)
        FlightRecorderEnabled bool   // Flight recorder for performance debugging
}

func main() <span class="cov0" title="0">{
        // Load .env file if it exists
        godotenv.Load()

        // Load configuration
        config := &amp;Config{
                Port:                  getEnvWithDefault("PORT", "8080"),
                Env:                   getEnvWithDefault("APP_ENV", "development"),
                SentryDSN:             os.Getenv("SENTRY_DSN"),
                LogLevel:              getEnvWithDefault("LOG_LEVEL", "info"),
                FlightRecorderEnabled: getEnvWithDefault("FLIGHT_RECORDER_ENABLED", "false") == "true",
        }

        // Start flight recorder if enabled
        if config.FlightRecorderEnabled </span><span class="cov0" title="0">{
                f, err := os.Create("trace.out")
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("failed to create trace file")
                }</span>

                <span class="cov0" title="0">if err := trace.Start(f); err != nil </span><span class="cov0" title="0">{
                        log.Fatal().Err(err).Msg("failed to start flight recorder")
                }</span>
                <span class="cov0" title="0">log.Info().Msg("Flight recorder enabled, writing to trace.out")

                // Defer closing the trace and the file to the shutdown sequence
                defer func() </span><span class="cov0" title="0">{
                        trace.Stop()
                        f.Close()
                        log.Info().Msg("Flight recorder stopped and trace file closed.")
                }</span>()
        }

        <span class="cov0" title="0">setupLogging(config)

        // Initialise Sentry for error tracking and performance monitoring
        if config.SentryDSN != "" </span><span class="cov0" title="0">{
                err := sentry.Init(sentry.ClientOptions{
                        Dsn:         config.SentryDSN,
                        Environment: config.Env,
                        TracesSampleRate: func() float64 </span><span class="cov0" title="0">{
                                if config.Env == "production" </span><span class="cov0" title="0">{
                                        return 0.1 // 10% sampling in production
                                }</span>
                                <span class="cov0" title="0">return 1.0</span> // 100% sampling in development
                        }(),
                        AttachStacktrace: true,
                        Debug:            config.Env == "development",
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Msg("Failed to initialise Sentry")
                }</span> else<span class="cov0" title="0"> {
                        log.Info().Str("environment", config.Env).Msg("Sentry initialised successfully")
                        // Ensure Sentry flushes before application exits
                        defer sentry.Flush(2 * time.Second)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Warn().Msg("Sentry DSN not configured, error tracking disabled")
        }</span>

        // Connect to PostgreSQL
        <span class="cov0" title="0">pgDB, err := db.InitFromEnv()
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Fatal().Err(err).Msg("Failed to connect to PostgreSQL database")
        }</span>
        <span class="cov0" title="0">defer pgDB.Close()

        log.Info().Msg("Connected to PostgreSQL database")

        // Initialise crawler
        crawlerConfig := crawler.DefaultConfig()
        cr := crawler.New(crawlerConfig) // QUESTION: Should we change cr to crawler for clarity, as others have clearer names.

        // Create database queue for operations
        dbQueue := db.NewDbQueue(pgDB)

        // Create a worker pool for task processing
        var jobWorkers int = 5 // QUESTION: Set in env or dynamically - consider impact throughout app where worker pool sizing is set.
        workerPool := jobs.NewWorkerPool(pgDB.GetDB(), dbQueue, cr, jobWorkers, pgDB.GetConfig())

        // Create job manager
        jobsManager := jobs.NewJobManager(pgDB.GetDB(), dbQueue, cr, workerPool)

        // Set the job manager in the worker pool for duplicate checking
        workerPool.SetJobManager(jobsManager)

        // Start the worker pool
        workerPool.Start(context.Background())
        defer workerPool.Stop()

        // Start a goroutine to monitor job completion
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(5 * time.Second)
                defer ticker.Stop()

                // Use for-range instead of for-select for better readability
                for range ticker.C </span><span class="cov0" title="0">{
                        // Check for jobs that should be marked complete
                        rows, err := pgDB.GetDB().Query(`
                                UPDATE jobs 
                                SET status = 'completed', completed_at = NOW()
                                WHERE (completed_tasks + failed_tasks) &gt;= (total_tasks - COALESCE(skipped_tasks, 0))
                                  AND status = 'running'
                                RETURNING id
                        `)
                        if err != nil </span><span class="cov0" title="0">{
                                sentry.CaptureException(err)
                                log.Error().Err(err).Msg("Failed to update completed jobs")
                                continue</span>
                        }

                        // Log completed jobs
                        <span class="cov0" title="0">for rows.Next() </span><span class="cov0" title="0">{
                                var jobID string
                                if err := rows.Scan(&amp;jobID); err == nil </span><span class="cov0" title="0">{
                                        log.Info().Str("job_id", jobID).Msg("Job marked as completed")
                                }</span>
                        }
                        <span class="cov0" title="0">rows.Close()</span>
                }
        }()

        // Create a rate limiter
        <span class="cov0" title="0">limiter := newRateLimiter()

        // Create API handler with dependencies
        apiHandler := api.NewHandler(pgDB, jobsManager)

        // Create HTTP multiplexer
        mux := http.NewServeMux()

        // Setup API routes
        apiHandler.SetupRoutes(mux)

        // Create middleware stack
        var handler http.Handler = mux

        // Add rate limiting
        handler = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ip := getClientIP(r)
                if !limiter.getLimiter(ip).Allow() </span><span class="cov0" title="0">{
                        api.WriteErrorMessage(w, r, "Too many requests", http.StatusTooManyRequests, api.ErrCodeRateLimit)
                        return
                }</span>
                <span class="cov0" title="0">mux.ServeHTTP(w, r)</span>
        })

        // Add middleware in reverse order (outermost first)
        <span class="cov0" title="0">handler = api.LoggingMiddleware(handler)
        handler = api.RequestIDMiddleware(handler)
        handler = api.CrossOriginProtectionMiddleware(handler)
        handler = api.CORSMiddleware(handler)

        // Create a new HTTP server
        server := &amp;http.Server{
                Addr:    ":" + config.Port,
                Handler: handler,
        }

        // Channel to listen for termination signals
        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

        // Channel to signal when the server has shut down
        done := make(chan struct{})

        go func() </span><span class="cov0" title="0">{
                &lt;-stop
                log.Info().Msg("Shutting down server...")

                // Create shutdown context with timeout
                ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)

                defer cancel()

                // Stop accepting new requests
                if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                        sentry.CaptureException(err)
                        log.Error().Err(err).Msg("Server forced to shutdown")
                }</span>

                <span class="cov0" title="0">close(done)</span>
        }()

        // Start the server
        <span class="cov0" title="0">log.Info().Str("port", config.Port).Msg("Starting server")
        if err := server.ListenAndServe(); err != http.ErrServerClosed </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Fatal().Err(err).Msg("Server error")
        }</span>

        <span class="cov0" title="0">&lt;-done // Wait for the shutdown process to complete
        log.Info().Msg("Server stopped")</span>
}

// getEnvWithDefault retrieves an environment variable or returns a default value if not set
func getEnvWithDefault(key, defaultValue string) string <span class="cov0" title="0">{
        value := os.Getenv(key)
        if value == "" </span><span class="cov0" title="0">{
                return defaultValue
        }</span>
        <span class="cov0" title="0">return value</span>
}

// setupLogging configures the logging system
func setupLogging(config *Config) <span class="cov0" title="0">{
        // Configure log level
        level, err := zerolog.ParseLevel(config.LogLevel)
        if err != nil </span><span class="cov0" title="0">{
                level = zerolog.WarnLevel
        }</span>
        <span class="cov0" title="0">zerolog.SetGlobalLevel(level)

        // Use console writer in development
        if config.Env == "development" </span><span class="cov0" title="0">{
                log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339})
        }</span> else<span class="cov0" title="0"> {
                // In production, use a more verbose JSON format that works well with Fly.io logs
                log.Logger = zerolog.New(os.Stdout).
                        With().
                        Timestamp().
                        Str("service", "blue-banded-bee").
                        Logger()
        }</span>
}

// RateLimiter represents a rate limiting system based on client IP addresses
type RateLimiter struct {
        limits   map[string]*IPRateLimiter
        mu       sync.Mutex
        rate     rate.Limit
        capacity int
}

// IPRateLimiter wraps a token bucket rate limiter specific to an IP address
type IPRateLimiter struct {
        limiter *rate.Limiter
}

// newRateLimiter creates a new rate limiter with default settings
func newRateLimiter() *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                limits:   make(map[string]*IPRateLimiter),
                rate:     rate.Limit(5), // 5 requests per second
                capacity: 5,             // 5 burst capacity
        }
}</span>

// getLimiter returns the rate limiter for a specific IP address
func (rl *RateLimiter) getLimiter(ip string) *IPRateLimiter <span class="cov8" title="1">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        limiter, exists := rl.limits[ip]
        if !exists </span><span class="cov8" title="1">{
                limiter = &amp;IPRateLimiter{
                        limiter: rate.NewLimiter(rl.rate, rl.capacity),
                }
                rl.limits[ip] = limiter
        }</span>

        <span class="cov8" title="1">return limiter</span>
}

// Allow checks if a request from this IP should be allowed
func (ipl *IPRateLimiter) Allow() bool <span class="cov8" title="1">{
        return ipl.limiter.Allow()
}</span>

// getClientIP extracts the client's IP address from a request
func getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // Check for X-Forwarded-For header first (for clients behind proxies)
        ip := r.Header.Get("X-Forwarded-For")
        if ip != "" </span><span class="cov8" title="1">{
                // X-Forwarded-For might contain multiple IPs, take the first one
                ips := strings.Split(ip, ",")
                ip = strings.TrimSpace(ips[0])
                return ip
        }</span>

        // If no X-Forwarded-For, use RemoteAddr
        <span class="cov0" title="0">ip, _, _ = net.SplitHostPort(r.RemoteAddr)
        return ip</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "os"
        "strconv"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/crawler"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/Harvey-AU/blue-banded-bee/internal/jobs"
        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/joho/godotenv"
        "github.com/rs/zerolog"
        "github.com/rs/zerolog/log"
)

/**
 * Job Queue Test Utility
 *
 * This program tests the job queue system by:
 * 1. Setting up a database connection
 * 2. Initializing the job queue schema
 * 3. Creating a worker pool with multiple workers
 * 4. Creating and starting a test job
 * 5. Monitoring job progress until completion
 *
 * Usage:
 *   go run cmd/test_jobs/main.go
 *
 * The program expects DATABASE_URL environment variable to be set in the .env file.
 */

func main() <span class="cov0" title="0">{
        // Set up logging
        log.Logger = log.Output(zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339})
        zerolog.SetGlobalLevel(zerolog.InfoLevel)

        // Load environment variables
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Error loading .env file")
        }</span>

        // Get database details from environment
        <span class="cov0" title="0">dbURL := os.Getenv("DATABASE_URL")
        if dbURL == "" </span><span class="cov0" title="0">{
                log.Fatal().Msg("DATABASE_URL must be set")
        }</span>

        // Connect to database
        <span class="cov0" title="0">log.Info().Msg("Connecting to PostgreSQL database...")
        database, err := db.InitFromEnv()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to connect to database")
        }</span>
        <span class="cov0" title="0">defer database.Close()

        // Set up crawler
        crawler := crawler.New(nil)

        // Create database queue for operations
        dbQueue := db.NewDbQueue(database)

        // Create worker pool
        var jobWorkers int = 3
        dbConfig := &amp;db.Config{
                DatabaseURL: dbURL,
        }
        workerPool := jobs.NewWorkerPool(database.GetDB(), dbQueue, crawler, jobWorkers, dbConfig)
        workerPool.Start(context.Background())
        defer workerPool.Stop()

        log.Info().Msg("Worker pool started with " + strconv.Itoa(jobWorkers) + " workers")

        // Create a test job
        jobManager := jobs.NewJobManager(database.GetDB(), dbQueue, crawler, workerPool)

        // Set up job options
        jobOptions := &amp;jobs.JobOptions{
                Domain:      "example.com",
                Concurrency: 2,
                FindLinks:   true,
                MaxPages:    10,
                UseSitemap:  true,
        }

        // Submit the job to the queue
        job, err := jobManager.CreateJob(context.Background(), jobOptions)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Err(err).Msg("Failed to create job")
        }</span>

        <span class="cov0" title="0">log.Info().Str("job_id", job.ID).Msg("Created test job")

        // Add the job to the worker pool - it will automatically start processing pending tasks
        workerPool.AddJob(job.ID, jobOptions)
        
        log.Info().Str("job_id", job.ID).Msg("Added job to worker pool, monitoring progress...")

        // Monitor job progress
        for </span><span class="cov0" title="0">{
                time.Sleep(1 * time.Second)

                job, err := jobManager.GetJobStatus(context.Background(), job.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to get job status")
                        continue</span>
                }

                <span class="cov0" title="0">log.Info().
                        Str("status", string(job.Status)).
                        Float64("progress", job.Progress).
                        Int("completed", job.CompletedTasks).
                        Int("failed", job.FailedTasks).
                        Int("total", job.TotalTasks).
                        Msg("Job progress")

                if job.Status == jobs.JobStatusCompleted || job.Status == jobs.JobStatusFailed </span><span class="cov0" title="0">{
                        log.Info().Str("final_status", string(job.Status)).Msg("Job finished")
                        break</span>
                }

                <span class="cov0" title="0">if job.Status == jobs.JobStatusRunning &amp;&amp; job.Progress &gt;= 100.0 </span><span class="cov0" title="0">{
                        log.Info().Msg("Job complete")
                        break</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package api

import (
        "net/http"
        "os"

        "github.com/Harvey-AU/blue-banded-bee/internal/auth"
        "github.com/getsentry/sentry-go"
        "github.com/rs/zerolog/log"
)

// AdminResetDatabase handles the admin database reset endpoint
// Requires valid JWT with admin role and explicit environment enablement
func (h *Handler) AdminResetDatabase(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov0" title="0">{
                MethodNotAllowed(w, r)
                return
        }</span>

        // Check if this is running in development environment
        <span class="cov8" title="1">env := os.Getenv("APP_ENV")
        if env == "production" </span><span class="cov8" title="1">{
                NotFound(w, r, "Not found") // Return 404 in production to hide the endpoint
                return
        }</span>

        // Require explicit enablement
        <span class="cov8" title="1">if os.Getenv("ALLOW_DB_RESET") != "true" </span><span class="cov8" title="1">{
                Forbidden(w, r, "Database reset not enabled. Set ALLOW_DB_RESET=true to enable")
                return
        }</span>

        // Get user claims from context (set by AuthMiddleware)
        <span class="cov8" title="1">claims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "Authentication required for admin endpoint")
                return
        }</span>

        // Verify system admin role
        <span class="cov0" title="0">if !hasSystemAdminRole(claims) </span><span class="cov0" title="0">{
                log.Warn().
                        Str("user_id", claims.UserID).
                        Str("email", claims.Email).
                        Msg("Non-system-admin user attempted to access database reset endpoint")
                Forbidden(w, r, "System administrator privileges required")
                return
        }</span>

        // Verify user exists in database
        <span class="cov0" title="0">user, err := h.DB.GetUser(claims.UserID)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("user_id", claims.UserID).Msg("Failed to verify admin user")
                Unauthorised(w, r, "User verification failed")
                return
        }</span>

        // Log the admin action with full context
        <span class="cov0" title="0">log.Warn().
                Str("user_id", user.ID).
                Str("email", user.Email).
                Str("org_id", func() string </span><span class="cov0" title="0">{
                        if user.OrganisationID != nil </span><span class="cov0" title="0">{
                                return *user.OrganisationID
                        }</span>
                        <span class="cov0" title="0">return "none"</span>
                }()).
                Str("remote_addr", r.RemoteAddr).
                Str("user_agent", r.Header.Get("User-Agent")).
                Msg("Admin database reset requested")

        // Capture in Sentry for audit trail
        <span class="cov0" title="0">sentry.WithScope(func(scope *sentry.Scope) </span><span class="cov0" title="0">{
                scope.SetTag("event_type", "admin_action")
                scope.SetTag("action", "database_reset")
                scope.SetUser(sentry.User{
                        ID:    user.ID,
                        Email: user.Email,
                })
                scope.SetContext("admin_action", map[string]interface{}{
                        "endpoint":   "/admin/reset-db",
                        "user_agent": r.Header.Get("User-Agent"),
                        "ip_address": r.RemoteAddr,
                })
                sentry.CaptureMessage("Admin database reset action")
        }</span>)

        // Perform the database reset
        <span class="cov0" title="0">if err := h.DB.ResetSchema(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).
                        Str("user_id", user.ID).
                        Msg("Failed to reset database schema")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("user_id", user.ID).
                Str("email", user.Email).
                Msg("Database schema reset completed by admin")

        WriteSuccess(w, r, nil, "Database schema reset successfully")</span>
}

// hasSystemAdminRole checks if the user has system administrator privileges via app_metadata
// This is distinct from organisation-level admin roles - system admins are Blue Banded Bee operators
// who have elevated privileges for system-level operations like database resets
func hasSystemAdminRole(claims *auth.UserClaims) bool <span class="cov8" title="1">{
        if claims == nil || claims.AppMetadata == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for system_role = "system_admin" in app_metadata
        <span class="cov8" title="1">if systemRole, exists := claims.AppMetadata["system_role"]; exists </span><span class="cov8" title="1">{
                if roleStr, ok := systemRole.(string); ok &amp;&amp; roleStr == "system_admin" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "strings"

        emailverifier "github.com/AfterShip/email-verifier"
        "github.com/Harvey-AU/blue-banded-bee/internal/auth"
        "github.com/getsentry/sentry-go"
        "github.com/rs/zerolog/log"
)

var (
        verifier = emailverifier.NewVerifier()
)

// AuthRegisterRequest represents a user registration request
type AuthRegisterRequest struct {
        UserID   string  `json:"user_id"`
        Email    string  `json:"email"`
        FullName *string `json:"full_name,omitempty"`
        OrgName  *string `json:"org_name,omitempty"`
}

// AuthSessionRequest represents a session validation request
type AuthSessionRequest struct {
        Token string `json:"token"`
}

// UserResponse represents a user in API responses
type UserResponse struct {
        ID             string  `json:"id"`
        Email          string  `json:"email"`
        FullName       *string `json:"full_name"`
        OrganisationID *string `json:"organisation_id"`
        CreatedAt      string  `json:"created_at"`
        UpdatedAt      string  `json:"updated_at"`
}

// OrganisationResponse represents an organisation in API responses
type OrganisationResponse struct {
        ID        string `json:"id"`
        Name      string `json:"name"`
        CreatedAt string `json:"created_at"`
        UpdatedAt string `json:"updated_at"`
}

// AuthRegister handles POST /v1/auth/register
func (h *Handler) AuthRegister(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                MethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov8" title="1">var req AuthRegisterRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                BadRequest(w, r, "Invalid JSON request body")
                return
        }</span>

        <span class="cov8" title="1">if req.UserID == "" || req.Email == "" </span><span class="cov8" title="1">{
                BadRequest(w, r, "user_id and email are required")
                return
        }</span>

        <span class="cov0" title="0">var orgName string

        // 1. Org name if explicitly provided
        if req.OrgName != nil &amp;&amp; *req.OrgName != "" </span><span class="cov0" title="0">{
                orgName = *req.OrgName
        }</span>

        // 2. Domain name if not generic (and org name not already set)
        <span class="cov0" title="0">if orgName == "" </span><span class="cov0" title="0">{
                result, err := verifier.Verify(req.Email)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Msg("Email verifier failed")
                }</span> else<span class="cov0" title="0"> if !result.Free </span><span class="cov0" title="0">{
                        // Not a free provider, so use the domain name
                        if emailParts := strings.Split(req.Email, "@"); len(emailParts) == 2 </span><span class="cov0" title="0">{
                                domain := emailParts[1]
                                domainName := strings.Split(domain, ".")[0]
                                if len(domainName) &gt; 0 </span><span class="cov0" title="0">{
                                        // Capitalise first letter of domain name
                                        orgName = strings.ToUpper(string(domainName[0])) + domainName[1:]
                                }</span>
                        }
                }
        }

        // 3. Person's full name as fallback
        <span class="cov0" title="0">if orgName == "" &amp;&amp; req.FullName != nil &amp;&amp; *req.FullName != "" </span><span class="cov0" title="0">{
                orgName = *req.FullName
        }</span>

        // 4. Final default if nothing else worked
        <span class="cov0" title="0">if orgName == "" </span><span class="cov0" title="0">{
                orgName = "Personal Organisation"
        }</span>

        // Create user with organisation automatically
        <span class="cov0" title="0">user, org, err := h.DB.CreateUser(req.UserID, req.Email, req.FullName, orgName)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Error().Err(err).Str("user_id", req.UserID).Msg("Failed to create user with organisation")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">userResp := UserResponse{
                ID:             user.ID,
                Email:          user.Email,
                FullName:       user.FullName,
                OrganisationID: user.OrganisationID,
                CreatedAt:      user.CreatedAt.Format("2006-01-02T15:04:05Z"),
                UpdatedAt:      user.UpdatedAt.Format("2006-01-02T15:04:05Z"),
        }

        orgResp := OrganisationResponse{
                ID:        org.ID,
                Name:      org.Name,
                CreatedAt: org.CreatedAt.Format("2006-01-02T15:04:05Z"),
                UpdatedAt: org.UpdatedAt.Format("2006-01-02T15:04:05Z"),
        }

        WriteCreated(w, r, map[string]interface{}{
                "user":         userResp,
                "organisation": orgResp,
        }, "User registered successfully")</span>
}

// AuthSession handles POST /v1/auth/session
func (h *Handler) AuthSession(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                MethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov8" title="1">var req AuthSessionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                BadRequest(w, r, "Invalid JSON request body")
                return
        }</span>

        <span class="cov8" title="1">if req.Token == "" </span><span class="cov8" title="1">{
                BadRequest(w, r, "token is required")
                return
        }</span>

        <span class="cov8" title="1">sessionInfo := auth.ValidateSession(req.Token)
        WriteSuccess(w, r, sessionInfo, "Session validated")</span>
}

// AuthProfile handles GET /v1/auth/profile
func (h *Handler) AuthProfile(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                MethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov8" title="1">userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "User information not found")
                return
        }</span>

        // Auto-create user if they don't exist
        <span class="cov0" title="0">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov0" title="0">userResp := UserResponse{
                ID:             user.ID,
                Email:          user.Email,
                FullName:       user.FullName,
                OrganisationID: user.OrganisationID,
                CreatedAt:      user.CreatedAt.Format("2006-01-02T15:04:05Z"),
                UpdatedAt:      user.UpdatedAt.Format("2006-01-02T15:04:05Z"),
        }

        response := map[string]interface{}{
                "user": userResp,
        }

        // Get organisation if user has one
        if user.OrganisationID != nil </span><span class="cov0" title="0">{
                org, err := h.DB.GetOrganisation(*user.OrganisationID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Str("organisation_id", *user.OrganisationID).Msg("Failed to get organisation")
                }</span> else<span class="cov0" title="0"> {
                        orgResp := OrganisationResponse{
                                ID:        org.ID,
                                Name:      org.Name,
                                CreatedAt: org.CreatedAt.Format("2006-01-02T15:04:05Z"),
                                UpdatedAt: org.UpdatedAt.Format("2006-01-02T15:04:05Z"),
                        }
                        response["organisation"] = orgResp
                }</span>
        }

        <span class="cov0" title="0">WriteSuccess(w, r, response, "Profile retrieved successfully")</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package api

import (
        "encoding/json"
        "net/http"

        "github.com/rs/zerolog/log"
)

// ErrorResponse represents a standardised error response
type ErrorResponse struct {
        Status    int    `json:"status"`
        Message   string `json:"message"`
        Code      string `json:"code,omitempty"`
        RequestID string `json:"request_id,omitempty"`
}

// ErrorCode represents standard error codes
type ErrorCode string

const (
        // Client errors (4xx)
        ErrCodeBadRequest       ErrorCode = "BAD_REQUEST"
        ErrCodeUnauthorised     ErrorCode = "UNAUTHORISED"
        ErrCodeForbidden        ErrorCode = "FORBIDDEN"
        ErrCodeNotFound         ErrorCode = "NOT_FOUND"
        ErrCodeMethodNotAllowed ErrorCode = "METHOD_NOT_ALLOWED"
        ErrCodeConflict         ErrorCode = "CONFLICT"
        ErrCodeValidation       ErrorCode = "VALIDATION_ERROR"
        ErrCodeRateLimit        ErrorCode = "RATE_LIMIT_EXCEEDED"

        // Server errors (5xx)
        ErrCodeInternal           ErrorCode = "INTERNAL_ERROR"
        ErrCodeServiceUnavailable ErrorCode = "SERVICE_UNAVAILABLE"
        ErrCodeDatabaseError      ErrorCode = "DATABASE_ERROR"
)

// WriteError writes a standardised error response
func WriteError(w http.ResponseWriter, r *http.Request, err error, status int, code ErrorCode) <span class="cov8" title="1">{
        requestID := GetRequestID(r)

        errResp := ErrorResponse{
                Status:    status,
                Message:   err.Error(),
                Code:      string(code),
                RequestID: requestID,
        }

        // Log the error with context
        log.Error().
                Err(err).
                Str("request_id", requestID).
                Str("method", r.Method).
                Str("path", r.URL.Path).
                Int("status", status).
                Str("code", string(code)).
                Msg("API error response")

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(errResp)
}</span>

// WriteErrorMessage writes a standardised error response with a custom message
func WriteErrorMessage(w http.ResponseWriter, r *http.Request, message string, status int, code ErrorCode) <span class="cov8" title="1">{
        requestID := GetRequestID(r)

        errResp := ErrorResponse{
                Status:    status,
                Message:   message,
                Code:      string(code),
                RequestID: requestID,
        }

        // Log the error with context
        log.Error().
                Str("request_id", requestID).
                Str("method", r.Method).
                Str("path", r.URL.Path).
                Int("status", status).
                Str("code", string(code)).
                Str("message", message).
                Msg("API error response")

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        json.NewEncoder(w).Encode(errResp)
}</span>

// Common error helpers for frequent use cases

// BadRequest responds with a 400 Bad Request error
func BadRequest(w http.ResponseWriter, r *http.Request, message string) <span class="cov8" title="1">{
        WriteErrorMessage(w, r, message, http.StatusBadRequest, ErrCodeBadRequest)
}</span>

// Unauthorised responds with a 401 Unauthorised error
func Unauthorised(w http.ResponseWriter, r *http.Request, message string) <span class="cov8" title="1">{
        WriteErrorMessage(w, r, message, http.StatusUnauthorized, ErrCodeUnauthorised)
}</span>

// Forbidden responds with a 403 Forbidden error
func Forbidden(w http.ResponseWriter, r *http.Request, message string) <span class="cov8" title="1">{
        WriteErrorMessage(w, r, message, http.StatusForbidden, ErrCodeForbidden)
}</span>

// NotFound responds with a 404 Not Found error
func NotFound(w http.ResponseWriter, r *http.Request, message string) <span class="cov8" title="1">{
        WriteErrorMessage(w, r, message, http.StatusNotFound, ErrCodeNotFound)
}</span>

// MethodNotAllowed responds with a 405 Method Not Allowed error
func MethodNotAllowed(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        WriteErrorMessage(w, r, "Method not allowed", http.StatusMethodNotAllowed, ErrCodeMethodNotAllowed)
}</span>

// InternalError responds with a 500 Internal Server Error
func InternalError(w http.ResponseWriter, r *http.Request, err error) <span class="cov8" title="1">{
        WriteError(w, r, err, http.StatusInternalServerError, ErrCodeInternal)
}</span>

// DatabaseError responds with a 500 error for database issues
func DatabaseError(w http.ResponseWriter, r *http.Request, err error) <span class="cov8" title="1">{
        WriteError(w, r, err, http.StatusInternalServerError, ErrCodeDatabaseError)
}</span>

// ServiceUnavailable responds with a 503 Service Unavailable error
func ServiceUnavailable(w http.ResponseWriter, r *http.Request, message string) <span class="cov8" title="1">{
        WriteErrorMessage(w, r, message, http.StatusServiceUnavailable, ErrCodeServiceUnavailable)
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package api

import (
        "database/sql"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/auth"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/Harvey-AU/blue-banded-bee/internal/jobs"
        "github.com/rs/zerolog/log"
)

// Version is the current API version (can be set via ldflags at build time)
var Version = "0.4.0"

// DBClient is an interface for database operations
type DBClient interface {
        GetDB() *sql.DB
        GetOrCreateUser(userID, email string, orgID *string) (*db.User, error)
        GetJobStats(organisationID string, startDate, endDate *time.Time) (*db.JobStats, error)
        GetJobActivity(organisationID string, startDate, endDate *time.Time) ([]db.ActivityPoint, error)
        GetSlowPages(organisationID string, startDate, endDate *time.Time) ([]db.SlowPage, error)
        GetExternalRedirects(organisationID string, startDate, endDate *time.Time) ([]db.ExternalRedirect, error)
        GetUserByWebhookToken(token string) (*db.User, error)
        // Additional methods used by API handlers
        GetUser(userID string) (*db.User, error)
        ResetSchema() error
        CreateUser(userID, email string, fullName *string, orgName string) (*db.User, *db.Organisation, error)
        GetOrganisation(organisationID string) (*db.Organisation, error)
        ListJobs(organisationID string, limit, offset int, status, dateRange string) ([]db.JobWithDomain, int, error)
}

// Handler holds dependencies for API handlers
type Handler struct {
        DB          DBClient
        JobsManager jobs.JobManagerInterface
}

// NewHandler creates a new API handler with dependencies
func NewHandler(pgDB DBClient, jobsManager jobs.JobManagerInterface) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                DB:          pgDB,
                JobsManager: jobsManager,
        }
}</span>

// SetupRoutes configures all API routes with proper middleware
func (h *Handler) SetupRoutes(mux *http.ServeMux) <span class="cov8" title="1">{
        // Health check endpoints (no auth required)
        mux.HandleFunc("/health", h.HealthCheck)
        mux.HandleFunc("/health/db", h.DatabaseHealthCheck)

        // V1 API routes with authentication
        mux.Handle("/v1/jobs", auth.AuthMiddleware(http.HandlerFunc(h.JobsHandler)))
        mux.Handle("/v1/jobs/", auth.AuthMiddleware(http.HandlerFunc(h.JobHandler))) // For /v1/jobs/:id

        // Dashboard API routes (require auth)
        mux.Handle("/v1/dashboard/stats", auth.AuthMiddleware(http.HandlerFunc(h.DashboardStats)))
        mux.Handle("/v1/dashboard/activity", auth.AuthMiddleware(http.HandlerFunc(h.DashboardActivity)))
        mux.Handle("/v1/dashboard/slow-pages", auth.AuthMiddleware(http.HandlerFunc(h.DashboardSlowPages)))
        mux.Handle("/v1/dashboard/external-redirects", auth.AuthMiddleware(http.HandlerFunc(h.DashboardExternalRedirects)))

        // Authentication routes (no auth middleware)
        mux.HandleFunc("/v1/auth/register", h.AuthRegister)
        mux.HandleFunc("/v1/auth/session", h.AuthSession)

        // Profile route (requires auth)
        mux.Handle("/v1/auth/profile", auth.AuthMiddleware(http.HandlerFunc(h.AuthProfile)))

        // Webhook endpoints (no auth required)
        mux.HandleFunc("/v1/webhooks/webflow/", h.WebflowWebhook) // Note: trailing slash for path params

        // Admin endpoints (require authentication and admin role)
        mux.Handle("/admin/reset-db", auth.AuthMiddleware(http.HandlerFunc(h.AdminResetDatabase)))

        // Debug endpoints (no auth required)
        mux.HandleFunc("/debug/fgtrace", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                f, err := os.Open("trace.out")
                if err != nil </span><span class="cov0" title="0">{
                        http.Error(w, "could not open trace file", http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">defer f.Close()
                w.Header().Set("Content-Type", "application/octet-stream")
                w.Header().Set("Content-Disposition", `attachment; filename="trace.out"`)
                io.Copy(w, f)</span>
        }))

        // Static files
        <span class="cov8" title="1">mux.HandleFunc("/", h.ServeHomepage)  // Marketing homepage
        mux.HandleFunc("/test-login.html", h.ServeTestLogin)
        mux.HandleFunc("/test-components.html", h.ServeTestComponents)
        mux.HandleFunc("/test-data-components.html", h.ServeTestDataComponents)
        mux.HandleFunc("/dashboard", h.ServeDashboard)
        mux.HandleFunc("/dashboard-new", h.ServeNewDashboard)

        // Web Components static files
        mux.Handle("/js/", http.StripPrefix("/js/", http.FileServer(http.Dir("./web/dist/"))))
        mux.Handle("/web/", http.StripPrefix("/web/", http.FileServer(http.Dir("./web/"))))</span>
}

// HealthCheck handles basic health check requests
func (h *Handler) HealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                MethodNotAllowed(w, r)
                return
        }</span>

        <span class="cov8" title="1">WriteHealthy(w, r, "blue-banded-bee", Version)</span>
}

// DatabaseHealthCheck handles database health check requests
func (h *Handler) DatabaseHealthCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                MethodNotAllowed(w, r)
                return
        }</span>

        // Guard against nil DB to prevent panic
        <span class="cov8" title="1">if h.DB == nil </span><span class="cov8" title="1">{
                WriteUnhealthy(w, r, "postgresql", fmt.Errorf("database connection not configured"))
                return
        }</span>

        <span class="cov8" title="1">if err := h.DB.GetDB().Ping(); err != nil </span><span class="cov8" title="1">{
                WriteUnhealthy(w, r, "postgresql", err)
                return
        }</span>

        <span class="cov8" title="1">WriteHealthy(w, r, "postgresql", "")</span>
}

// ServeTestLogin serves the test login page
func (h *Handler) ServeTestLogin(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        http.ServeFile(w, r, "test-login.html")
}</span>

// ServeTestComponents serves the Web Components test page
func (h *Handler) ServeTestComponents(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        http.ServeFile(w, r, "test-components.html")
}</span>

// ServeTestDataComponents serves the data components test page
func (h *Handler) ServeTestDataComponents(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        http.ServeFile(w, r, "test-data-components.html")
}</span>

// ServeDashboard serves the dashboard page
func (h *Handler) ServeDashboard(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        http.ServeFile(w, r, "dashboard.html")
}</span>

// ServeNewDashboard serves the new Web Components dashboard page
func (h *Handler) ServeNewDashboard(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        http.ServeFile(w, r, "dashboard.html")
}</span>

// ServeHomepage serves the marketing homepage
func (h *Handler) ServeHomepage(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Only serve homepage for exact root path
        if r.URL.Path != "/" </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>
        <span class="cov0" title="0">http.ServeFile(w, r, "homepage.html")</span>
}

// DashboardStats handles dashboard statistics requests
func (h *Handler) DashboardStats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                MethodNotAllowed(w, r)
                return
        }</span>

        // Get user claims from context
        <span class="cov8" title="1">userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok || userClaims == nil </span><span class="cov0" title="0">{
                Unauthorised(w, r, "Authentication required")
                return
        }</span>

        // Get full user object from database (auto-create if needed)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        // Get query parameters
        <span class="cov8" title="1">dateRange := r.URL.Query().Get("range")
        if dateRange == "" </span><span class="cov8" title="1">{
                dateRange = "last7"
        }</span>

        // Calculate date range for query
        <span class="cov8" title="1">startDate, endDate := calculateDateRange(dateRange)

        // Get job statistics
        orgID := ""
        if user.OrganisationID != nil </span><span class="cov8" title="1">{
                orgID = *user.OrganisationID
        }</span>
        <span class="cov8" title="1">stats, err := h.DB.GetJobStats(orgID, startDate, endDate)
        if err != nil </span><span class="cov8" title="1">{
                DatabaseError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">WriteSuccess(w, r, map[string]interface{}{
                "total_jobs":          stats.TotalJobs,
                "running_jobs":        stats.RunningJobs,
                "completed_jobs":      stats.CompletedJobs,
                "failed_jobs":         stats.FailedJobs,
                "total_tasks":         stats.TotalTasks,
                "avg_completion_time": stats.AvgCompletionTime,
                "date_range":          dateRange,
                "period_start":        startDate,
                "period_end":          endDate,
        }, "Dashboard statistics retrieved successfully")</span>
}

// DashboardActivity handles dashboard activity chart requests
func (h *Handler) DashboardActivity(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                MethodNotAllowed(w, r)
                return
        }</span>

        // Get user claims from context
        <span class="cov8" title="1">userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok || userClaims == nil </span><span class="cov8" title="1">{
                Unauthorised(w, r, "Authentication required")
                return
        }</span>

        // Get full user object from database (auto-create if needed)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        // Get query parameters
        <span class="cov8" title="1">dateRange := r.URL.Query().Get("range")
        if dateRange == "" </span><span class="cov8" title="1">{
                dateRange = "last7"
        }</span>

        // Calculate date range for query
        <span class="cov8" title="1">startDate, endDate := calculateDateRange(dateRange)

        // Get activity data
        orgID := ""
        if user.OrganisationID != nil </span><span class="cov8" title="1">{
                orgID = *user.OrganisationID
        }</span>
        <span class="cov8" title="1">activity, err := h.DB.GetJobActivity(orgID, startDate, endDate)
        if err != nil </span><span class="cov8" title="1">{
                DatabaseError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">WriteSuccess(w, r, map[string]interface{}{
                "activity":     activity,
                "date_range":   dateRange,
                "period_start": startDate,
                "period_end":   endDate,
        }, "Dashboard activity retrieved successfully")</span>
}

// calculateDateRange converts date range string to start and end times
func calculateDateRange(dateRange string) (*time.Time, *time.Time) <span class="cov8" title="1">{
        now := time.Now().UTC()
        var startDate, endDate *time.Time

        switch dateRange </span>{
        case "today":<span class="cov8" title="1">
                start := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.UTC)
                end := time.Date(now.Year(), now.Month(), now.Day(), 23, 59, 59, 999999999, time.UTC)
                startDate = &amp;start
                endDate = &amp;end</span>
        case "last24":<span class="cov8" title="1">
                start := now.Add(-24 * time.Hour)
                startDate = &amp;start
                endDate = &amp;now</span>
        case "yesterday":<span class="cov8" title="1">
                yesterday := now.AddDate(0, 0, -1)
                start := time.Date(yesterday.Year(), yesterday.Month(), yesterday.Day(), 0, 0, 0, 0, time.UTC)
                end := time.Date(yesterday.Year(), yesterday.Month(), yesterday.Day(), 23, 59, 59, 999999999, time.UTC)
                startDate = &amp;start
                endDate = &amp;end</span>
        case "last7":<span class="cov8" title="1">
                start := now.AddDate(0, 0, -7)
                startDate = &amp;start
                endDate = &amp;now</span>
        case "last30":<span class="cov8" title="1">
                start := now.AddDate(0, 0, -30)
                startDate = &amp;start
                endDate = &amp;now</span>
        case "last90":<span class="cov8" title="1">
                start := now.AddDate(0, 0, -90)
                startDate = &amp;start
                endDate = &amp;now</span>
        case "all":<span class="cov8" title="1">
                // Return nil for both to indicate no date filtering
                return nil, nil</span>
        default:<span class="cov8" title="1">
                // Default to last 7 days
                start := now.AddDate(0, 0, -7)
                startDate = &amp;start
                endDate = &amp;now</span>
        }

        <span class="cov8" title="1">return startDate, endDate</span>
}

// DashboardSlowPages handles requests for slow-loading pages analysis
func (h *Handler) DashboardSlowPages(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                MethodNotAllowed(w, r)
                return
        }</span>

        // Get user claims from context
        <span class="cov8" title="1">userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok || userClaims == nil </span><span class="cov8" title="1">{
                Unauthorised(w, r, "Authentication required")
                return
        }</span>

        // Get full user object from database (auto-create if needed)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        // Get query parameters
        <span class="cov8" title="1">dateRange := r.URL.Query().Get("range")
        if dateRange == "" </span><span class="cov8" title="1">{
                dateRange = "last7"
        }</span>

        // Calculate date range for query
        <span class="cov8" title="1">startDate, endDate := calculateDateRange(dateRange)

        // Get slow pages data
        orgID := ""
        if user.OrganisationID != nil </span><span class="cov8" title="1">{
                orgID = *user.OrganisationID
        }</span>
        <span class="cov8" title="1">slowPages, err := h.DB.GetSlowPages(orgID, startDate, endDate)
        if err != nil </span><span class="cov8" title="1">{
                DatabaseError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">WriteSuccess(w, r, map[string]interface{}{
                "slow_pages":   slowPages,
                "date_range":   dateRange,
                "period_start": startDate,
                "period_end":   endDate,
                "count":        len(slowPages),
        }, "Slow pages analysis retrieved successfully")</span>
}

// DashboardExternalRedirects handles requests for external redirect analysis
func (h *Handler) DashboardExternalRedirects(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov0" title="0">{
                MethodNotAllowed(w, r)
                return
        }</span>

        // Get user claims from context
        <span class="cov8" title="1">userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok || userClaims == nil </span><span class="cov8" title="1">{
                Unauthorised(w, r, "Authentication required")
                return
        }</span>

        // Get full user object from database (auto-create if needed)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        // Get query parameters
        <span class="cov8" title="1">dateRange := r.URL.Query().Get("range")
        if dateRange == "" </span><span class="cov8" title="1">{
                dateRange = "last7"
        }</span>

        // Calculate date range for query
        <span class="cov8" title="1">startDate, endDate := calculateDateRange(dateRange)

        // Get external redirects data
        orgID := ""
        if user.OrganisationID != nil </span><span class="cov8" title="1">{
                orgID = *user.OrganisationID
        }</span>
        <span class="cov8" title="1">redirects, err := h.DB.GetExternalRedirects(orgID, startDate, endDate)
        if err != nil </span><span class="cov8" title="1">{
                DatabaseError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">WriteSuccess(w, r, map[string]interface{}{
                "external_redirects": redirects,
                "date_range":         dateRange,
                "period_start":       startDate,
                "period_end":         endDate,
                "count":              len(redirects),
        }, "External redirects analysis retrieved successfully")</span>
}

// WebflowWebhookPayload represents the structure of Webflow's site publish webhook
type WebflowWebhookPayload struct {
        TriggerType string `json:"triggerType"`
        Payload     struct {
                Domains     []string `json:"domains"`
                PublishedBy struct {
                        DisplayName string `json:"displayName"`
                } `json:"publishedBy"`
        } `json:"payload"`
}

// WebflowWebhook handles Webflow site publish webhooks
func (h *Handler) WebflowWebhook(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                MethodNotAllowed(w, r)
                return
        }</span>

        // Extract webhook token from URL path: /v1/webhooks/webflow/WEBHOOK_TOKEN
        <span class="cov8" title="1">pathParts := strings.Split(strings.Trim(r.URL.Path, "/"), "/")
        if len(pathParts) &lt; 4 || pathParts[3] == "" </span><span class="cov8" title="1">{
                log.Error().Str("path", r.URL.Path).Msg("Webflow webhook missing token in URL")
                BadRequest(w, r, "Webhook token required in URL path")
                return
        }</span>
        <span class="cov8" title="1">webhookToken := pathParts[3]

        // Parse webhook payload
        var payload WebflowWebhookPayload
        if err := json.NewDecoder(r.Body).Decode(&amp;payload); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to parse Webflow webhook payload")
                BadRequest(w, r, "Invalid webhook payload")
                return
        }</span>

        // Get user from database using webhook token
        <span class="cov8" title="1">user, err := h.DB.GetUserByWebhookToken(webhookToken)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("webhook_token", webhookToken).Msg("Failed to get user by webhook token")
                // Return 404 to avoid leaking information about valid tokens
                NotFound(w, r, "Invalid webhook token")
                return
        }</span>

        // Log webhook received
        <span class="cov8" title="1">log.Info().
                Str("user_id", user.ID).
                Str("trigger_type", payload.TriggerType).
                Str("published_by", payload.Payload.PublishedBy.DisplayName).
                Strs("domains", payload.Payload.Domains).
                Msg("Webflow webhook received")

        // Validate it's a site publish event
        if payload.TriggerType != "site_publish" </span><span class="cov8" title="1">{
                log.Warn().Str("trigger_type", payload.TriggerType).Msg("Ignoring non-site-publish webhook")
                WriteSuccess(w, r, nil, "Webhook received but ignored (not site_publish)")
                return
        }</span>

        // Validate domains are provided
        <span class="cov8" title="1">if len(payload.Payload.Domains) == 0 </span><span class="cov0" title="0">{
                log.Error().Msg("Webflow webhook missing domains")
                BadRequest(w, r, "Domains are required")
                return
        }</span>

        // Use the first domain in the list (primary/canonical domain)
        <span class="cov8" title="1">selectedDomain := payload.Payload.Domains[0]

        // Create job using shared logic with webhook defaults
        useSitemap := true
        findLinks := true
        concurrency := 3
        maxPages := 0 // Unlimited pages for webhook-triggered jobs
        sourceType := "webflow_webhook"
        sourceDetail := payload.Payload.PublishedBy.DisplayName

        // Store full webhook payload for debugging
        sourceInfoBytes, _ := json.Marshal(payload)
        sourceInfo := string(sourceInfoBytes)

        req := CreateJobRequest{
                Domain:       selectedDomain,
                UseSitemap:   &amp;useSitemap,
                FindLinks:    &amp;findLinks,
                Concurrency:  &amp;concurrency,
                MaxPages:     &amp;maxPages,
                SourceType:   &amp;sourceType,
                SourceDetail: &amp;sourceDetail,
                SourceInfo:   &amp;sourceInfo,
        }

        job, err := h.createJobFromRequest(r.Context(), user, req)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).
                        Str("user_id", user.ID).
                        Str("domain", selectedDomain).
                        Msg("Failed to create job from webhook")
                InternalError(w, r, err)
                return
        }</span>

        // Start the job immediately
        <span class="cov8" title="1">if err := h.JobsManager.StartJob(r.Context(), job.ID); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("job_id", job.ID).Msg("Failed to start job from webhook")
                // Don't return error - job was created successfully, just failed to start
        }</span>

        <span class="cov8" title="1">orgIDStr := ""
        if user.OrganisationID != nil </span><span class="cov8" title="1">{
                orgIDStr = *user.OrganisationID
        }</span>

        <span class="cov8" title="1">log.Info().
                Str("job_id", job.ID).
                Str("user_id", user.ID).
                Str("org_id", orgIDStr).
                Str("domain", selectedDomain).
                Str("selected_from", strings.Join(payload.Payload.Domains, ", ")).
                Msg("Successfully created and started job from Webflow webhook")

        WriteSuccess(w, r, map[string]interface{}{
                "job_id":  job.ID,
                "user_id": user.ID,
                "org_id":  orgIDStr,
                "domain":  selectedDomain,
                "status":  "created",
        }, "Job created successfully from webhook")</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package api

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "net"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/auth"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/Harvey-AU/blue-banded-bee/internal/jobs"
        "github.com/rs/zerolog/log"
)

// JobsHandler handles requests to /v1/jobs
func (h *Handler) JobsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.listJobs(w, r)</span>
        case http.MethodPost:<span class="cov8" title="1">
                h.createJob(w, r)</span>
        default:<span class="cov8" title="1">
                MethodNotAllowed(w, r)</span>
        }
}

// JobHandler handles requests to /v1/jobs/:id
func (h *Handler) JobHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Extract job ID from path
        path := strings.TrimPrefix(r.URL.Path, "/v1/jobs/")
        if path == "" </span><span class="cov8" title="1">{
                BadRequest(w, r, "Job ID is required")
                return
        }</span>

        // Handle sub-routes like /v1/jobs/:id/tasks
        <span class="cov8" title="1">parts := strings.Split(path, "/")
        jobID := parts[0]

        if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                // Handle sub-routes
                switch parts[1] </span>{
                case "tasks":<span class="cov8" title="1">
                        h.getJobTasks(w, r, jobID)
                        return</span>
                default:<span class="cov8" title="1">
                        NotFound(w, r, "Endpoint not found")
                        return</span>
                }
        }

        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                h.getJob(w, r, jobID)</span>
        case http.MethodPut:<span class="cov8" title="1">
                h.updateJob(w, r, jobID)</span>
        case http.MethodDelete:<span class="cov8" title="1">
                h.cancelJob(w, r, jobID)</span>
        default:<span class="cov8" title="1">
                MethodNotAllowed(w, r)</span>
        }
}

// CreateJobRequest represents the request body for creating a job
type CreateJobRequest struct {
        Domain       string  `json:"domain"`
        UseSitemap   *bool   `json:"use_sitemap,omitempty"`
        FindLinks    *bool   `json:"find_links,omitempty"`
        Concurrency  *int    `json:"concurrency,omitempty"`
        MaxPages     *int    `json:"max_pages,omitempty"`
        SourceType   *string `json:"source_type,omitempty"`
        SourceDetail *string `json:"source_detail,omitempty"`
        SourceInfo   *string `json:"source_info,omitempty"`
}

// JobResponse represents a job in API responses
type JobResponse struct {
        ID             string  `json:"id"`
        Domain         string  `json:"domain"`
        Status         string  `json:"status"`
        TotalTasks     int     `json:"total_tasks"`
        CompletedTasks int     `json:"completed_tasks"`
        FailedTasks    int     `json:"failed_tasks"`
        SkippedTasks   int     `json:"skipped_tasks"`
        Progress       float64 `json:"progress"`
        CreatedAt      string  `json:"created_at"`
        StartedAt      *string `json:"started_at,omitempty"`
        CompletedAt    *string `json:"completed_at,omitempty"`
}

// listJobs handles GET /v1/jobs
func (h *Handler) listJobs(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "User information not found")
                return
        }</span>

        // Auto-create user if they don't exist (handles new signups)
        <span class="cov0" title="0">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        // Parse query parameters
        <span class="cov0" title="0">limit := 10 // default
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 100 </span><span class="cov0" title="0">{
                        limit = parsedLimit
                }</span>
        }

        <span class="cov0" title="0">offset := 0
        if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov0" title="0">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov0" title="0">{
                        offset = parsedOffset
                }</span>
        }

        <span class="cov0" title="0">status := r.URL.Query().Get("status")   // Optional status filter
        dateRange := r.URL.Query().Get("range") // Optional date range filter
        include := r.URL.Query().Get("include") // Optional includes (domain, progress, etc.)

        // Get jobs from database
        orgID := ""
        if user.OrganisationID != nil </span><span class="cov0" title="0">{
                orgID = *user.OrganisationID
        }</span>
        <span class="cov0" title="0">jobs, total, err := h.DB.ListJobs(orgID, limit, offset, status, dateRange)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("organisation_id", orgID).Msg("Failed to list jobs")
                DatabaseError(w, r, err)
                return
        }</span>

        // Calculate pagination info
        <span class="cov0" title="0">hasNext := offset+limit &lt; total
        hasPrev := offset &gt; 0

        // Prepare response
        response := map[string]interface{}{
                "jobs": jobs,
                "pagination": map[string]interface{}{
                        "limit":    limit,
                        "offset":   offset,
                        "total":    total,
                        "has_next": hasNext,
                        "has_prev": hasPrev,
                },
        }

        if include != "" </span><span class="cov0" title="0">{
                // Add additional data based on include parameter
                response["include"] = include
        }</span>

        <span class="cov0" title="0">WriteSuccess(w, r, response, "Jobs retrieved successfully")</span>
}

// createJobFromRequest creates a job from a CreateJobRequest with user context
func (h *Handler) createJobFromRequest(ctx context.Context, user *db.User, req CreateJobRequest) (*jobs.Job, error) <span class="cov8" title="1">{
        // Set defaults
        useSitemap := true
        if req.UseSitemap != nil </span><span class="cov8" title="1">{
                useSitemap = *req.UseSitemap
        }</span>

        <span class="cov8" title="1">findLinks := true
        if req.FindLinks != nil </span><span class="cov8" title="1">{
                findLinks = *req.FindLinks
        }</span>

        <span class="cov8" title="1">concurrency := 5
        if req.Concurrency != nil </span><span class="cov8" title="1">{
                concurrency = *req.Concurrency
        }</span>

        <span class="cov8" title="1">maxPages := 0
        if req.MaxPages != nil </span><span class="cov8" title="1">{
                maxPages = *req.MaxPages
        }</span>

        <span class="cov8" title="1">opts := &amp;jobs.JobOptions{
                Domain:         req.Domain,
                UserID:         &amp;user.ID,
                OrganisationID: user.OrganisationID,
                UseSitemap:     useSitemap,
                Concurrency:    concurrency,
                FindLinks:      findLinks,
                MaxPages:       maxPages,
                SourceType:     req.SourceType,
                SourceDetail:   req.SourceDetail,
                SourceInfo:     req.SourceInfo,
        }

        return h.JobsManager.CreateJob(ctx, opts)</span>
}

// createJob handles POST /v1/jobs
func (h *Handler) createJob(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "User information not found")
                return
        }</span>

        // Auto-create user if they don't exist (handles new signups)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">var req CreateJobRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                BadRequest(w, r, "Invalid JSON request body")
                return
        }</span>

        <span class="cov8" title="1">if req.Domain == "" </span><span class="cov8" title="1">{
                BadRequest(w, r, "Domain is required")
                return
        }</span>

        // Set source information if not provided (dashboard creation)
        <span class="cov8" title="1">if req.SourceType == nil </span><span class="cov8" title="1">{
                sourceType := "dashboard"
                req.SourceType = &amp;sourceType
        }</span>
        <span class="cov8" title="1">if req.SourceDetail == nil </span><span class="cov8" title="1">{
                sourceDetail := "create_job"
                req.SourceDetail = &amp;sourceDetail
        }</span>
        <span class="cov8" title="1">if req.SourceInfo == nil </span><span class="cov8" title="1">{
                sourceInfoData := map[string]interface{}{
                        "ip":        getClientIP(r),
                        "userAgent": r.UserAgent(),
                        "timestamp": time.Now().UTC().Format(time.RFC3339),
                        "endpoint":  r.URL.Path,
                        "method":    r.Method,
                }
                sourceInfoBytes, _ := json.Marshal(sourceInfoData)
                sourceInfo := string(sourceInfoBytes)
                req.SourceInfo = &amp;sourceInfo
        }</span>

        <span class="cov8" title="1">job, err := h.createJobFromRequest(r.Context(), user, req)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("domain", req.Domain).Msg("Failed to create job")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">response := JobResponse{
                ID:             job.ID,
                Domain:         job.Domain,
                Status:         string(job.Status),
                TotalTasks:     job.TotalTasks,
                CompletedTasks: job.CompletedTasks,
                FailedTasks:    job.FailedTasks,
                SkippedTasks:   job.SkippedTasks,
                Progress:       0.0,
                CreatedAt:      job.CreatedAt.Format(time.RFC3339),
        }

        WriteCreated(w, r, response, "Job created successfully")</span>
}

// getJob handles GET /v1/jobs/:id
func (h *Handler) getJob(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov8" title="1">{
        userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "User information not found")
                return
        }</span>

        // Auto-create user if they don't exist (handles new signups)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">var total, completed, failed, skipped int
        var status, domain string
        var createdAt, startedAt, completedAt sql.NullTime
        err = h.DB.GetDB().QueryRowContext(r.Context(), `
                SELECT j.total_tasks, j.completed_tasks, j.failed_tasks, j.skipped_tasks, j.status,
                       d.name as domain, j.created_at, j.started_at, j.completed_at
                FROM jobs j
                JOIN domains d ON j.domain_id = d.id
                WHERE j.id = $1 AND j.organisation_id = $2
        `, jobID, user.OrganisationID).Scan(&amp;total, &amp;completed, &amp;failed, &amp;skipped, &amp;status, &amp;domain, &amp;createdAt, &amp;startedAt, &amp;completedAt)

        if err != nil </span><span class="cov8" title="1">{
                NotFound(w, r, "Job not found")
                return
        }</span>

        // Calculate progress
        <span class="cov8" title="1">progress := 0.0
        if total &gt; skipped </span><span class="cov8" title="1">{
                progress = float64(completed+failed) / float64(total-skipped) * 100
        }</span>

        <span class="cov8" title="1">response := JobResponse{
                ID:             jobID,
                Domain:         domain,
                Status:         status,
                TotalTasks:     total,
                CompletedTasks: completed,
                FailedTasks:    failed,
                SkippedTasks:   skipped,
                Progress:       progress,
        }

        // Add timestamps if available
        if createdAt.Valid </span><span class="cov8" title="1">{
                response.CreatedAt = createdAt.Time.Format(time.RFC3339)
        }</span>
        <span class="cov8" title="1">if startedAt.Valid </span><span class="cov8" title="1">{
                startedTime := startedAt.Time.Format(time.RFC3339)
                response.StartedAt = &amp;startedTime
        }</span>
        <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                completedTime := completedAt.Time.Format(time.RFC3339)
                response.CompletedAt = &amp;completedTime
        }</span>

        <span class="cov8" title="1">WriteSuccess(w, r, response, "Job retrieved successfully")</span>
}

// JobActionRequest represents actions that can be performed on jobs
type JobActionRequest struct {
        Action string `json:"action"`
}

// updateJob handles PUT /v1/jobs/:id for job actions
func (h *Handler) updateJob(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov8" title="1">{
        userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "User information not found")
                return
        }</span>

        // Auto-create user if they don't exist (handles new signups)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">var req JobActionRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                BadRequest(w, r, "Invalid JSON request body")
                return
        }</span>

        // Verify job belongs to user's organisation
        <span class="cov8" title="1">var orgID string
        err = h.DB.GetDB().QueryRowContext(r.Context(), `
                SELECT organisation_id FROM jobs WHERE id = $1
        `, jobID).Scan(&amp;orgID)

        if err != nil </span><span class="cov8" title="1">{
                NotFound(w, r, "Job not found")
                return
        }</span>

        <span class="cov8" title="1">if user.OrganisationID == nil || *user.OrganisationID != orgID </span><span class="cov8" title="1">{
                Unauthorised(w, r, "Job access denied")
                return
        }</span>

        <span class="cov8" title="1">switch req.Action </span>{
        case "start", "restart":<span class="cov8" title="1">
                err = h.JobsManager.StartJob(r.Context(), jobID)</span>
        case "cancel":<span class="cov8" title="1">
                err = h.JobsManager.CancelJob(r.Context(), jobID)</span>
        default:<span class="cov8" title="1">
                BadRequest(w, r, "Invalid action. Supported actions: start, restart, cancel")
                return</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("job_id", jobID).Str("action", req.Action).Msg("Failed to perform job action")
                InternalError(w, r, err)
                return
        }</span>

        // Get updated job status
        <span class="cov8" title="1">job, err := h.JobsManager.GetJobStatus(r.Context(), jobID)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to get job status after action")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">response := JobResponse{
                ID:             job.ID,
                Domain:         job.Domain,
                Status:         string(job.Status),
                TotalTasks:     job.TotalTasks,
                CompletedTasks: job.CompletedTasks,
                FailedTasks:    job.FailedTasks,
                SkippedTasks:   job.SkippedTasks,
                Progress:       job.Progress,
                CreatedAt:      job.CreatedAt.Format(time.RFC3339),
        }

        if !job.CompletedAt.IsZero() </span><span class="cov8" title="1">{
                completedAt := job.CompletedAt.Format(time.RFC3339)
                response.CompletedAt = &amp;completedAt
        }</span>

        <span class="cov8" title="1">WriteSuccess(w, r, response, fmt.Sprintf("Job %s %sed successfully", jobID, req.Action))</span>
}

// cancelJob handles DELETE /v1/jobs/:id
func (h *Handler) cancelJob(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov8" title="1">{
        userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "User information not found")
                return
        }</span>

        // Auto-create user if they don't exist (handles new signups)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return
        }</span>

        // Verify job belongs to user's organisation
        <span class="cov8" title="1">var orgID string
        err = h.DB.GetDB().QueryRowContext(r.Context(), `
                SELECT organisation_id FROM jobs WHERE id = $1
        `, jobID).Scan(&amp;orgID)

        if err != nil </span><span class="cov0" title="0">{
                NotFound(w, r, "Job not found")
                return
        }</span>

        <span class="cov8" title="1">if user.OrganisationID == nil || *user.OrganisationID != orgID </span><span class="cov0" title="0">{
                Unauthorised(w, r, "Job access denied")
                return
        }</span>

        <span class="cov8" title="1">err = h.JobsManager.CancelJob(r.Context(), jobID)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to cancel job")
                InternalError(w, r, err)
                return
        }</span>

        <span class="cov8" title="1">WriteSuccess(w, r, map[string]string{"id": jobID, "status": "cancelled"}, "Job cancelled successfully")</span>
}

// TaskQueryParams holds parameters for task listing queries
type TaskQueryParams struct {
        Limit   int
        Offset  int
        Status  string
        OrderBy string
}

// parseTaskQueryParams extracts and validates query parameters for task listing
func parseTaskQueryParams(r *http.Request) TaskQueryParams <span class="cov8" title="1">{
        // Parse limit parameter
        limit := 50 // default
        if limitStr := r.URL.Query().Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if parsedLimit, err := strconv.Atoi(limitStr); err == nil &amp;&amp; parsedLimit &gt; 0 &amp;&amp; parsedLimit &lt;= 200 </span><span class="cov8" title="1">{
                        limit = parsedLimit
                }</span>
        }

        // Parse offset parameter
        <span class="cov8" title="1">offset := 0
        if offsetStr := r.URL.Query().Get("offset"); offsetStr != "" </span><span class="cov8" title="1">{
                if parsedOffset, err := strconv.Atoi(offsetStr); err == nil &amp;&amp; parsedOffset &gt;= 0 </span><span class="cov8" title="1">{
                        offset = parsedOffset
                }</span>
        }

        // Parse status filter
        <span class="cov8" title="1">status := r.URL.Query().Get("status") // Optional status filter
        
        // Parse sort parameter
        sortParam := r.URL.Query().Get("sort") // Optional sort parameter
        orderBy := "t.created_at DESC" // default
        if sortParam != "" </span><span class="cov8" title="1">{
                // Handle sort direction prefix
                direction := "DESC"
                column := sortParam
                if strings.HasPrefix(sortParam, "-") </span><span class="cov8" title="1">{
                        direction = "DESC"
                        column = strings.TrimPrefix(sortParam, "-")
                }</span> else<span class="cov8" title="1"> {
                        direction = "ASC"
                }</span>

                // Map column names to actual SQL columns
                <span class="cov8" title="1">switch column </span>{
                case "path":<span class="cov8" title="1">
                        orderBy = "p.path " + direction</span>
                case "status":<span class="cov8" title="1">
                        orderBy = "t.status " + direction</span>
                case "response_time":<span class="cov8" title="1">
                        orderBy = "t.response_time " + direction + " NULLS LAST"</span>
                case "cache_status":<span class="cov8" title="1">
                        orderBy = "t.cache_status " + direction + " NULLS LAST"</span>
                case "second_response_time":<span class="cov8" title="1">
                        orderBy = "t.second_response_time " + direction + " NULLS LAST"</span>
                case "status_code":<span class="cov8" title="1">
                        orderBy = "t.status_code " + direction + " NULLS LAST"</span>
                case "created_at":<span class="cov8" title="1">
                        orderBy = "t.created_at " + direction</span>
                default:<span class="cov8" title="1">
                        orderBy = "t.created_at DESC"</span> // fallback to default
                }
        }

        <span class="cov8" title="1">return TaskQueryParams{
                Limit:   limit,
                Offset:  offset,
                Status:  status,
                OrderBy: orderBy,
        }</span>
}

// validateJobAccess validates user authentication and job access permissions
// Returns the user if validation succeeds, or writes HTTP error and returns nil
func (h *Handler) validateJobAccess(w http.ResponseWriter, r *http.Request, jobID string) *db.User <span class="cov8" title="1">{
        // Extract user claims from context
        userClaims, ok := auth.GetUserFromContext(r.Context())
        if !ok </span><span class="cov8" title="1">{
                Unauthorised(w, r, "User information not found")
                return nil
        }</span>

        // Auto-create user if they don't exist (handles new signups)
        <span class="cov8" title="1">user, err := h.DB.GetOrCreateUser(userClaims.UserID, userClaims.Email, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("user_id", userClaims.UserID).Msg("Failed to get or create user")
                InternalError(w, r, err)
                return nil
        }</span>

        // Verify job belongs to user's organisation
        <span class="cov8" title="1">var orgID string
        err = h.DB.GetDB().QueryRowContext(r.Context(), `
                SELECT organisation_id FROM jobs WHERE id = $1
        `, jobID).Scan(&amp;orgID)

        if err != nil </span><span class="cov0" title="0">{
                NotFound(w, r, "Job not found")
                return nil
        }</span>

        <span class="cov8" title="1">if user.OrganisationID == nil || *user.OrganisationID != orgID </span><span class="cov0" title="0">{
                Unauthorised(w, r, "Job access denied")
                return nil
        }</span>

        <span class="cov8" title="1">return user</span>
}

// TaskQueryBuilder holds the SQL queries and arguments for task retrieval
type TaskQueryBuilder struct {
        SelectQuery string
        CountQuery  string
        Args        []interface{}
}

// buildTaskQuery constructs SQL queries for task retrieval with filters and pagination
func buildTaskQuery(jobID string, params TaskQueryParams) TaskQueryBuilder <span class="cov8" title="1">{
        baseQuery := `
                SELECT t.id, t.job_id, p.path, d.name as domain, t.status, t.status_code, t.response_time, 
                       t.cache_status, t.second_response_time, t.second_cache_status, t.content_type, t.error, t.source_type, t.source_url,
                       t.created_at, t.started_at, t.completed_at, t.retry_count
                FROM tasks t
                JOIN pages p ON t.page_id = p.id
                JOIN jobs j ON t.job_id = j.id
                JOIN domains d ON j.domain_id = d.id
                WHERE t.job_id = $1`

        countQuery := `
                SELECT COUNT(*) 
                FROM tasks t 
                WHERE t.job_id = $1`

        args := []interface{}{jobID}

        // Add status filter if provided
        if params.Status != "" </span><span class="cov8" title="1">{
                baseQuery += ` AND t.status = $2`
                countQuery += ` AND t.status = $2`
                args = append(args, params.Status)
        }</span>

        // Add ordering, limit, and offset
        <span class="cov8" title="1">baseQuery += ` ORDER BY ` + params.OrderBy + ` LIMIT $` + strconv.Itoa(len(args)+1) + ` OFFSET $` + strconv.Itoa(len(args)+2)
        args = append(args, params.Limit, params.Offset)

        return TaskQueryBuilder{
                SelectQuery: baseQuery,
                CountQuery:  countQuery,
                Args:        args,
        }</span>
}

// formatTasksFromRows converts database rows into TaskResponse slice
func formatTasksFromRows(rows *sql.Rows) ([]TaskResponse, error) <span class="cov8" title="1">{
        var tasks []TaskResponse
        
        for rows.Next() </span><span class="cov8" title="1">{
                var task TaskResponse
                var domain string
                var startedAt, completedAt, createdAt sql.NullTime
                var statusCode, responseTime, secondResponseTime sql.NullInt32
                var cacheStatus, secondCacheStatus, contentType, errorMsg, sourceType, sourceURL sql.NullString

                err := rows.Scan(
                        &amp;task.ID, &amp;task.JobID, &amp;task.Path, &amp;domain, &amp;task.Status,
                        &amp;statusCode, &amp;responseTime, &amp;cacheStatus, &amp;secondResponseTime, &amp;secondCacheStatus, &amp;contentType, &amp;errorMsg, &amp;sourceType, &amp;sourceURL,
                        &amp;createdAt, &amp;startedAt, &amp;completedAt, &amp;task.RetryCount,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan task row: %w", err)
                }</span>

                // Construct full URL from domain and path
                <span class="cov8" title="1">task.URL = fmt.Sprintf("https://%s%s", domain, task.Path)

                // Handle nullable fields
                if statusCode.Valid </span><span class="cov8" title="1">{
                        sc := int(statusCode.Int32)
                        task.StatusCode = &amp;sc
                }</span>
                <span class="cov8" title="1">if responseTime.Valid </span><span class="cov8" title="1">{
                        rt := int(responseTime.Int32)
                        task.ResponseTime = &amp;rt
                }</span>
                <span class="cov8" title="1">if cacheStatus.Valid </span><span class="cov8" title="1">{
                        task.CacheStatus = &amp;cacheStatus.String
                }</span>
                <span class="cov8" title="1">if secondResponseTime.Valid </span><span class="cov8" title="1">{
                        srt := int(secondResponseTime.Int32)
                        task.SecondResponseTime = &amp;srt
                }</span>
                <span class="cov8" title="1">if secondCacheStatus.Valid </span><span class="cov8" title="1">{
                        task.SecondCacheStatus = &amp;secondCacheStatus.String
                }</span>
                <span class="cov8" title="1">if contentType.Valid </span><span class="cov8" title="1">{
                        task.ContentType = &amp;contentType.String
                }</span>
                <span class="cov8" title="1">if errorMsg.Valid </span><span class="cov8" title="1">{
                        task.Error = &amp;errorMsg.String
                }</span>
                <span class="cov8" title="1">if sourceType.Valid </span><span class="cov8" title="1">{
                        task.SourceType = &amp;sourceType.String
                }</span>
                <span class="cov8" title="1">if sourceURL.Valid </span><span class="cov8" title="1">{
                        task.SourceURL = &amp;sourceURL.String
                }</span>
                <span class="cov8" title="1">if startedAt.Valid </span><span class="cov8" title="1">{
                        sa := startedAt.Time.Format(time.RFC3339)
                        task.StartedAt = &amp;sa
                }</span>
                <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                        ca := completedAt.Time.Format(time.RFC3339)
                        task.CompletedAt = &amp;ca
                }</span>

                // Format created_at
                <span class="cov8" title="1">if createdAt.Valid </span><span class="cov8" title="1">{
                        task.CreatedAt = createdAt.Time.Format(time.RFC3339)
                }</span>

                <span class="cov8" title="1">tasks = append(tasks, task)</span>
        }

        <span class="cov8" title="1">return tasks, nil</span>
}

func getClientIP(r *http.Request) string <span class="cov8" title="1">{
        // Check for X-Forwarded-For header first (common with proxies/load balancers)
        xff := r.Header.Get("X-Forwarded-For")
        if xff != "" </span><span class="cov8" title="1">{
                // X-Forwarded-For can contain multiple IPs, use the first one
                if idx := strings.Index(xff, ","); idx != -1 </span><span class="cov8" title="1">{
                        return strings.TrimSpace(xff[:idx])
                }</span>
                <span class="cov8" title="1">return strings.TrimSpace(xff)</span>
        }

        // Check for X-Real-IP header
        <span class="cov8" title="1">xri := r.Header.Get("X-Real-IP")
        if xri != "" </span><span class="cov8" title="1">{
                return strings.TrimSpace(xri)
        }</span>

        // Fall back to RemoteAddr
        <span class="cov8" title="1">ip, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov8" title="1">{
                return r.RemoteAddr
        }</span>
        <span class="cov8" title="1">return ip</span>
}

// TaskResponse represents a task in API responses
type TaskResponse struct {
        ID                 string  `json:"id"`
        JobID              string  `json:"job_id"`
        Path               string  `json:"path"`
        URL                string  `json:"url"`
        Status             string  `json:"status"`
        StatusCode         *int    `json:"status_code,omitempty"`
        ResponseTime       *int    `json:"response_time,omitempty"`
        CacheStatus        *string `json:"cache_status,omitempty"`
        SecondResponseTime *int    `json:"second_response_time,omitempty"`
        SecondCacheStatus  *string `json:"second_cache_status,omitempty"`
        ContentType        *string `json:"content_type,omitempty"`
        Error              *string `json:"error,omitempty"`
        SourceType         *string `json:"source_type,omitempty"`
        SourceURL          *string `json:"source_url,omitempty"`
        CreatedAt          string  `json:"created_at"`
        StartedAt          *string `json:"started_at,omitempty"`
        CompletedAt        *string `json:"completed_at,omitempty"`
        RetryCount         int     `json:"retry_count"`
}

// getJobTasks handles GET /v1/jobs/:id/tasks
func (h *Handler) getJobTasks(w http.ResponseWriter, r *http.Request, jobID string) <span class="cov8" title="1">{
        // Validate user authentication and job access
        user := h.validateJobAccess(w, r, jobID)
        if user == nil </span><span class="cov8" title="1">{
                return // validateJobAccess already wrote the error response
        }</span>

        // Parse query parameters and build queries
        <span class="cov8" title="1">params := parseTaskQueryParams(r)
        queries := buildTaskQuery(jobID, params)

        // Get total count
        var total int
        countArgs := queries.Args[:len(queries.Args)-2] // Remove limit and offset for count query
        err := h.DB.GetDB().QueryRowContext(r.Context(), queries.CountQuery, countArgs...).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to count tasks")
                DatabaseError(w, r, err)
                return
        }</span>

        // Get tasks
        <span class="cov8" title="1">rows, err := h.DB.GetDB().QueryContext(r.Context(), queries.SelectQuery, queries.Args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to get tasks")
                DatabaseError(w, r, err)
                return
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        // Format tasks from database rows
        tasks, err := formatTasksFromRows(rows)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to format tasks")
                DatabaseError(w, r, err)
                return
        }</span>

        // Calculate pagination info
        <span class="cov8" title="1">hasNext := params.Offset+params.Limit &lt; total
        hasPrev := params.Offset &gt; 0

        // Prepare response
        response := map[string]interface{}{
                "tasks": tasks,
                "pagination": map[string]interface{}{
                        "limit":    params.Limit,
                        "offset":   params.Offset,
                        "total":    total,
                        "has_next": hasNext,
                        "has_prev": hasPrev,
                },
        }

        WriteSuccess(w, r, response, "Tasks retrieved successfully")</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package api

import (
        "context"
        "crypto/rand"
        "fmt"
        "net/http"
        "time"

        "github.com/rs/zerolog/log"
)

// contextKey is used for storing values in request context
type contextKey string

const requestIDKey contextKey = "request_id"

// RequestIDMiddleware adds a unique request ID to each request
func RequestIDMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Check if request ID already exists in headers (from load balancers, etc.)
                requestID := r.Header.Get("X-Request-ID")
                if requestID == "" </span><span class="cov8" title="1">{
                        requestID = generateRequestID()
                }</span>

                // Add request ID to response headers
                <span class="cov8" title="1">w.Header().Set("X-Request-ID", requestID)

                // Add request ID to request context
                ctx := context.WithValue(r.Context(), requestIDKey, requestID)
                r = r.WithContext(ctx)

                // Log the incoming request
                log.Info().
                        Str("request_id", requestID).
                        Str("method", r.Method).
                        Str("path", r.URL.Path).
                        Str("remote_addr", r.RemoteAddr).
                        Str("user_agent", r.UserAgent()).
                        Msg("Incoming request")

                next.ServeHTTP(w, r)</span>
        })
}

// GetRequestID retrieves the request ID from the request context
func GetRequestID(r *http.Request) string <span class="cov8" title="1">{
        if requestID, ok := r.Context().Value(requestIDKey).(string); ok </span><span class="cov8" title="1">{
                return requestID
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// generateRequestID creates a unique request ID
func generateRequestID() string <span class="cov8" title="1">{
        // Use timestamp + random bytes for uniqueness
        timestamp := time.Now().UnixNano()

        // Generate 4 random bytes
        randomBytes := make([]byte, 4)
        rand.Read(randomBytes)

        return fmt.Sprintf("%x-%x", timestamp, randomBytes)
}</span>

// LoggingMiddleware logs request details and response times
func LoggingMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                start := time.Now()
                requestID := GetRequestID(r)

                // Wrap the ResponseWriter to capture status code
                wrapper := &amp;responseWrapper{
                        ResponseWriter: w,
                        statusCode:     http.StatusOK,
                }

                next.ServeHTTP(wrapper, r)

                duration := time.Since(start)

                // Log the completed request
                log.Info().
                        Str("request_id", requestID).
                        Str("method", r.Method).
                        Str("path", r.URL.Path).
                        Int("status", wrapper.statusCode).
                        Dur("duration", duration).
                        Msg("Request completed")
        }</span>)
}

// responseWrapper wraps http.ResponseWriter to capture status code
type responseWrapper struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWrapper) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// CORSMiddleware adds CORS headers for browser requests
func CORSMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Set CORS headers
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Request-ID")
                w.Header().Set("Access-Control-Expose-Headers", "X-Request-ID")

                // Handle preflight requests
                if r.Method == http.MethodOptions </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusOK)
                        return
                }</span>

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// CrossOriginProtectionMiddleware provides protection against CSRF attacks.
// It is a wrapper around Go's experimental http.CrossOriginProtection.
func CrossOriginProtectionMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        // Using nil for the config uses the default protection.
        // The Handler method returns a handler that serves the given handler
        // after performing cross-origin request checks.
        return http.NewCrossOriginProtection().Handler(next)
}</span>

// SecurityHeadersMiddleware adds security-related headers
func SecurityHeadersMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("Content-Security-Policy", "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';")
                w.Header().Set("Strict-Transport-Security", "max-age=63072000; includeSubDomains")
                next.ServeHTTP(w, r)
        }</span>)
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package api

import (
        "encoding/json"
        "net/http"
        "time"

        "github.com/rs/zerolog/log"
)

// SuccessResponse represents a standardised success response
type SuccessResponse struct {
        Status    string      `json:"status"`
        Data      interface{} `json:"data,omitempty"`
        Message   string      `json:"message,omitempty"`
        RequestID string      `json:"request_id,omitempty"`
}

// WriteJSON writes a JSON response with the given status code
func WriteJSON(w http.ResponseWriter, r *http.Request, data interface{}, status int) <span class="cov8" title="1">{
        requestID := GetRequestID(r)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("request_id", requestID).
                        Msg("Failed to encode JSON response")
        }</span>
}

// WriteSuccess writes a standardised success response
func WriteSuccess(w http.ResponseWriter, r *http.Request, data interface{}, message string) <span class="cov8" title="1">{
        requestID := GetRequestID(r)

        response := SuccessResponse{
                Status:    "success",
                Data:      data,
                Message:   message,
                RequestID: requestID,
        }

        WriteJSON(w, r, response, http.StatusOK)
}</span>

// WriteCreated writes a standardised success response for created resources
func WriteCreated(w http.ResponseWriter, r *http.Request, data interface{}, message string) <span class="cov8" title="1">{
        requestID := GetRequestID(r)

        response := SuccessResponse{
                Status:    "success",
                Data:      data,
                Message:   message,
                RequestID: requestID,
        }

        WriteJSON(w, r, response, http.StatusCreated)
}</span>

// WriteNoContent writes a 204 No Content response
func WriteNoContent(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.WriteHeader(http.StatusNoContent)
}</span>

// HealthResponse represents a health check response
type HealthResponse struct {
        Status    string `json:"status"`
        Timestamp string `json:"timestamp"`
        Service   string `json:"service"`
        Version   string `json:"version,omitempty"`
}

// WriteHealthy writes a standardised health check response
func WriteHealthy(w http.ResponseWriter, r *http.Request, service string, version string) <span class="cov8" title="1">{
        response := HealthResponse{
                Status:    "healthy",
                Timestamp: time.Now().Format(time.RFC3339),
                Service:   service,
                Version:   version,
        }

        WriteJSON(w, r, response, http.StatusOK)
}</span>

// WriteUnhealthy writes a standardised unhealthy response
func WriteUnhealthy(w http.ResponseWriter, r *http.Request, service string, err error) <span class="cov8" title="1">{
        requestID := GetRequestID(r)

        response := map[string]interface{}{
                "status":     "unhealthy",
                "timestamp":  time.Now().Format(time.RFC3339),
                "service":    service,
                "error":      err.Error(),
                "request_id": requestID,
        }

        WriteJSON(w, r, response, http.StatusServiceUnavailable)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package api

import (
        "bytes"
        "context"
        "database/sql"
        "net/http"
        "net/http/httptest"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/auth"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/Harvey-AU/blue-banded-bee/internal/jobs"
        "github.com/stretchr/testify/mock"
)

// MockJobManager is a mock implementation of jobs.JobManagerInterface
type MockJobManager struct {
        mock.Mock
}

func (m *MockJobManager) CreateJob(ctx context.Context, options *jobs.JobOptions) (*jobs.Job, error) <span class="cov8" title="1">{
        args := m.Called(ctx, options)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*jobs.Job), args.Error(1)</span>
}

func (m *MockJobManager) StartJob(ctx context.Context, jobID string) error <span class="cov8" title="1">{
        args := m.Called(ctx, jobID)
        return args.Error(0)
}</span>

func (m *MockJobManager) CancelJob(ctx context.Context, jobID string) error <span class="cov8" title="1">{
        args := m.Called(ctx, jobID)
        return args.Error(0)
}</span>

func (m *MockJobManager) GetJobStatus(ctx context.Context, jobID string) (*jobs.Job, error) <span class="cov8" title="1">{
        args := m.Called(ctx, jobID)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*jobs.Job), args.Error(1)</span>
}

func (m *MockJobManager) GetJob(ctx context.Context, jobID string) (*jobs.Job, error) <span class="cov0" title="0">{
        args := m.Called(ctx, jobID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*jobs.Job), args.Error(1)</span>
}

func (m *MockJobManager) EnqueueJobURLs(ctx context.Context, jobID string, pages []db.Page, sourceType string, sourceURL string) error <span class="cov0" title="0">{
        args := m.Called(ctx, jobID, pages, sourceType, sourceURL)
        return args.Error(0)
}</span>

func (m *MockJobManager) IsJobComplete(job *jobs.Job) bool <span class="cov0" title="0">{
        args := m.Called(job)
        return args.Bool(0)
}</span>

func (m *MockJobManager) CalculateJobProgress(job *jobs.Job) float64 <span class="cov0" title="0">{
        args := m.Called(job)
        return args.Get(0).(float64)
}</span>

func (m *MockJobManager) ValidateStatusTransition(from, to jobs.JobStatus) error <span class="cov0" title="0">{
        args := m.Called(from, to)
        return args.Error(0)
}</span>

func (m *MockJobManager) UpdateJobStatus(ctx context.Context, jobID string, status jobs.JobStatus) error <span class="cov0" title="0">{
        args := m.Called(ctx, jobID, status)
        return args.Error(0)
}</span>

// MockDBClient is a mock implementation of DBClient interface
type MockDBClient struct {
        mock.Mock
}

func (m *MockDBClient) GetDB() *sql.DB <span class="cov8" title="1">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*sql.DB)</span>
}

func (m *MockDBClient) GetOrCreateUser(userID, email string, orgID *string) (*db.User, error) <span class="cov8" title="1">{
        args := m.Called(userID, email, orgID)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*db.User), args.Error(1)</span>
}

func (m *MockDBClient) GetUserByWebhookToken(token string) (*db.User, error) <span class="cov8" title="1">{
        args := m.Called(token)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*db.User), args.Error(1)</span>
}

func (m *MockDBClient) ListJobs(organisationID string, limit, offset int, status, dateRange string) ([]db.JobWithDomain, int, error) <span class="cov0" title="0">{
        args := m.Called(organisationID, limit, offset, status, dateRange)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Int(1), args.Error(2)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]db.JobWithDomain), args.Int(1), args.Error(2)</span>
}

func (m *MockDBClient) GetJobStats(organisationID string, startDate, endDate *time.Time) (*db.JobStats, error) <span class="cov8" title="1">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).(*db.JobStats), args.Error(1)</span>
}

func (m *MockDBClient) GetJobActivity(organisationID string, startDate, endDate *time.Time) ([]db.ActivityPoint, error) <span class="cov8" title="1">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).([]db.ActivityPoint), args.Error(1)</span>
}

func (m *MockDBClient) GetSlowPages(organisationID string, startDate, endDate *time.Time) ([]db.SlowPage, error) <span class="cov8" title="1">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).([]db.SlowPage), args.Error(1)</span>
}

func (m *MockDBClient) GetExternalRedirects(organisationID string, startDate, endDate *time.Time) ([]db.ExternalRedirect, error) <span class="cov8" title="1">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov8" title="1">return args.Get(0).([]db.ExternalRedirect), args.Error(1)</span>
}

func (m *MockDBClient) GetUser(userID string) (*db.User, error) <span class="cov0" title="0">{
        args := m.Called(userID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.User), args.Error(1)</span>
}

func (m *MockDBClient) ResetSchema() error <span class="cov0" title="0">{
        args := m.Called()
        return args.Error(0)
}</span>

func (m *MockDBClient) CreateUser(userID, email string, fullName *string, orgName string) (*db.User, *db.Organisation, error) <span class="cov0" title="0">{
        args := m.Called(userID, email, fullName, orgName)
        var user *db.User
        var org *db.Organisation
        if args.Get(0) != nil </span><span class="cov0" title="0">{
                user = args.Get(0).(*db.User)
        }</span>
        <span class="cov0" title="0">if args.Get(1) != nil </span><span class="cov0" title="0">{
                org = args.Get(1).(*db.Organisation)
        }</span>
        <span class="cov0" title="0">return user, org, args.Error(2)</span>
}

func (m *MockDBClient) GetOrganisation(organisationID string) (*db.Organisation, error) <span class="cov0" title="0">{
        args := m.Called(organisationID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.Organisation), args.Error(1)</span>
}

// Test helpers
func createTestHandler() (*Handler, *MockDBClient, *MockJobManager) <span class="cov8" title="1">{
        mockDB := new(MockDBClient)
        mockJobsManager := new(MockJobManager)
        
        handler := NewHandler(mockDB, mockJobsManager)
        return handler, mockDB, mockJobsManager
}</span>

func createAuthenticatedRequest(method, url string, body []byte) *http.Request <span class="cov8" title="1">{
        var req *http.Request
        if body != nil </span><span class="cov8" title="1">{
                req = httptest.NewRequest(method, url, bytes.NewBuffer(body))
                req.Header.Set("Content-Type", "application/json")
        }</span> else<span class="cov8" title="1"> {
                req = httptest.NewRequest(method, url, nil)
        }</span>
        
        // Add user context for authentication
        <span class="cov8" title="1">ctx := context.WithValue(req.Context(), auth.UserKey, &amp;auth.UserClaims{
                UserID: "test-user-123",
                Email:  "test@example.com",
        })
        return req.WithContext(ctx)</span>
}

// Helper functions for pointer creation
func boolPtr(b bool) *bool <span class="cov8" title="1">{
        return &amp;b
}</span>

func intPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>

func stringPtr(s string) *string <span class="cov8" title="1">{
        return &amp;s
}</pre>
		
		<pre class="file" id="file10" style="display: none">package auth

import (
        "fmt"
        "os"
)

// Config holds Supabase authentication configuration
type Config struct {
        SupabaseURL     string
        SupabaseAnonKey string
        JWTSecret       string
}

// NewConfigFromEnv creates auth config from environment variables
func NewConfigFromEnv() (*Config, error) <span class="cov8" title="1">{
        config := &amp;Config{
                SupabaseURL:     os.Getenv("SUPABASE_URL"),
                SupabaseAnonKey: os.Getenv("SUPABASE_ANON_KEY"),
                JWTSecret:       os.Getenv("SUPABASE_JWT_SECRET"),
        }

        // Validate required environment variables
        if config.SupabaseURL == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("SUPABASE_URL environment variable is required")
        }</span>
        <span class="cov8" title="1">if config.SupabaseAnonKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("SUPABASE_ANON_KEY environment variable is required")
        }</span>
        <span class="cov8" title="1">if config.JWTSecret == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("SUPABASE_JWT_SECRET environment variable is required")
        }</span>

        <span class="cov8" title="1">return config, nil</span>
}

// Validate ensures all required configuration is present
func (c *Config) Validate() error <span class="cov8" title="1">{
        if c.SupabaseURL == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("SupabaseURL is required")
        }</span>
        <span class="cov8" title="1">if c.SupabaseAnonKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("SupabaseAnonKey is required")
        }</span>
        <span class="cov8" title="1">if c.JWTSecret == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("JWTSecret is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "strings"
        "time"

        "github.com/getsentry/sentry-go"
        "github.com/golang-jwt/jwt/v5"
        "github.com/rs/zerolog/log"
)

// AuthClient defines the interface for authentication operations
type AuthClient interface {
        ValidateToken(ctx context.Context, token string) (*UserClaims, error)
        ExtractTokenFromRequest(r *http.Request) (string, error)
        SetUserInContext(r *http.Request, user *UserClaims) *http.Request
}

// SupabaseAuthClient implements AuthClient for Supabase authentication
type SupabaseAuthClient struct{}

// NewSupabaseAuthClient creates a new SupabaseAuthClient
func NewSupabaseAuthClient() *SupabaseAuthClient <span class="cov8" title="1">{
        return &amp;SupabaseAuthClient{}
}</span>

// ValidateToken validates a Supabase JWT token
func (s *SupabaseAuthClient) ValidateToken(ctx context.Context, token string) (*UserClaims, error) <span class="cov0" title="0">{
        return validateSupabaseToken(token)
}</span>

// ExtractTokenFromRequest extracts a JWT token from the Authorization header
func (s *SupabaseAuthClient) ExtractTokenFromRequest(r *http.Request) (string, error) <span class="cov0" title="0">{
        authHeader := r.Header.Get("Authorization")
        if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return "", fmt.Errorf("missing or invalid Authorization header")
        }</span>
        <span class="cov0" title="0">return strings.TrimPrefix(authHeader, "Bearer "), nil</span>
}

// SetUserInContext adds user claims to the request context
func (s *SupabaseAuthClient) SetUserInContext(r *http.Request, user *UserClaims) *http.Request <span class="cov0" title="0">{
        ctx := context.WithValue(r.Context(), UserKey, user)
        return r.WithContext(ctx)
}</span>

// UserContextKey is the key used to store user claims in the request context
type UserContextKey string

const (
        UserKey UserContextKey = "user"
)

// UserClaims represents the Supabase JWT claims
type UserClaims struct {
        jwt.RegisteredClaims
        UserID       string                 `json:"sub"`
        Email        string                 `json:"email"`
        AppMetadata  map[string]interface{} `json:"app_metadata"`
        UserMetadata map[string]interface{} `json:"user_metadata"`
        Role         string                 `json:"role"`
}

// AuthMiddleware validates Supabase JWT tokens (uses default SupabaseAuthClient)
func AuthMiddleware(next http.Handler) http.Handler <span class="cov8" title="1">{
        return AuthMiddlewareWithClient(NewSupabaseAuthClient())(next)
}</span>

// AuthMiddlewareWithClient validates JWT tokens using the provided AuthClient
func AuthMiddlewareWithClient(authClient AuthClient) func(http.Handler) http.Handler <span class="cov8" title="1">{
        return func(next http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        // Extract the JWT from the Authorization header
                        tokenString, err := authClient.ExtractTokenFromRequest(r)
                        if err != nil </span><span class="cov8" title="1">{
                                writeAuthError(w, r, "Missing or invalid Authorization header", http.StatusUnauthorized)
                                return
                        }</span>

                        // Validate the JWT
                        <span class="cov8" title="1">claims, err := authClient.ValidateToken(r.Context(), tokenString)
                        if err != nil </span><span class="cov8" title="1">{
                                log.Warn().Err(err).Str("token_prefix", tokenString[:min(10, len(tokenString))]).Msg("JWT validation failed")

                                // Determine specific error type and capture critical errors in Sentry
                                errorMsg := "Invalid authentication token"
                                statusCode := http.StatusUnauthorized

                                if strings.Contains(err.Error(), "expired") </span><span class="cov0" title="0">{
                                        errorMsg = "Authentication token has expired"
                                        // Don't capture expired tokens - this is normal user behavior
                                }</span> else<span class="cov8" title="1"> if strings.Contains(err.Error(), "signature") </span><span class="cov0" title="0">{
                                        errorMsg = "Invalid token signature"
                                        // Capture invalid signatures - potential security issue
                                        sentry.CaptureException(err)
                                }</span> else<span class="cov8" title="1"> if strings.Contains(err.Error(), "SUPABASE_JWT_SECRET") </span><span class="cov0" title="0">{
                                        errorMsg = "Authentication service misconfigured"
                                        statusCode = http.StatusInternalServerError
                                        // Capture service misconfigurations - critical system error
                                        sentry.CaptureException(err)
                                }</span>

                                <span class="cov8" title="1">writeAuthError(w, r, errorMsg, statusCode)
                                return</span>
                        }

                        // Add user claims to context using the auth client
                        <span class="cov8" title="1">r = authClient.SetUserInContext(r, claims)
                        next.ServeHTTP(w, r)</span>
                })
        }
}

// validateSupabaseToken validates and parses a Supabase JWT token
func validateSupabaseToken(tokenString string) (*UserClaims, error) <span class="cov8" title="1">{
        // Get JWT secret from environment
        jwtSecret := os.Getenv("SUPABASE_JWT_SECRET")
        if jwtSecret == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("SUPABASE_JWT_SECRET environment variable not set")
        }</span>

        // Parse and validate the token
        <span class="cov0" title="0">token, err := jwt.ParseWithClaims(tokenString, &amp;UserClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                // Validate signing method
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>

                <span class="cov0" title="0">return []byte(jwtSecret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse token: %w", err)
        }</span>

        // Extract and return claims
        <span class="cov0" title="0">if claims, ok := token.Claims.(*UserClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token claims")</span>
}

// GetUserFromContext extracts user claims from the request context
func GetUserFromContext(ctx context.Context) (*UserClaims, bool) <span class="cov8" title="1">{
        user, ok := ctx.Value(UserKey).(*UserClaims)
        return user, ok
}</span>

// OptionalAuthMiddleware validates JWT if present but doesn't require it
func OptionalAuthMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Check if Authorization header is present
                authHeader := r.Header.Get("Authorization")
                if authHeader != "" &amp;&amp; strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        tokenString := strings.TrimPrefix(authHeader, "Bearer ")

                        // Try to validate the token
                        claims, err := validateSupabaseToken(tokenString)
                        if err == nil </span><span class="cov0" title="0">{
                                // Token is valid, add to context
                                ctx := context.WithValue(r.Context(), UserKey, claims)
                                r = r.WithContext(ctx)
                        }</span> else<span class="cov0" title="0"> {
                                // Token is invalid but we continue without auth
                                log.Warn().Err(err).Msg("Invalid JWT token in optional auth")
                        }</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

// writeAuthError writes a standardised authentication error response
func writeAuthError(w http.ResponseWriter, r *http.Request, message string, statusCode int) <span class="cov8" title="1">{
        // Get request ID if available (fallback to empty string if not)
        var requestID string
        if r != nil &amp;&amp; r.Context() != nil </span><span class="cov8" title="1">{
                if rid := r.Context().Value("request_id"); rid != nil </span><span class="cov0" title="0">{
                        if ridStr, ok := rid.(string); ok </span><span class="cov0" title="0">{
                                requestID = ridStr
                        }</span>
                }
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)

        response := map[string]interface{}{
                "status":     statusCode,
                "message":    message,
                "code":       "UNAUTHORISED",
                "request_id": requestID,
        }

        json.NewEncoder(w).Encode(response)</span>
}

// min returns the minimum of two integers
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// SessionInfo holds session information and token validity
type SessionInfo struct {
        IsValid       bool   `json:"is_valid"`
        ExpiresAt     int64  `json:"expires_at,omitempty"`
        RefreshNeeded bool   `json:"refresh_needed"`
        UserID        string `json:"user_id,omitempty"`
        Email         string `json:"email,omitempty"`
}

// ValidateSession validates a JWT token and returns session information
func ValidateSession(tokenString string) *SessionInfo <span class="cov8" title="1">{
        claims, err := validateSupabaseToken(tokenString)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;SessionInfo{
                        IsValid:       false,
                        RefreshNeeded: strings.Contains(err.Error(), "expired"),
                }
        }</span>

        // Check if token expires soon (within 5 minutes)
        <span class="cov0" title="0">refreshNeeded := false
        if claims.ExpiresAt != nil </span><span class="cov0" title="0">{
                timeUntilExpiry := claims.ExpiresAt.Time.Unix() - time.Now().Unix()
                refreshNeeded = timeUntilExpiry &lt; 300 // 5 minutes
        }</span>

        <span class="cov0" title="0">return &amp;SessionInfo{
                IsValid:       true,
                ExpiresAt:     claims.ExpiresAt.Time.Unix(),
                RefreshNeeded: refreshNeeded,
                UserID:        claims.UserID,
                Email:         claims.Email,
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cache

import "sync"

// InMemoryCache is a simple, concurrent-safe in-memory key-value store.
type InMemoryCache struct {
        mu    sync.RWMutex
        items map[string]interface{}
}

// NewInMemoryCache creates and returns a new InMemoryCache.
func NewInMemoryCache() *InMemoryCache <span class="cov8" title="1">{
        return &amp;InMemoryCache{
                items: make(map[string]interface{}),
        }
}</span>

// Get retrieves a value from the cache.
// It returns the value and true if the key exists, otherwise nil and false.
func (c *InMemoryCache) Get(key string) (interface{}, bool) <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        item, found := c.items[key]
        return item, found
}</span>

// Set adds or updates a value in the cache.
func (c *InMemoryCache) Set(key string, value interface{}) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.items[key] = value
}</span>

// Delete removes a value from the cache.
func (c *InMemoryCache) Delete(key string) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        delete(c.items, key)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package crawler

import (
        "time"
)

// Config holds the configuration for a crawler instance
type Config struct {
        DefaultTimeout time.Duration // Default timeout for requests
        MaxConcurrency int           // Maximum number of concurrent requests
        RateLimit      int           // Maximum requests per second
        UserAgent      string        // User agent string for requests
        RetryAttempts  int           // Number of retry attempts for failed requests
        RetryDelay     time.Duration // Delay between retry attempts
        SkipCachedURLs bool          // Whether to skip URLs that are already cached (HIT)
        Port           string        // Server port
        Env            string        // Environment (development/production)
        LogLevel       string        // Logging level
        DatabaseURL    string        // Database connection URL
        AuthToken      string        // Database authentication token
        SentryDSN      string        // Sentry DSN for error tracking
        FindLinks      bool          // Whether to extract links (e.g. PDFs/docs) from pages
}

// DefaultConfig returns a Config instance with default values
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                DefaultTimeout: 30 * time.Second,
                MaxConcurrency: 10,
                RateLimit:      3,
                UserAgent:      "BlueBandedBee/1.0 (+https://www.bluebandedbee.co/pages/about-the-bot)",
                RetryAttempts:  3,
                RetryDelay:     500 * time.Millisecond,
                SkipCachedURLs: false, // Default to crawling all URLs
                FindLinks:      false,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package crawler

import (
        "context"
        "crypto/tls"
        "fmt"
        "net/http"
        "net/http/httptrace"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/PuerkitoBio/goquery"
        "github.com/gocolly/colly/v2"
        "github.com/rs/zerolog/log"
)

// Crawler represents a URL crawler with configuration and metrics
type Crawler struct {
        config     *Config
        colly      *colly.Collector
        id         string    // Add an ID field to identify each crawler instance
        metricsMap *sync.Map // Shared metrics storage for the transport
}

// GetUserAgent returns the user agent string for this crawler
func (c *Crawler) GetUserAgent() string <span class="cov0" title="0">{
        return c.config.UserAgent
}</span>

// tracingRoundTripper captures HTTP trace metrics for each request
type tracingRoundTripper struct {
        transport  http.RoundTripper
        metricsMap *sync.Map // Maps URL -&gt; PerformanceMetrics
}

// RoundTrip implements the http.RoundTripper interface with httptrace instrumentation
func (t *tracingRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov8" title="1">{
        // Create performance metrics for this request
        metrics := &amp;PerformanceMetrics{}

        // Create trace with callbacks that populate metrics
        var dnsStartTime, connectStartTime, tlsStartTime, requestStartTime time.Time
        requestStartTime = time.Now()

        trace := &amp;httptrace.ClientTrace{
                DNSStart: func(info httptrace.DNSStartInfo) </span><span class="cov8" title="1">{
                        dnsStartTime = time.Now()
                }</span>,
                DNSDone: func(info httptrace.DNSDoneInfo) <span class="cov8" title="1">{
                        if !dnsStartTime.IsZero() </span><span class="cov8" title="1">{
                                metrics.DNSLookupTime = time.Since(dnsStartTime).Milliseconds()
                        }</span>
                },
                ConnectStart: func(network, addr string) <span class="cov8" title="1">{
                        connectStartTime = time.Now()
                }</span>,
                ConnectDone: func(network, addr string, err error) <span class="cov8" title="1">{
                        if err == nil &amp;&amp; !connectStartTime.IsZero() </span><span class="cov8" title="1">{
                                metrics.TCPConnectionTime = time.Since(connectStartTime).Milliseconds()
                        }</span>
                },
                TLSHandshakeStart: func() <span class="cov8" title="1">{
                        tlsStartTime = time.Now()
                }</span>,
                TLSHandshakeDone: func(state tls.ConnectionState, err error) <span class="cov8" title="1">{
                        if err == nil &amp;&amp; !tlsStartTime.IsZero() </span><span class="cov8" title="1">{
                                metrics.TLSHandshakeTime = time.Since(tlsStartTime).Milliseconds()
                        }</span>
                },
                GotFirstResponseByte: func() <span class="cov8" title="1">{
                        metrics.TTFB = time.Since(requestStartTime).Milliseconds()
                }</span>,
        }

        // Store metrics for this URL (will be retrieved in OnResponse)
        <span class="cov8" title="1">t.metricsMap.Store(req.URL.String(), metrics)

        // Attach trace to request context
        req = req.WithContext(httptrace.WithClientTrace(req.Context(), trace))

        // Perform the request
        return t.transport.RoundTrip(req)</span>
}

// New creates a new Crawler instance with the given configuration and optional ID
// If config is nil, default configuration is used
func New(config *Config, id ...string) *Crawler <span class="cov8" title="1">{
        if config == nil </span><span class="cov8" title="1">{
                config = DefaultConfig()
        }</span>

        <span class="cov8" title="1">crawlerID := ""
        if len(id) &gt; 0 </span><span class="cov0" title="0">{
                crawlerID = id[0]
        }</span>

        <span class="cov8" title="1">userAgent := config.UserAgent
        if crawlerID != "" </span><span class="cov0" title="0">{
                userAgent = fmt.Sprintf("%s Worker-%s", config.UserAgent, crawlerID)
        }</span>

        <span class="cov8" title="1">c := colly.NewCollector(
                colly.UserAgent(userAgent),
                colly.MaxDepth(1),
                colly.Async(true),
                colly.AllowURLRevisit(),
        )

        c.Limit(&amp;colly.LimitRule{
                DomainGlob:  "*",
                Parallelism: config.MaxConcurrency,
                RandomDelay: time.Second / time.Duration(config.RateLimit),
        })

        // Create metrics map for this crawler instance
        metricsMap := &amp;sync.Map{}

        // Set up base transport
        baseTransport := &amp;http.Transport{
                MaxIdleConnsPerHost: 25,
                MaxConnsPerHost:     50,
                IdleConnTimeout:     120 * time.Second,
                TLSHandshakeTimeout: 10 * time.Second,
                DisableCompression:  true,
                ForceAttemptHTTP2:   true,
        }

        // Wrap the base transport with our custom tracing transport
        tracingTransport := &amp;tracingRoundTripper{
                transport:  baseTransport,
                metricsMap: metricsMap,
        }

        // Set HTTP client with tracing transport and proper timeout
        httpClient := &amp;http.Client{
                Timeout:   config.DefaultTimeout,
                Transport: tracingTransport,
        }
        c.SetClient(httpClient)

        // Add browser-like headers to avoid blocking
        c.OnRequest(func(r *colly.Request) </span><span class="cov0" title="0">{
                // Set browser-like headers
                r.Headers.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
                r.Headers.Set("Accept-Language", "en-US,en;q=0.9")
                r.Headers.Set("Accept-Encoding", "gzip, deflate, br")

                log.Debug().
                        Str("url", r.URL.String()).
                        Msg("Crawler sending request")
        }</span>)

        // Note: OnHTML handler will be registered on the clone in WarmURL to ensure proper context access

        <span class="cov8" title="1">return &amp;Crawler{
                config:     config,
                colly:      c,
                id:         crawlerID,
                metricsMap: metricsMap,
        }</span>
}

// validateCrawlRequest validates the crawl request parameters and URL format
func validateCrawlRequest(ctx context.Context, targetURL string) (*url.URL, error) <span class="cov8" title="1">{
        if err := ctx.Err(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">parsed, err := url.Parse(targetURL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to parse URL: %w", err)
        }</span>

        <span class="cov8" title="1">if parsed.Scheme == "" || parsed.Host == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid URL format: %s", targetURL)
        }</span>

        <span class="cov8" title="1">return parsed, nil</span>
}

// setupResponseHandlers configures Colly response and error handlers for crawl result collection
func (c *Crawler) setupResponseHandlers(collyClone *colly.Collector, result *CrawlResult, startTime time.Time, targetURL string) <span class="cov8" title="1">{
        // Handle response - collect cache headers, status, timing
        collyClone.OnResponse(func(r *colly.Response) </span><span class="cov8" title="1">{
                startTime := r.Ctx.GetAny("start_time").(time.Time)
                result := r.Ctx.GetAny("result").(*CrawlResult)

                // Retrieve performance metrics from the metrics map
                if metricsVal, ok := c.metricsMap.LoadAndDelete(r.Request.URL.String()); ok </span><span class="cov8" title="1">{
                        performanceMetrics := metricsVal.(*PerformanceMetrics)
                        // Content transfer time is total response time minus TTFB
                        if performanceMetrics.TTFB &gt; 0 </span><span class="cov8" title="1">{
                                performanceMetrics.ContentTransferTime = time.Since(startTime).Milliseconds() - performanceMetrics.TTFB
                        }</span>
                        <span class="cov8" title="1">result.Performance = *performanceMetrics</span>
                }

                // Calculate response time
                <span class="cov8" title="1">result.ResponseTime = time.Since(startTime).Milliseconds()
                result.StatusCode = r.StatusCode
                result.ContentType = r.Headers.Get("Content-Type")
                result.ContentLength = int64(len(r.Body))
                result.Headers = r.Headers.Clone()
                result.RedirectURL = r.Request.URL.String()

                // Log comprehensive Cloudflare headers for analysis
                cfCacheStatus := r.Headers.Get("CF-Cache-Status")
                cfRay := r.Headers.Get("CF-Ray")
                cfDatacenter := r.Headers.Get("CF-IPCountry")
                cfConnectingIP := r.Headers.Get("CF-Connecting-IP")
                cfVisitor := r.Headers.Get("CF-Visitor")

                log.Debug().
                        Str("url", r.Request.URL.String()).
                        Str("cf_cache_status", cfCacheStatus).
                        Str("cf_ray", cfRay).
                        Str("cf_datacenter", cfDatacenter).
                        Str("cf_connecting_ip", cfConnectingIP).
                        Str("cf_visitor", cfVisitor).
                        Int64("response_time_ms", result.ResponseTime).
                        Msg("Cloudflare headers analysis")

                // Check for cache status headers from different CDNs
                // Cloudflare
                if cacheStatus := r.Headers.Get("CF-Cache-Status"); cacheStatus != "" </span><span class="cov8" title="1">{
                        result.CacheStatus = cacheStatus
                }</span>
                // Fastly
                <span class="cov8" title="1">if cacheStatus := r.Headers.Get("X-Cache"); cacheStatus != "" &amp;&amp; result.CacheStatus == "" </span><span class="cov0" title="0">{
                        result.CacheStatus = cacheStatus
                }</span>
                // Akamai
                <span class="cov8" title="1">if cacheStatus := r.Headers.Get("X-Cache-Remote"); cacheStatus != "" &amp;&amp; result.CacheStatus == "" </span><span class="cov0" title="0">{
                        result.CacheStatus = cacheStatus
                }</span>
                // Vercel
                <span class="cov8" title="1">if cacheStatus := r.Headers.Get("x-vercel-cache"); cacheStatus != "" &amp;&amp; result.CacheStatus == "" </span><span class="cov0" title="0">{
                        result.CacheStatus = cacheStatus
                }</span>
                // Standard Cache-Status header (newer standardized approach)
                <span class="cov8" title="1">if cacheStatus := r.Headers.Get("Cache-Status"); cacheStatus != "" &amp;&amp; result.CacheStatus == "" </span><span class="cov0" title="0">{
                        result.CacheStatus = cacheStatus
                }</span>
                // Varnish (the presence of X-Varnish indicates it was processed by Varnish)
                <span class="cov8" title="1">if varnishID := r.Headers.Get("X-Varnish"); varnishID != "" &amp;&amp; result.CacheStatus == "" </span><span class="cov0" title="0">{
                        if strings.Contains(varnishID, " ") </span><span class="cov0" title="0">{
                                result.CacheStatus = "HIT" // Multiple IDs indicate a cache hit
                        }</span> else<span class="cov0" title="0"> {
                                result.CacheStatus = "MISS" // Single ID indicates a cache miss
                        }</span>
                }

                // Set error for non-2xx status codes (to match test expectations)
                <span class="cov8" title="1">if r.StatusCode &lt; 200 || r.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                        result.Error = fmt.Sprintf("non-success status code: %d", r.StatusCode)
                }</span>
        })

        // Handle errors
        <span class="cov8" title="1">collyClone.OnError(func(r *colly.Response, err error) </span><span class="cov8" title="1">{
                result := r.Ctx.GetAny("result").(*CrawlResult)
                result.Error = err.Error()

                if r != nil </span><span class="cov8" title="1">{
                        startTime := r.Ctx.GetAny("start_time").(time.Time)
                        result.ResponseTime = time.Since(startTime).Milliseconds()
                        result.StatusCode = r.StatusCode
                }</span>

                <span class="cov8" title="1">log.Error().
                        Err(err).
                        Str("url", targetURL).
                        Dur("duration_ms", time.Duration(result.ResponseTime)*time.Millisecond).
                        Msg("URL warming failed")</span>
        })
}

// performCacheValidation handles cache warming logic if cache miss is detected
func (c *Crawler) performCacheValidation(ctx context.Context, targetURL string, res *CrawlResult) error <span class="cov8" title="1">{
        // Only perform cache warming if we got a MISS or BYPASS
        if !shouldMakeSecondRequest(res.CacheStatus) </span><span class="cov8" title="1">{
                log.Debug().
                        Str("url", targetURL).
                        Str("cache_status", res.CacheStatus).
                        Msg("No cache warming needed - cache already available or not cacheable")
                return nil
        }</span>

        // Calculate dynamic delay based on response time
        <span class="cov8" title="1">delayMs := int(float64(res.ResponseTime) * 1.5)
        if delayMs &lt; 500 </span><span class="cov8" title="1">{
                delayMs = 500 // Minimum 500ms delay
        }</span> else<span class="cov8" title="1"> if delayMs &gt; 5000 </span><span class="cov0" title="0">{
                delayMs = 5000 // Maximum 5 second delay
        }</span>

        <span class="cov8" title="1">log.Debug().
                Str("url", targetURL).
                Str("cache_status", res.CacheStatus).
                Int64("initial_response_time", res.ResponseTime).
                Int("calculated_delay_ms", delayMs).
                Msg("Cache MISS detected, using dynamic delay based on initial response time")

        // Wait for initial delay to allow CDN to process and cache
        select </span>{
        case &lt;-time.After(time.Duration(delayMs) * time.Millisecond):<span class="cov0" title="0"></span>
                // Continue with cache check loop
        case &lt;-ctx.Done():<span class="cov8" title="1">
                // Context cancelled during wait
                log.Debug().Str("url", targetURL).Msg("Cache warming cancelled during initial delay")
                return nil</span> // First request was successful, return that
        }

        // Check cache status with HEAD requests in a loop
        <span class="cov0" title="0">maxChecks := 10
        checkDelay := 2000 // Initial 2 seconds delay
        cacheHit := false

        for i := 0; i &lt; maxChecks; i++ </span><span class="cov0" title="0">{
                // Check cache status with HEAD request
                cacheStatus, err := c.CheckCacheStatus(ctx, targetURL)

                // Record the attempt
                attempt := CacheCheckAttempt{
                        Attempt:     i + 1,
                        CacheStatus: cacheStatus,
                        Delay:       checkDelay,
                }
                res.CacheCheckAttempts = append(res.CacheCheckAttempts, attempt)

                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().
                                Err(err).
                                Str("url", targetURL).
                                Int("check_attempt", i+1).
                                Msg("Failed to check cache status")
                }</span> else<span class="cov0" title="0"> {
                        log.Debug().
                                Str("url", targetURL).
                                Str("cache_status", cacheStatus).
                                Int("check_attempt", i+1).
                                Msg("Cache status check")

                        // If cache is now HIT, we can proceed with second request
                        if cacheStatus == "HIT" || cacheStatus == "STALE" || cacheStatus == "REVALIDATED" </span><span class="cov0" title="0">{
                                cacheHit = true
                                break</span>
                        }
                }

                // If not the last check, wait before next attempt
                <span class="cov0" title="0">if i &lt; maxChecks-1 </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-time.After(time.Duration(checkDelay) * time.Millisecond):<span class="cov0" title="0"></span>
                                // Continue to next check
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Debug().Str("url", targetURL).Msg("Cache warming cancelled during check loop")
                                return nil</span>
                        }
                        // Increase delay for the next iteration
                        <span class="cov0" title="0">checkDelay += 1000</span>
                }
        }

        // Log whether cache became available
        <span class="cov0" title="0">if cacheHit </span><span class="cov0" title="0">{
                log.Debug().
                        Str("url", targetURL).
                        Msg("Cache is now available, proceeding with second request")
        }</span> else<span class="cov0" title="0"> {
                log.Warn().
                        Str("url", targetURL).
                        Int("max_checks", maxChecks).
                        Msg("Cache did not become available after maximum checks")
        }</span>

        // Perform second request to measure cached response time
        <span class="cov0" title="0">secondResult, err := c.makeSecondRequest(ctx, targetURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Warn().
                        Err(err).
                        Str("url", targetURL).
                        Msg("Second request failed, but first request succeeded")
                // Don't return error - first request was successful
        }</span> else<span class="cov0" title="0"> {
                res.SecondResponseTime = secondResult.ResponseTime
                res.SecondCacheStatus = secondResult.CacheStatus
                res.SecondContentLength = secondResult.ContentLength
                res.SecondHeaders = secondResult.Headers
                res.SecondPerformance = &amp;secondResult.Performance

                // Calculate improvement ratio for pattern analysis
                improvementRatio := float64(res.ResponseTime) / float64(res.SecondResponseTime)

                log.Debug().
                        Str("url", targetURL).
                        Str("first_cache_status", res.CacheStatus).
                        Str("second_cache_status", res.SecondCacheStatus).
                        Int64("first_response_time", res.ResponseTime).
                        Int64("second_response_time", res.SecondResponseTime).
                        Int("initial_delay_ms", delayMs).
                        Float64("improvement_ratio", improvementRatio).
                        Bool("cache_hit_before_second", cacheHit).
                        Msg("Cache warming analysis - pattern data")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupLinkExtraction configures Colly HTML handler for link extraction and categorization  
func setupLinkExtraction(collyClone *colly.Collector) <span class="cov8" title="1">{
        collyClone.OnHTML("html", func(e *colly.HTMLElement) </span><span class="cov0" title="0">{
                // Check if link extraction is enabled for this request
                findLinksVal := e.Request.Ctx.GetAny("find_links")
                if findLinksVal == nil </span><span class="cov0" title="0">{
                        log.Debug().
                                Str("url", e.Request.URL.String()).
                                Msg("find_links not set in context - defaulting to enabled")
                }</span> else<span class="cov0" title="0"> if findLinks, ok := findLinksVal.(bool); ok &amp;&amp; !findLinks </span><span class="cov0" title="0">{
                        log.Debug().
                                Str("url", e.Request.URL.String()).
                                Bool("find_links", findLinks).
                                Msg("Link extraction disabled for this request")
                        return
                }</span>

                <span class="cov0" title="0">result, ok := e.Request.Ctx.GetAny("result").(*CrawlResult)
                if !ok </span><span class="cov0" title="0">{
                        log.Debug().
                                Str("url", e.Request.URL.String()).
                                Msg("No result context - not collecting links")
                        return
                }</span>

                <span class="cov0" title="0">extractLinks := func(selection *goquery.Selection, category string) </span><span class="cov0" title="0">{
                        selection.Find("a[href]").Each(func(i int, s *goquery.Selection) </span><span class="cov0" title="0">{
                                href := strings.TrimSpace(s.AttrOr("href", ""))
                                if isElementHidden(s) || href == "" || href == "#" || strings.HasPrefix(href, "javascript:") || strings.HasPrefix(href, "mailto:") </span><span class="cov0" title="0">{
                                        return
                                }</span>

                                <span class="cov0" title="0">var u string
                                if strings.HasPrefix(href, "?") </span><span class="cov0" title="0">{
                                        base := e.Request.URL
                                        base.RawQuery = ""
                                        u = base.String() + href
                                }</span> else<span class="cov0" title="0"> {
                                        u = e.Request.AbsoluteURL(href)
                                }</span>

                                <span class="cov0" title="0">result.Links[category] = append(result.Links[category], u)</span>
                        })
                }

                // Extract from header and footer first
                <span class="cov0" title="0">extractLinks(e.DOM.Find("header"), "header")
                extractLinks(e.DOM.Find("footer"), "footer")

                // Remove header and footer to get body links
                e.DOM.Find("header").Remove()
                e.DOM.Find("footer").Remove()

                // Extract remaining links as "body"
                extractLinks(e.DOM, "body")

                log.Debug().
                        Str("url", e.Request.URL.String()).
                        Int("header_links", len(result.Links["header"])).
                        Int("footer_links", len(result.Links["footer"])).
                        Int("body_links", len(result.Links["body"])).
                        Msg("Categorized links from page")</span>
        })
}

// executeCollyRequest performs the HTTP request using Colly with context cancellation support
func executeCollyRequest(ctx context.Context, collyClone *colly.Collector, targetURL string, res *CrawlResult) error <span class="cov8" title="1">{
        // Set up context cancellation handling
        done := make(chan error, 1)

        // Visit the URL with Colly in a goroutine to support context cancellation
        go func() </span><span class="cov8" title="1">{
                visitErr := collyClone.Visit(targetURL)
                if visitErr != nil </span><span class="cov0" title="0">{
                        done &lt;- visitErr
                        return
                }</span>
                // Wait for async requests to complete
                <span class="cov8" title="1">collyClone.Wait()
                done &lt;- nil</span>
        }()

        // Wait for either completion or context cancellation
        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        res.Error = err.Error()
                        log.Error().
                                Err(err).
                                Str("url", targetURL).
                                Msg("Colly visit failed")
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                res.Error = ctx.Err().Error()
                log.Error().
                        Err(ctx.Err()).
                        Str("url", targetURL).
                        Msg("URL warming cancelled due to context")
                return ctx.Err()</span>
        }
}

// WarmURL performs a crawl of the specified URL and returns the result.
// It respects context cancellation, enforces timeout, and treats non-2xx statuses as errors.
func (c *Crawler) WarmURL(ctx context.Context, targetURL string, findLinks bool) (*CrawlResult, error) <span class="cov8" title="1">{
        // Validate the crawl request
        _, err := validateCrawlRequest(ctx, targetURL)
        if err != nil </span><span class="cov8" title="1">{
                // Create error result - caller (WarmURL) is responsible for CrawlResult construction
                res := &amp;CrawlResult{URL: targetURL, Timestamp: time.Now().Unix(), Error: err.Error()}
                return res, err
        }</span>

        <span class="cov8" title="1">start := time.Now()
        res := &amp;CrawlResult{
                URL:       targetURL,
                Timestamp: start.Unix(),
                Links:     make(map[string][]string),
        }

        log.Debug().
                Str("url", targetURL).
                Bool("find_links", findLinks).
                Msg("Starting URL warming with Colly")

        // Use Colly for everything - single request handles cache warming and link extraction
        collyClone := c.colly.Clone()

        // Set up link extraction
        setupLinkExtraction(collyClone)

        // Set up timing and result collection
        collyClone.OnRequest(func(r *colly.Request) </span><span class="cov8" title="1">{
                r.Ctx.Put("result", res)
                r.Ctx.Put("start_time", start)
                r.Ctx.Put("find_links", findLinks)
        }</span>)

        // Set up response and error handlers
        <span class="cov8" title="1">c.setupResponseHandlers(collyClone, res, start, targetURL)

        // Execute the HTTP request
        if err := executeCollyRequest(ctx, collyClone, targetURL, res); err != nil </span><span class="cov8" title="1">{
                return res, err
        }</span>

        // Log results and return error if needed
        <span class="cov8" title="1">if res.Error != "" </span><span class="cov8" title="1">{
                if res.StatusCode &lt; 200 || res.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                        log.Warn().
                                Int("status", res.StatusCode).
                                Str("url", targetURL).
                                Str("error", res.Error).
                                Dur("duration_ms", time.Duration(res.ResponseTime)*time.Millisecond).
                                Msg("URL warming returned non-success status")
                }</span> else<span class="cov0" title="0"> {
                        log.Error().
                                Str("url", targetURL).
                                Str("error", res.Error).
                                Dur("duration_ms", time.Duration(res.ResponseTime)*time.Millisecond).
                                Msg("URL warming failed")
                }</span>
                <span class="cov8" title="1">return res, fmt.Errorf("%s", res.Error)</span>
        }

        // Perform cache validation and warming
        <span class="cov8" title="1">if err := c.performCacheValidation(ctx, targetURL, res); err != nil </span><span class="cov0" title="0">{
                return res, err
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

// shouldMakeSecondRequest determines if we should make a second request for cache warming
func shouldMakeSecondRequest(cacheStatus string) bool <span class="cov8" title="1">{
        // Make second request for cache misses and bypasses
        // Don't make second request for hits, expired, stale, etc.
        switch strings.ToUpper(cacheStatus) </span>{
        case "MISS", "BYPASS", "EXPIRED":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// makeSecondRequest performs a second request to verify cache warming
// Reuses the main WarmURL logic but disables link extraction
func (c *Crawler) makeSecondRequest(ctx context.Context, targetURL string) (*CrawlResult, error) <span class="cov0" title="0">{
        // Reuse the main WarmURL method but disable link extraction
        return c.WarmURL(ctx, targetURL, false)
}</span>

func (c *Crawler) CheckCacheStatus(ctx context.Context, targetURL string) (string, error) <span class="cov0" title="0">{
        req, err := http.NewRequestWithContext(ctx, "HEAD", targetURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">req.Header.Set("User-Agent", c.config.UserAgent)
        req.Header.Set("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8")
        req.Header.Set("Accept-Language", "en-US,en;q=0.9")
        req.Header.Set("Accept-Encoding", "gzip, deflate, br")

        client := &amp;http.Client{
                Timeout: c.config.DefaultTimeout,
        }

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        return resp.Header.Get("CF-Cache-Status"), nil</span>
}

// CreateHTTPClient returns a configured HTTP client
func (c *Crawler) CreateHTTPClient(timeout time.Duration) *http.Client <span class="cov0" title="0">{
        if timeout == 0 </span><span class="cov0" title="0">{
                timeout = c.config.DefaultTimeout
        }</span>

        <span class="cov0" title="0">return &amp;http.Client{
                Timeout: timeout,
                Transport: &amp;http.Transport{
                        MaxIdleConnsPerHost: 25,
                        MaxConnsPerHost:     50,
                        IdleConnTimeout:     120 * time.Second,
                        TLSHandshakeTimeout: 10 * time.Second,
                        DisableCompression:  true,
                        ForceAttemptHTTP2:   true,
                },
        }</span>
}

// Config returns the Crawler's configuration.
func (c *Crawler) Config() *Config <span class="cov0" title="0">{
        return c.config
}</span>

// isElementHidden checks if an element is hidden based on common inline styles,
// accessibility attributes, and conventional CSS classes.
// This is a best-effort check based on raw HTML attributes, as it does not
// evaluate external or internal CSS stylesheets.
func isElementHidden(s *goquery.Selection) bool <span class="cov0" title="0">{
        // Define the list of common hiding classes
        hidingClasses := []string{
                "hide",
                "hidden",
                "display-none",
                "d-none",
                "invisible",
                "is-hidden",
                "sr-only",
                "visually-hidden",
        }

        // Loop through the current element and all its parents up to the body
        for n := s; n.Length() &gt; 0 &amp;&amp; !n.Is("body"); n = n.Parent() </span><span class="cov0" title="0">{
                // 1. Check for explicit data attributes
                if _, exists := n.Attr("data-hidden"); exists </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">if val, exists := n.Attr("data-visible"); exists &amp;&amp; val == "false" </span><span class="cov0" title="0">{
                        return true
                }</span>

                // 2. Check for aria-hidden="true" attribute
                <span class="cov0" title="0">if ariaHidden, exists := n.Attr("aria-hidden"); exists &amp;&amp; ariaHidden == "true" </span><span class="cov0" title="0">{
                        return true
                }</span>

                // 3. Check for inline style attributes
                <span class="cov0" title="0">if style, exists := n.Attr("style"); exists </span><span class="cov0" title="0">{
                        if strings.Contains(style, "display: none") || strings.Contains(style, "visibility: hidden") </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }

                // 4. Check for common hiding classes
                <span class="cov0" title="0">for _, class := range hidingClasses </span><span class="cov0" title="0">{
                        if n.HasClass(class) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        // No hiding attributes or classes were found
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package crawler

import (
        "bufio"
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/rs/zerolog/log"
)

// RobotsRules contains parsed robots.txt rules for a domain
type RobotsRules struct {
        // CrawlDelay in seconds (0 means no delay specified)
        CrawlDelay int
        // Sitemaps found in robots.txt
        Sitemaps []string
        // DisallowPatterns are URL patterns that should not be crawled
        DisallowPatterns []string
        // AllowPatterns override DisallowPatterns (more specific)
        AllowPatterns []string
}

// ParseRobotsTxt fetches and parses robots.txt for a domain
//
// The parser follows these rules in order of precedence:
// 1. If there are specific rules for "BlueBandedBee", use those
// 2. If there are rules for similar legitimate web crawlers (AhrefsBot, MJ12bot, etc.), use those
// 3. Otherwise, fall back to wildcard (*) rules
//
// This approach ensures we respect site owners' wishes for legitimate web crawlers
// while avoiding being blocked by overly broad AI/LLM crawler restrictions.
func ParseRobotsTxt(ctx context.Context, domain string, userAgent string) (*RobotsRules, error) <span class="cov8" title="1">{
        // Support both domain-only and full URL formats
        var robotsURL string
        if strings.HasPrefix(domain, "http://") || strings.HasPrefix(domain, "https://") </span><span class="cov0" title="0">{
                // Full URL provided - use as base
                robotsURL = strings.TrimSuffix(domain, "/") + "/robots.txt"
        }</span> else<span class="cov8" title="1"> {
                // Domain only - default to https
                robotsURL = fmt.Sprintf("https://%s/robots.txt", domain)
        }</span>

        <span class="cov8" title="1">log.Debug().
                Str("domain", domain).
                Str("robots_url", robotsURL).
                Msg("Fetching robots.txt")

        // Create a client with shorter timeout
        client := &amp;http.Client{
                Timeout: 10 * time.Second,
                CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                        if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                                return fmt.Errorf("too many redirects")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        }

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, "GET", robotsURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        // Use the provided user agent
        <span class="cov8" title="1">req.Header.Set("User-Agent", userAgent)

        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to fetch robots.txt: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                // No robots.txt means no restrictions
                if resp.StatusCode == http.StatusNotFound </span><span class="cov8" title="1">{
                        log.Debug().Msg("No robots.txt found, no restrictions apply")
                        return &amp;RobotsRules{}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("robots.txt returned status %d", resp.StatusCode)</span>
        }

        // Limit robots.txt size to 1MB to prevent memory exhaustion
        <span class="cov0" title="0">limitedReader := io.LimitReader(resp.Body, 1*1024*1024) // 1MB limit
        return parseRobotsTxtContent(limitedReader, userAgent)</span>
}

// parseRobotsTxtContent parses the robots.txt content
func parseRobotsTxtContent(r io.Reader, userAgent string) (*RobotsRules, error) <span class="cov8" title="1">{
        rules := &amp;RobotsRules{
                Sitemaps:         []string{},
                DisallowPatterns: []string{},
                AllowPatterns:    []string{},
        }

        // Read entire content to check if we hit the limit
        content, err := io.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read robots.txt: %w", err)
        }</span>

        // Check if we likely hit the 1MB limit (exactly 1MB read)
        <span class="cov8" title="1">if len(content) == 1*1024*1024 </span><span class="cov0" title="0">{
                log.Warn().
                        Int("size_bytes", len(content)).
                        Msg("Robots.txt file truncated at 1MB limit")
        }</span>

        <span class="cov8" title="1">scanner := bufio.NewScanner(bytes.NewReader(content))

        // Track if we're in a section that applies to us
        var inOurSection bool
        var inWildcardSection bool
        var foundSpecificSection bool // Track if we've found a specific section for our bot

        // Extract bot name from user agent (e.g., "BlueBandedBee/1.0" -&gt; "bluebandedbee")
        botName := strings.ToLower(strings.Split(userAgent, "/")[0])

        // List of similar crawler/SEO bots whose rules we should also respect
        // These are legitimate web crawlers that BlueBandedBee is similar to
        similarBots := []string{
                "ahrefsbot",       // SEO crawler
                "ahrefssiteaudit", // SEO site audit
                "mj12bot",         // Majestic SEO crawler
                "semrushbot",      // SEO crawler
                "dotbot",          // Moz crawler
                "rogerbot",        // Moz crawler (legacy)
                "screaming frog",  // SEO spider
                "sitebot",         // Generic site crawler
                "webcrawler",      // Generic crawler
        }

        // Temporary storage for wildcard rules
        wildcardRules := &amp;RobotsRules{
                Sitemaps:         []string{},
                DisallowPatterns: []string{},
                AllowPatterns:    []string{},
        }

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Convert to lowercase for case-insensitive matching
                <span class="cov8" title="1">lowerLine := strings.ToLower(line)

                // Parse User-agent directive
                if strings.HasPrefix(lowerLine, "user-agent:") </span><span class="cov8" title="1">{
                        agent := strings.TrimSpace(line[11:])
                        agentLower := strings.ToLower(agent)

                        // Check if this section applies to us
                        inOurSection = false
                        inWildcardSection = false

                        if agent == "*" </span><span class="cov8" title="1">{
                                inWildcardSection = true
                        }</span> else<span class="cov8" title="1"> if agentLower == botName || strings.Contains(agentLower, botName) </span><span class="cov8" title="1">{
                                inOurSection = true
                                foundSpecificSection = true
                                // Clear any wildcard rules we've collected
                                rules = &amp;RobotsRules{
                                        Sitemaps:         []string{},
                                        DisallowPatterns: []string{},
                                        AllowPatterns:    []string{},
                                }
                                log.Debug().
                                        Str("user_agent_section", agent).
                                        Msg("Found rules section for our bot")
                        }</span> else<span class="cov8" title="1"> if !foundSpecificSection </span><span class="cov8" title="1">{
                                // Check if this is a similar bot whose rules we should respect
                                for _, similarBot := range similarBots </span><span class="cov8" title="1">{
                                        if strings.Contains(agentLower, similarBot) </span><span class="cov8" title="1">{
                                                inOurSection = true
                                                foundSpecificSection = true
                                                // Clear any wildcard rules we've collected
                                                rules = &amp;RobotsRules{
                                                        Sitemaps:         []string{},
                                                        DisallowPatterns: []string{},
                                                        AllowPatterns:    []string{},
                                                }
                                                log.Debug().
                                                        Str("user_agent_section", agent).
                                                        Str("matched_similar_bot", similarBot).
                                                        Msg("Found rules section for similar bot - adopting these rules")
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">continue</span>
                }

                // Parse Sitemap directive (applies globally)
                <span class="cov8" title="1">if strings.HasPrefix(lowerLine, "sitemap:") </span><span class="cov8" title="1">{
                        sitemapURL := strings.TrimSpace(line[8:])
                        if sitemapURL != "" </span><span class="cov8" title="1">{
                                // Always add sitemaps to the main rules
                                rules.Sitemaps = append(rules.Sitemaps, sitemapURL)
                                if inWildcardSection &amp;&amp; !foundSpecificSection </span><span class="cov8" title="1">{
                                        wildcardRules.Sitemaps = append(wildcardRules.Sitemaps, sitemapURL)
                                }</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                // Only process other directives if we're in a relevant section
                <span class="cov8" title="1">if !inOurSection &amp;&amp; !inWildcardSection </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Determine which rule set to update
                <span class="cov8" title="1">currentRules := rules
                if inWildcardSection &amp;&amp; !foundSpecificSection </span><span class="cov8" title="1">{
                        currentRules = wildcardRules
                }</span>

                // Parse Crawl-delay directive
                <span class="cov8" title="1">if strings.HasPrefix(lowerLine, "crawl-delay:") </span><span class="cov8" title="1">{
                        delayStr := strings.TrimSpace(line[12:])
                        if delay, err := strconv.Atoi(delayStr); err == nil &amp;&amp; delay &gt; 0 </span><span class="cov8" title="1">{
                                currentRules.CrawlDelay = delay
                                log.Debug().
                                        Int("crawl_delay", delay).
                                        Bool("from_specific_section", inOurSection).
                                        Msg("Found Crawl-delay directive")
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Parse Disallow directive
                <span class="cov8" title="1">if strings.HasPrefix(lowerLine, "disallow:") </span><span class="cov8" title="1">{
                        path := strings.TrimSpace(line[9:])
                        if path != "" &amp;&amp; path != "/" </span><span class="cov8" title="1">{ // Ignore "Disallow: /" which blocks everything
                                currentRules.DisallowPatterns = append(currentRules.DisallowPatterns, path)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                // Parse Allow directive (overrides Disallow)
                <span class="cov8" title="1">if strings.HasPrefix(lowerLine, "allow:") </span><span class="cov8" title="1">{
                        path := strings.TrimSpace(line[6:])
                        if path != "" </span><span class="cov8" title="1">{
                                currentRules.AllowPatterns = append(currentRules.AllowPatterns, path)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
        }

        // If we didn't find a specific section, use wildcard rules
        <span class="cov8" title="1">if !foundSpecificSection </span><span class="cov8" title="1">{
                rules = wildcardRules
        }</span>

        <span class="cov8" title="1">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading robots.txt: %w", err)
        }</span>

        <span class="cov8" title="1">log.Debug().
                Int("crawl_delay", rules.CrawlDelay).
                Int("sitemaps", len(rules.Sitemaps)).
                Int("disallow_patterns", len(rules.DisallowPatterns)).
                Int("allow_patterns", len(rules.AllowPatterns)).
                Msg("Parsed robots.txt rules")

        return rules, nil</span>
}

// IsPathAllowed checks if a path is allowed by robots.txt rules
func IsPathAllowed(rules *RobotsRules, path string) bool <span class="cov8" title="1">{
        // No rules means everything is allowed
        if rules == nil || len(rules.DisallowPatterns) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check Allow patterns first (they override Disallow)
        <span class="cov8" title="1">for _, pattern := range rules.AllowPatterns </span><span class="cov8" title="1">{
                if matchesRobotsPattern(path, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Check Disallow patterns
        <span class="cov8" title="1">for _, pattern := range rules.DisallowPatterns </span><span class="cov8" title="1">{
                if matchesRobotsPattern(path, pattern) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // If no patterns match, it's allowed
        <span class="cov8" title="1">return true</span>
}

// matchesRobotsPattern checks if a path matches a robots.txt pattern
// Supports * wildcard and $ end-of-URL marker
func matchesRobotsPattern(path, pattern string) bool <span class="cov8" title="1">{
        // Handle $ end marker
        if strings.HasSuffix(pattern, "$") </span><span class="cov8" title="1">{
                pattern = strings.TrimSuffix(pattern, "$")
                // For exact end matching, the path must exactly match the pattern
                return path == pattern
        }</span>

        // Convert * wildcards to simple matching
        <span class="cov8" title="1">if strings.Contains(pattern, "*") </span><span class="cov8" title="1">{
                // For now, just support simple cases
                parts := strings.Split(pattern, "*")
                if len(parts) == 2 &amp;&amp; parts[1] == "" </span><span class="cov8" title="1">{
                        // Pattern like "/path/*" - just check prefix
                        return strings.HasPrefix(path, parts[0])
                }</span>
                // More complex wildcard patterns - simplified implementation
                // Just check if path contains all parts in order
                <span class="cov0" title="0">currentPos := 0
                for _, part := range parts </span><span class="cov0" title="0">{
                        if part == "" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">idx := strings.Index(path[currentPos:], part)
                        if idx == -1 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">currentPos += idx + len(part)</span>
                }
                <span class="cov0" title="0">return true</span>
        }

        // Simple prefix matching
        <span class="cov8" title="1">return strings.HasPrefix(path, pattern)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package crawler

import (
        "context"
        "encoding/xml"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/util"
        "github.com/rs/zerolog/log"
)

// SitemapDiscoveryResult contains both sitemaps and robots.txt rules
type SitemapDiscoveryResult struct {
        Sitemaps    []string
        RobotsRules *RobotsRules
}

// DiscoverSitemapsAndRobots attempts to find sitemaps and parse robots.txt rules for a domain
func (c *Crawler) DiscoverSitemapsAndRobots(ctx context.Context, domain string) (*SitemapDiscoveryResult, error) <span class="cov8" title="1">{
        // Normalise the domain first to handle different input formats
        normalisedDomain := util.NormaliseDomain(domain)
        log.Debug().
                Str("original_domain", domain).
                Str("normalised_domain", normalisedDomain).
                Msg("Starting sitemap and robots.txt discovery")

        result := &amp;SitemapDiscoveryResult{
                Sitemaps:    []string{},
                RobotsRules: &amp;RobotsRules{}, // Default empty rules
        }

        // Parse robots.txt first - this gets us both sitemaps and crawl rules
        robotRules, err := ParseRobotsTxt(ctx, normalisedDomain, c.config.UserAgent)
        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail - no robots.txt means no restrictions
                log.Debug().
                        Err(err).
                        Str("domain", normalisedDomain).
                        Msg("Failed to parse robots.txt, proceeding with no restrictions")
        }</span> else<span class="cov8" title="1"> {
                result.RobotsRules = robotRules
                result.Sitemaps = robotRules.Sitemaps
        }</span>

        // Log if sitemaps were found in robots.txt
        <span class="cov8" title="1">if len(result.Sitemaps) &gt; 0 </span><span class="cov0" title="0">{
                log.Debug().
                        Strs("sitemaps", result.Sitemaps).
                        Msg("Sitemaps found in robots.txt")
        }</span> else<span class="cov8" title="1"> {
                log.Debug().Msg("No sitemaps found in robots.txt")
        }</span>

        // If no sitemaps found in robots.txt, check common locations
        <span class="cov8" title="1">if len(result.Sitemaps) == 0 </span><span class="cov8" title="1">{
                commonPaths := []string{
                        "https://" + normalisedDomain + "/sitemap.xml",
                        "https://" + normalisedDomain + "/sitemap_index.xml",
                }

                // Create a client for checking common locations
                client := &amp;http.Client{
                        Timeout: 5 * time.Second,
                        CheckRedirect: func(req *http.Request, via []*http.Request) error </span><span class="cov0" title="0">{
                                if len(via) &gt;= 10 </span><span class="cov0" title="0">{
                                        return fmt.Errorf("too many redirects")
                                }</span>
                                <span class="cov0" title="0">return nil</span>
                        },
                }

                // Check common locations concurrently with a timeout
                <span class="cov8" title="1">for _, sitemapURL := range commonPaths </span><span class="cov8" title="1">{
                        log.Debug().Str("checking_sitemap_url", sitemapURL).Msg("Checking common sitemap location")
                        req, err := http.NewRequestWithContext(ctx, "HEAD", sitemapURL, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debug().Err(err).Str("url", sitemapURL).Msg("Error creating request for sitemap")
                                continue</span>
                        }
                        <span class="cov8" title="1">req.Header.Set("User-Agent", c.config.UserAgent)

                        resp, err := client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Debug().Err(err).Str("url", sitemapURL).Msg("Error fetching sitemap")
                                continue</span>
                        }

                        <span class="cov8" title="1">resp.Body.Close()
                        log.Debug().Str("url", sitemapURL).Int("status", resp.StatusCode).Msg("Sitemap check response")
                        if resp.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                                result.Sitemaps = append(result.Sitemaps, sitemapURL)
                                log.Debug().Str("url", sitemapURL).Msg("Found sitemap at common location")
                        }</span>
                }
        }

        // Deduplicate sitemaps
        <span class="cov8" title="1">seen := make(map[string]bool)
        var uniqueSitemaps []string
        for _, sitemap := range result.Sitemaps </span><span class="cov0" title="0">{
                if !seen[sitemap] </span><span class="cov0" title="0">{
                        seen[sitemap] = true
                        uniqueSitemaps = append(uniqueSitemaps, sitemap)
                }</span>
        }
        <span class="cov8" title="1">result.Sitemaps = uniqueSitemaps

        // Log final result
        if len(result.Sitemaps) &gt; 0 </span><span class="cov0" title="0">{
                log.Debug().
                        Strs("sitemaps", result.Sitemaps).
                        Int("count", len(result.Sitemaps)).
                        Int("crawl_delay", result.RobotsRules.CrawlDelay).
                        Int("disallow_patterns", len(result.RobotsRules.DisallowPatterns)).
                        Msg("Found sitemaps and robots rules for domain")
        }</span> else<span class="cov8" title="1"> {
                log.Debug().
                        Str("domain", domain).
                        Int("crawl_delay", result.RobotsRules.CrawlDelay).
                        Int("disallow_patterns", len(result.RobotsRules.DisallowPatterns)).
                        Msg("No sitemaps found but got robots rules for domain")
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// DiscoverSitemaps is a backward-compatible wrapper that only returns sitemaps
func (c *Crawler) DiscoverSitemaps(ctx context.Context, domain string) ([]string, error) <span class="cov0" title="0">{
        result, err := c.DiscoverSitemapsAndRobots(ctx, domain)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result.Sitemaps, nil</span>
}

// Create proper sitemap structs
type SitemapIndex struct {
        XMLName  xml.Name  `xml:"sitemapindex"`
        Sitemaps []Sitemap `xml:"sitemap"`
}

type Sitemap struct {
        XMLName xml.Name `xml:"sitemap"`
        Loc     string   `xml:"loc"`
}

type URLSet struct {
        XMLName xml.Name `xml:"urlset"`
        URLs    []URL    `xml:"url"`
}

type URL struct {
        XMLName xml.Name `xml:"url"`
        Loc     string   `xml:"loc"`
}

// ParseSitemap extracts URLs from a sitemap
func (c *Crawler) ParseSitemap(ctx context.Context, sitemapURL string) ([]string, error) <span class="cov8" title="1">{
        var urls []string

        req, err := http.NewRequestWithContext(ctx, "GET", sitemapURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">client := &amp;http.Client{Timeout: 30 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to fetch sitemap: %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">content := string(body)

        // Log the content for debugging
        log.Debug().
                Str("url", sitemapURL).
                Int("content_length", len(content)).
                Str("content_sample", content[:min(100, len(content))]).
                Msg("Sitemap content received")

        // Check if it's a sitemap index
        if strings.Contains(content, "&lt;sitemapindex") </span><span class="cov8" title="1">{
                // Extract sitemap URLs
                sitemapURLs := extractURLsFromXML(content, "&lt;sitemap&gt;", "&lt;/sitemap&gt;", "&lt;loc&gt;", "&lt;/loc&gt;")

                // Process each sitemap in the index
                for _, childSitemapURL := range sitemapURLs </span><span class="cov8" title="1">{
                        // Validate and normalise the child sitemap URL
                        childSitemapURL = util.NormaliseURL(childSitemapURL)
                        if childSitemapURL == "" </span><span class="cov0" title="0">{
                                log.Warn().Str("url", childSitemapURL).Msg("Invalid child sitemap URL, skipping")
                                continue</span>
                        }

                        <span class="cov8" title="1">childURLs, err := c.ParseSitemap(ctx, childSitemapURL)
                        if err != nil </span><span class="cov8" title="1">{
                                log.Warn().Err(err).Str("url", childSitemapURL).Msg("Failed to parse child sitemap")
                                continue</span>
                        }
                        <span class="cov0" title="0">urls = append(urls, childURLs...)</span>
                }
        } else<span class="cov8" title="1"> {
                // It's a regular sitemap
                extractedURLs := extractURLsFromXML(content, "&lt;url&gt;", "&lt;/url&gt;", "&lt;loc&gt;", "&lt;/loc&gt;")

                // Validate and normalise all extracted URLs
                var validURLs []string
                for _, extractedURL := range extractedURLs </span><span class="cov8" title="1">{
                        validURL := util.NormaliseURL(extractedURL)
                        if validURL != "" </span><span class="cov8" title="1">{
                                validURLs = append(validURLs, validURL)
                        }</span> else<span class="cov0" title="0"> {
                                log.Debug().Str("invalid_url", extractedURL).Msg("Skipping invalid URL from sitemap")
                        }</span>
                }

                <span class="cov8" title="1">log.Debug().
                        Str("sitemap_url", sitemapURL).
                        Int("url_count", len(validURLs)).
                        Msg("Extracted valid URLs from regular sitemap")
                urls = append(urls, validURLs...)</span>
        }

        <span class="cov8" title="1">log.Debug().
                Str("sitemap_url", sitemapURL).
                Int("total_url_count", len(urls)).
                Msg("Finished parsing sitemap")

        return urls, nil</span>
}

// Helper function to extract URLs from XML content
func extractURLsFromXML(content, startTag, endTag, locStartTag, locEndTag string) []string <span class="cov8" title="1">{
        var urls []string

        // Find all instances of the outer tag
        startIdx := 0
        for </span><span class="cov8" title="1">{
                startTagIdx := strings.Index(content[startIdx:], startTag)
                if startTagIdx == -1 </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">startTagIdx += startIdx
                endTagIdx := strings.Index(content[startTagIdx:], endTag)
                if endTagIdx == -1 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">endTagIdx += startTagIdx

                // Extract the section between tags
                section := content[startTagIdx : endTagIdx+len(endTag)]

                // Find the URL in the section
                locStartIdx := strings.Index(section, locStartTag)
                if locStartIdx != -1 </span><span class="cov8" title="1">{
                        locEndIdx := strings.Index(section[locStartIdx:], locEndTag)
                        if locEndIdx != -1 </span><span class="cov8" title="1">{
                                locEndIdx += locStartIdx

                                // Extract the URL
                                url := section[locStartIdx+len(locStartTag) : locEndIdx]
                                url = strings.TrimSpace(url)

                                if url != "" </span><span class="cov8" title="1">{
                                        urls = append(urls, url)
                                }</span>
                        }
                }

                <span class="cov8" title="1">startIdx = endTagIdx + len(endTag)</span>
        }

        <span class="cov8" title="1">return urls</span>
}

// min returns the smaller of a and b
func min(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

// FilterURLs filters URLs based on include/exclude patterns
func (c *Crawler) FilterURLs(urls []string, includePaths, excludePaths []string) []string <span class="cov8" title="1">{
        if len(includePaths) == 0 &amp;&amp; len(excludePaths) == 0 </span><span class="cov8" title="1">{
                return urls
        }</span>

        <span class="cov8" title="1">var filtered []string

        for _, url := range urls </span><span class="cov8" title="1">{
                // If include patterns exist, URL must match at least one
                includeMatch := len(includePaths) == 0
                for _, pattern := range includePaths </span><span class="cov8" title="1">{
                        if strings.Contains(url, pattern) </span><span class="cov8" title="1">{
                                includeMatch = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !includeMatch </span><span class="cov8" title="1">{
                        continue</span>
                }

                // If URL matches any exclude pattern, skip it
                <span class="cov8" title="1">excludeMatch := false
                for _, pattern := range excludePaths </span><span class="cov8" title="1">{
                        if strings.Contains(url, pattern) </span><span class="cov8" title="1">{
                                excludeMatch = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !excludeMatch </span><span class="cov8" title="1">{
                        filtered = append(filtered, url)
                }</span>
        }

        <span class="cov8" title="1">return filtered</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package db

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/rs/zerolog/log"
)

// JobStats represents job statistics for the dashboard
type JobStats struct {
        TotalJobs         int     `json:"total_jobs"`
        RunningJobs       int     `json:"running_jobs"`
        CompletedJobs     int     `json:"completed_jobs"`
        FailedJobs        int     `json:"failed_jobs"`
        TotalTasks        int     `json:"total_tasks"`
        AvgCompletionTime float64 `json:"avg_completion_time"`
}

// ActivityPoint represents a data point for activity charts
type ActivityPoint struct {
        Timestamp  string `json:"timestamp"`
        JobsCount  int    `json:"jobs_count"`
        TasksCount int    `json:"tasks_count"`
}

// GetJobStats retrieves job statistics for the dashboard
func (db *DB) GetJobStats(organisationID string, startDate, endDate *time.Time) (*JobStats, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        COUNT(*) as total_jobs,
                        SUM(CASE WHEN status = 'running' THEN 1 ELSE 0 END) as running_jobs,
                        SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed_jobs,
                        SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failed_jobs,
                        SUM(COALESCE(total_tasks, 0)) as total_tasks,
                        AVG(
                                CASE WHEN status = 'completed' AND started_at IS NOT NULL AND completed_at IS NOT NULL 
                                THEN EXTRACT(EPOCH FROM (completed_at - started_at))
                                ELSE NULL END
                        ) as avg_completion_time
                FROM jobs 
                WHERE organisation_id = $1`

        args := []interface{}{organisationID}
        argCount := 1

        // Add date filtering if provided
        if startDate != nil </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" AND created_at &gt;= $%d", argCount)
                args = append(args, *startDate)
        }</span>
        <span class="cov0" title="0">if endDate != nil </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" AND created_at &lt;= $%d", argCount)
                args = append(args, *endDate)
        }</span>

        <span class="cov0" title="0">var stats JobStats
        var avgCompletionTime sql.NullFloat64

        err := db.client.QueryRow(query, args...).Scan(
                &amp;stats.TotalJobs,
                &amp;stats.RunningJobs,
                &amp;stats.CompletedJobs,
                &amp;stats.FailedJobs,
                &amp;stats.TotalTasks,
                &amp;avgCompletionTime,
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("organisation_id", organisationID).Msg("Failed to get job stats")
                return nil, err
        }</span>

        <span class="cov0" title="0">if avgCompletionTime.Valid </span><span class="cov0" title="0">{
                stats.AvgCompletionTime = avgCompletionTime.Float64
        }</span>

        <span class="cov0" title="0">return &amp;stats, nil</span>
}

// GetJobActivity retrieves job activity data for charts
func (db *DB) GetJobActivity(organisationID string, startDate, endDate *time.Time) ([]ActivityPoint, error) <span class="cov0" title="0">{
        // Determine the appropriate time grouping based on date range
        var timeGroup string
        var intervalStr string

        if startDate != nil &amp;&amp; endDate != nil </span><span class="cov0" title="0">{
                duration := endDate.Sub(*startDate)
                if duration &lt;= 24*time.Hour </span><span class="cov0" title="0">{
                        // Less than 1 day: group by hour
                        timeGroup = "DATE_TRUNC('hour', created_at)"
                        intervalStr = "1 hour"
                }</span> else<span class="cov0" title="0"> if duration &lt;= 7*24*time.Hour </span><span class="cov0" title="0">{
                        // Less than 1 week: group by 6 hours
                        timeGroup = "DATE_TRUNC('hour', created_at) + INTERVAL '6 hours' * FLOOR(EXTRACT(HOUR FROM created_at) / 6)"
                        intervalStr = "6 hours"
                }</span> else<span class="cov0" title="0"> if duration &lt;= 30*24*time.Hour </span><span class="cov0" title="0">{
                        // Less than 1 month: group by day
                        timeGroup = "DATE_TRUNC('day', created_at)"
                        intervalStr = "1 day"
                }</span> else<span class="cov0" title="0"> {
                        // More than 1 month: group by week
                        timeGroup = "DATE_TRUNC('week', created_at)"
                        intervalStr = "1 week"
                }</span>
        } else<span class="cov0" title="0"> {
                // Default to daily grouping
                timeGroup = "DATE_TRUNC('day', created_at)"
                intervalStr = "1 day"
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                WITH time_series AS (
                        SELECT generate_series(
                                COALESCE($2, DATE_TRUNC('day', NOW() - INTERVAL '7 days')),
                                COALESCE($3, DATE_TRUNC('day', NOW())),
                                INTERVAL '%s'
                        ) as time_bucket
                ),
                job_activity AS (
                        SELECT 
                                %s as time_bucket,
                                COUNT(*) as jobs_count,
                                SUM(COALESCE(total_tasks, 0)) as tasks_count
                        FROM jobs 
                        WHERE organisation_id = $1`, intervalStr, timeGroup)

        args := []interface{}{organisationID, startDate, endDate}
        argCount := 3

        // Add date filtering if provided
        if startDate != nil </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" AND created_at &gt;= $%d", argCount)
                args = append(args, *startDate)
        }</span>
        <span class="cov0" title="0">if endDate != nil </span><span class="cov0" title="0">{
                argCount++
                query += fmt.Sprintf(" AND created_at &lt;= $%d", argCount)
                args = append(args, *endDate)
        }</span>

        <span class="cov0" title="0">query += `
                        GROUP BY ` + timeGroup + `
                )
                SELECT 
                        ts.time_bucket,
                        COALESCE(ja.jobs_count, 0) as jobs_count,
                        COALESCE(ja.tasks_count, 0) as tasks_count
                FROM time_series ts
                LEFT JOIN job_activity ja ON ts.time_bucket = ja.time_bucket
                ORDER BY ts.time_bucket`

        rows, err := db.client.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("organisation_id", organisationID).Msg("Failed to get job activity")
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var activity []ActivityPoint
        for rows.Next() </span><span class="cov0" title="0">{
                var point ActivityPoint
                var timestamp time.Time

                err := rows.Scan(&amp;timestamp, &amp;point.JobsCount, &amp;point.TasksCount)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to scan activity row")
                        continue</span>
                }

                <span class="cov0" title="0">point.Timestamp = timestamp.Format(time.RFC3339)
                activity = append(activity, point)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Error iterating activity rows")
                return nil, err
        }</span>

        <span class="cov0" title="0">return activity, nil</span>
}

// JobListItem represents a job in the list view
type JobListItem struct {
        ID                    string   `json:"id"`
        Status                string   `json:"status"`
        Progress              float64  `json:"progress"`
        TotalTasks            int      `json:"total_tasks"`
        CompletedTasks        int      `json:"completed_tasks"`
        FailedTasks           int      `json:"failed_tasks"`
        SitemapTasks          int      `json:"sitemap_tasks"`
        FoundTasks            int      `json:"found_tasks"`
        CreatedAt             string   `json:"created_at"`
        StartedAt             *string  `json:"started_at,omitempty"`
        CompletedAt           *string  `json:"completed_at,omitempty"`
        Domain                *string  `json:"domains,omitempty"` // For compatibility with frontend
        DurationSeconds       *int     `json:"duration_seconds,omitempty"`
        AvgTimePerTaskSeconds *float64 `json:"avg_time_per_task_seconds,omitempty"`
}

// Domain represents the domain information for jobs
type Domain struct {
        Name string `json:"name"`
}

// JobWithDomain represents a job with domain information
type JobWithDomain struct {
        JobListItem
        Domains *Domain `json:"domains"`
}

// ListJobs retrieves a paginated list of jobs for an organisation
func (db *DB) ListJobs(organisationID string, limit, offset int, status, dateRange string) ([]JobWithDomain, int, error) <span class="cov0" title="0">{
        // Build the base query
        baseQuery := `
                FROM jobs j
                LEFT JOIN domains d ON j.domain_id = d.id
                WHERE j.organisation_id = $1`

        args := []interface{}{organisationID}
        argCount := 1

        // Add status filter if provided
        if status != "" </span><span class="cov0" title="0">{
                argCount++
                baseQuery += fmt.Sprintf(" AND j.status = $%d", argCount)
                args = append(args, status)
        }</span>

        // Add date range filter if provided
        <span class="cov0" title="0">if dateRange != "" </span><span class="cov0" title="0">{
                startDate, endDate := calculateDateRangeForList(dateRange)
                if startDate != nil </span><span class="cov0" title="0">{
                        argCount++
                        baseQuery += fmt.Sprintf(" AND j.created_at &gt;= $%d", argCount)
                        args = append(args, *startDate)
                }</span>
                <span class="cov0" title="0">if endDate != nil </span><span class="cov0" title="0">{
                        argCount++
                        baseQuery += fmt.Sprintf(" AND j.created_at &lt;= $%d", argCount)
                        args = append(args, *endDate)
                }</span>
        }

        // Get total count
        <span class="cov0" title="0">countQuery := "SELECT COUNT(*) " + baseQuery
        var total int
        err := db.client.QueryRow(countQuery, args...).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to count jobs: %w", err)
        }</span>

        // Get jobs with pagination
        <span class="cov0" title="0">selectQuery := `
                SELECT 
                        j.id, j.status, j.progress, j.total_tasks, j.completed_tasks, 
                        j.failed_tasks, j.sitemap_tasks, j.found_tasks, j.created_at,
                        j.started_at, j.completed_at, d.name as domain_name,
                        j.duration_seconds, j.avg_time_per_task_seconds
                ` + baseQuery + `
                ORDER BY j.created_at DESC
                LIMIT $` + fmt.Sprintf("%d", argCount+1) + ` OFFSET $` + fmt.Sprintf("%d", argCount+2)

        args = append(args, limit, offset)

        rows, err := db.client.Query(selectQuery, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to query jobs: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var jobs []JobWithDomain
        for rows.Next() </span><span class="cov0" title="0">{
                var job JobWithDomain
                var startedAt, completedAt sql.NullString
                var domainName sql.NullString

                err := rows.Scan(
                        &amp;job.ID, &amp;job.Status, &amp;job.Progress, &amp;job.TotalTasks, &amp;job.CompletedTasks,
                        &amp;job.FailedTasks, &amp;job.SitemapTasks, &amp;job.FoundTasks, &amp;job.CreatedAt,
                        &amp;startedAt, &amp;completedAt, &amp;domainName,
                        &amp;job.DurationSeconds, &amp;job.AvgTimePerTaskSeconds,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to scan job row")
                        continue</span>
                }

                // Handle nullable fields
                <span class="cov0" title="0">if startedAt.Valid </span><span class="cov0" title="0">{
                        job.StartedAt = &amp;startedAt.String
                }</span>
                <span class="cov0" title="0">if completedAt.Valid </span><span class="cov0" title="0">{
                        job.CompletedAt = &amp;completedAt.String
                }</span>
                <span class="cov0" title="0">if domainName.Valid </span><span class="cov0" title="0">{
                        job.Domains = &amp;Domain{Name: domainName.String}
                }</span>

                <span class="cov0" title="0">jobs = append(jobs, job)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("error iterating job rows: %w", err)
        }</span>

        <span class="cov0" title="0">return jobs, total, nil</span>
}

// calculateDateRangeForList is a helper function for list queries
func calculateDateRangeForList(dateRange string) (*time.Time, *time.Time) <span class="cov0" title="0">{
        now := time.Now().UTC()
        var startDate, endDate *time.Time

        switch dateRange </span>{
        case "today":<span class="cov0" title="0">
                start := time.Date(now.Year(), now.Month(), now.Day(), 0, 0, 0, 0, time.UTC)
                end := time.Date(now.Year(), now.Month(), now.Day(), 23, 59, 59, 999999999, time.UTC)
                startDate = &amp;start
                endDate = &amp;end</span>
        case "last7":<span class="cov0" title="0">
                start := now.AddDate(0, 0, -7)
                startDate = &amp;start
                endDate = &amp;now</span>
        case "last30":<span class="cov0" title="0">
                start := now.AddDate(0, 0, -30)
                startDate = &amp;start
                endDate = &amp;now</span>
        case "last90":<span class="cov0" title="0">
                start := now.AddDate(0, 0, -90)
                startDate = &amp;start
                endDate = &amp;now</span>
        case "all":<span class="cov0" title="0">
                // Return nil for both to indicate no date filtering
                return nil, nil</span>
        default:<span class="cov0" title="0">
                // Default to last 7 days
                start := now.AddDate(0, 0, -7)
                startDate = &amp;start
                endDate = &amp;now</span>
        }

        <span class="cov0" title="0">return startDate, endDate</span>
}

// SlowPage represents a slow-loading page for dashboard analysis
type SlowPage struct {
        URL                string `json:"url"`
        Domain             string `json:"domain"`
        Path               string `json:"path"`
        SecondResponseTime int64  `json:"second_response_time"` // milliseconds after cache retry
        JobID              string `json:"job_id"`
        CompletedAt        string `json:"completed_at"`
}

// ExternalRedirect represents a page that redirects to an external domain
type ExternalRedirect struct {
        URL         string `json:"url"`
        Domain      string `json:"domain"`
        Path        string `json:"path"`
        RedirectURL string `json:"redirect_url"`
        JobID       string `json:"job_id"`
        CompletedAt string `json:"completed_at"`
}

// GetSlowPages retrieves the slowest pages after cache retry attempts
// Returns top 10 absolute slowest and 10% slowest from user's organisation
func (db *DB) GetSlowPages(organisationID string, startDate, endDate *time.Time) ([]SlowPage, error) <span class="cov8" title="1">{
        query := `
                WITH user_tasks AS (
                        SELECT 
                                t.url,
                                d.domain,
                                p.path,
                                t.second_response_time,
                                t.job_id,
                                t.completed_at
                        FROM tasks t
                        JOIN jobs j ON t.job_id = j.id
                        JOIN pages p ON t.page_id = p.id
                        JOIN domains d ON p.domain_id = d.id
                        WHERE j.organisation_id = $1
                                AND t.status = 'completed'
                                AND t.second_response_time IS NOT NULL
                                AND t.second_response_time &gt; 0
                                AND ($2::timestamp IS NULL OR t.completed_at &gt;= $2)
                                AND ($3::timestamp IS NULL OR t.completed_at &lt;= $3)
                ),
                top_10_absolute AS (
                        SELECT *, 'absolute' as category
                        FROM user_tasks
                        ORDER BY second_response_time DESC
                        LIMIT 10
                ),
                slowest_percentile AS (
                        SELECT *, 'percentile' as category
                        FROM user_tasks
                        WHERE second_response_time &gt;= (
                                SELECT PERCENTILE_CONT(0.9) WITHIN GROUP (ORDER BY second_response_time)
                                FROM user_tasks
                        )
                        ORDER BY second_response_time DESC
                        LIMIT 10
                )
                SELECT DISTINCT 
                        url, domain, path, second_response_time, job_id, 
                        completed_at::timestamp AT TIME ZONE 'UTC' as completed_at
                FROM (
                        SELECT * FROM top_10_absolute
                        UNION ALL
                        SELECT * FROM slowest_percentile
                ) combined
                ORDER BY second_response_time DESC
                LIMIT 20;
        `

        rows, err := db.client.Query(query, organisationID, startDate, endDate)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Msg("Failed to query slow pages")
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var slowPages []SlowPage
        for rows.Next() </span><span class="cov8" title="1">{
                var page SlowPage
                var completedAt sql.NullTime

                err := rows.Scan(
                        &amp;page.URL,
                        &amp;page.Domain,
                        &amp;page.Path,
                        &amp;page.SecondResponseTime,
                        &amp;page.JobID,
                        &amp;completedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to scan slow page row")
                        return nil, err
                }</span>

                <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                        page.CompletedAt = completedAt.Time.Format(time.RFC3339)
                }</span>

                <span class="cov8" title="1">slowPages = append(slowPages, page)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Error iterating slow pages rows")
                return nil, err
        }</span>

        <span class="cov8" title="1">return slowPages, nil</span>
}

// GetExternalRedirects retrieves pages that redirect to external domains
func (db *DB) GetExternalRedirects(organisationID string, startDate, endDate *time.Time) ([]ExternalRedirect, error) <span class="cov8" title="1">{
        query := `
                SELECT 
                        t.url,
                        d.domain,
                        p.path,
                        t.redirect_url,
                        t.job_id,
                        t.completed_at::timestamp AT TIME ZONE 'UTC' as completed_at
                FROM tasks t
                JOIN jobs j ON t.job_id = j.id
                JOIN pages p ON t.page_id = p.id
                JOIN domains d ON p.domain_id = d.id
                WHERE j.organisation_id = $1
                        AND t.status = 'completed'
                        AND t.redirect_url IS NOT NULL
                        AND t.redirect_url != ''
                        -- Check if redirect URL is external (different domain)
                        AND NOT (
                                t.redirect_url LIKE 'http://' || d.domain || '%' OR
                                t.redirect_url LIKE 'https://' || d.domain || '%' OR
                                t.redirect_url LIKE '//%' || d.domain || '%' OR
                                t.redirect_url LIKE '/' || '%'  -- relative paths
                        )
                        AND ($2::timestamp IS NULL OR t.completed_at &gt;= $2)
                        AND ($3::timestamp IS NULL OR t.completed_at &lt;= $3)
                ORDER BY t.completed_at DESC
                LIMIT 100;
        `

        rows, err := db.client.Query(query, organisationID, startDate, endDate)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Msg("Failed to query external redirects")
                return nil, err
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var redirects []ExternalRedirect
        for rows.Next() </span><span class="cov8" title="1">{
                var redirect ExternalRedirect
                var completedAt sql.NullTime

                err := rows.Scan(
                        &amp;redirect.URL,
                        &amp;redirect.Domain,
                        &amp;redirect.Path,
                        &amp;redirect.RedirectURL,
                        &amp;redirect.JobID,
                        &amp;completedAt,
                )
                if err != nil </span><span class="cov8" title="1">{
                        log.Error().Err(err).Msg("Failed to scan external redirect row")
                        return nil, err
                }</span>

                <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                        redirect.CompletedAt = completedAt.Time.Format(time.RFC3339)
                }</span>

                <span class="cov8" title="1">redirects = append(redirects, redirect)</span>
        }

        <span class="cov8" title="1">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Error iterating external redirects rows")
                return nil, err
        }</span>

        <span class="cov8" title="1">return redirects, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package db

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/cache"

        _ "github.com/jackc/pgx/v5/stdlib"
        "github.com/rs/zerolog/log"
)

// DB represents a PostgreSQL database connection
type DB struct {
        client *sql.DB
        config *Config
        Cache  *cache.InMemoryCache
}

// GetConfig returns the original DB connection settings
func (d *DB) GetConfig() *Config <span class="cov8" title="1">{
        return d.config
}</span>

// Config holds PostgreSQL connection configuration
type Config struct {
        Host         string        // Database host
        Port         string        // Database port
        User         string        // Database user
        Password     string        // Database password
        Database     string        // Database name
        SSLMode      string        // SSL mode (disable, require, verify-ca, verify-full)
        MaxIdleConns int           // Maximum number of idle connections
        MaxOpenConns int           // Maximum number of open connections
        MaxLifetime  time.Duration // Maximum lifetime of a connection
        DatabaseURL  string        // Original DATABASE_URL if used
}

// ConnectionString returns the PostgreSQL connection string
func (c *Config) ConnectionString() string <span class="cov8" title="1">{
        // If we have a DatabaseURL, use it directly
        if c.DatabaseURL != "" </span><span class="cov8" title="1">{
                return c.DatabaseURL
        }</span>

        // Set default SSLMode if not specified
        <span class="cov8" title="1">sslMode := c.SSLMode
        if sslMode == "" </span><span class="cov8" title="1">{
                sslMode = "require"
        }</span>

        // Otherwise use the individual components
        <span class="cov8" title="1">return fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=%s",
                c.Host, c.Port, c.User, c.Password, c.Database, sslMode)</span>
}

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov8" title="1">{
        // If we have a DatabaseURL, that's sufficient
        if c.DatabaseURL != "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Otherwise, check individual fields
        <span class="cov8" title="1">if c.Host == "" || c.Port == "" || c.User == "" || c.Password == "" || c.Database == "" </span><span class="cov8" title="1">{
                if c.Host == "" &amp;&amp; c.Port == "" &amp;&amp; c.User == "" &amp;&amp; c.Password == "" &amp;&amp; c.Database == "" </span><span class="cov8" title="1">{
                        return fmt.Errorf("database configuration required")
                }</span>
                <span class="cov8" title="1">return fmt.Errorf("incomplete database configuration")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// New creates a new PostgreSQL database connection
func New(config *Config) (*DB, error) <span class="cov8" title="1">{
        // Validate required fields only if not using DATABASE_URL
        if config.DatabaseURL == "" </span><span class="cov8" title="1">{
                if config.Host == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("database host is required")
                }</span>
                <span class="cov8" title="1">if config.Port == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("database port is required")
                }</span>
                <span class="cov8" title="1">if config.User == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("database user is required")
                }</span>
                <span class="cov8" title="1">if config.Database == "" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("database name is required")
                }</span>
        }

        // Set defaults for optional fields
        <span class="cov8" title="1">if config.SSLMode == "" </span><span class="cov8" title="1">{
                config.SSLMode = "disable"
        }</span>
        <span class="cov8" title="1">if config.MaxIdleConns == 0 </span><span class="cov8" title="1">{
                config.MaxIdleConns = 50  // Increased from 30
        }</span>
        <span class="cov8" title="1">if config.MaxOpenConns == 0 </span><span class="cov8" title="1">{
                config.MaxOpenConns = 150  // Increased from 75 for 49 workers
        }</span>
        <span class="cov8" title="1">if config.MaxLifetime == 0 </span><span class="cov8" title="1">{
                config.MaxLifetime = 10 * time.Minute  // Reduced from 20 minutes
        }</span>

        // Add statement timeout to connection string
        <span class="cov8" title="1">connStr := config.ConnectionString()
        if !strings.Contains(connStr, "statement_timeout") </span><span class="cov8" title="1">{
                // Check if we're using URL format or key=value format
                if strings.HasPrefix(connStr, "postgres://") || strings.HasPrefix(connStr, "postgresql://") </span><span class="cov8" title="1">{
                        // URL format - use query parameters
                        separator := "?"
                        if strings.Contains(connStr, "?") </span><span class="cov8" title="1">{
                                separator = "&amp;"
                        }</span>
                        <span class="cov8" title="1">connStr += separator + "statement_timeout=60000"</span> // 60 seconds
                } else<span class="cov8" title="1"> {
                        // Key=value format - append as another key=value pair
                        connStr += " statement_timeout=60000" // 60 seconds
                }</span>
        }
        
        <span class="cov8" title="1">client, err := sql.Open("pgx", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to PostgreSQL: %w", err)
        }</span>

        // Configure connection pool
        <span class="cov8" title="1">client.SetMaxOpenConns(config.MaxOpenConns)
        client.SetMaxIdleConns(config.MaxIdleConns)
        client.SetConnMaxLifetime(config.MaxLifetime)
        client.SetConnMaxIdleTime(2 * time.Minute)  // Close idle connections after 2 minutes

        // Test connection
        if err := client.Ping(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to ping PostgreSQL: %w", err)
        }</span>

        // Initialize schema
        <span class="cov0" title="0">if err := setupSchema(client); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to setup schema: %w", err)
        }</span>

        // Create the cache
        <span class="cov0" title="0">dbCache := cache.NewInMemoryCache()

        return &amp;DB{client: client, config: config, Cache: dbCache}, nil</span>
}

// InitFromEnv creates a PostgreSQL connection using environment variables
func InitFromEnv() (*DB, error) <span class="cov8" title="1">{
        // If DATABASE_URL is provided, use it with default config
        if url := os.Getenv("DATABASE_URL"); url != "" </span><span class="cov8" title="1">{
                config := &amp;Config{
                        DatabaseURL:  url,
                        MaxIdleConns: 50,   // Increased from 30
                        MaxOpenConns: 150,  // Increased from 75 for 49 workers  
                        MaxLifetime:  10 * time.Minute,  // Reduced from 20 minutes
                }

                // Add statement timeout to DATABASE_URL if not present
                if !strings.Contains(url, "statement_timeout") </span><span class="cov8" title="1">{
                        separator := "?"
                        if strings.Contains(url, "?") </span><span class="cov0" title="0">{
                                separator = "&amp;"
                        }</span>
                        <span class="cov8" title="1">url += separator + "statement_timeout=60000" // 60 seconds
                        // Persist the augmented URL back to config for consistency
                        config.DatabaseURL = url</span>
                }
                
                <span class="cov8" title="1">client, err := sql.Open("pgx", url)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to connect to PostgreSQL via DATABASE_URL: %w", err)
                }</span>

                // Configure connection pool using the same settings
                <span class="cov8" title="1">client.SetMaxOpenConns(config.MaxOpenConns)
                client.SetMaxIdleConns(config.MaxIdleConns)
                client.SetConnMaxLifetime(config.MaxLifetime)
                client.SetConnMaxIdleTime(2 * time.Minute)  // Close idle connections after 2 minutes

                // Verify connection
                if err := client.Ping(); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to ping PostgreSQL via DATABASE_URL: %w", err)
                }</span>

                // Initialise schema
                <span class="cov0" title="0">if err := setupSchema(client); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to setup schema: %w", err)
                }</span>

                // Create the cache
                <span class="cov0" title="0">dbCache := cache.NewInMemoryCache()

                return &amp;DB{client: client, config: config, Cache: dbCache}, nil</span>
        }

        <span class="cov8" title="1">config := &amp;Config{
                Host:         os.Getenv("POSTGRES_HOST"),
                Port:         os.Getenv("POSTGRES_PORT"),
                User:         os.Getenv("POSTGRES_USER"),
                Password:     os.Getenv("POSTGRES_PASSWORD"),
                Database:     os.Getenv("POSTGRES_DB"),
                SSLMode:      os.Getenv("POSTGRES_SSL_MODE"),
                MaxIdleConns: 30,
                MaxOpenConns: 75,
                MaxLifetime:  20 * time.Minute,
        }

        // Use defaults if not set
        if config.Host == "" </span><span class="cov8" title="1">{
                config.Host = "localhost"
        }</span>
        <span class="cov8" title="1">if config.Port == "" </span><span class="cov8" title="1">{
                config.Port = "5432"
        }</span>
        <span class="cov8" title="1">if config.User == "" </span><span class="cov8" title="1">{
                config.User = "postgres"
        }</span>
        <span class="cov8" title="1">if config.Database == "" </span><span class="cov8" title="1">{
                config.Database = "blue_banded_bee"
        }</span>

        // Create the database connection
        <span class="cov8" title="1">db, err := New(config)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return db, nil</span>
}

// createCoreTables creates all core database tables
func createCoreTables(db *sql.DB) error <span class="cov8" title="1">{
        // Create organisations table first (referenced by users and jobs)
        _, err := db.Exec(`
                CREATE TABLE IF NOT EXISTS organisations (
                        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
                        name TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                        updated_at TIMESTAMP NOT NULL DEFAULT NOW()
                )
        `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create organisations table: %w", err)
        }</span>

        // Create users table (extends Supabase auth.users)
        <span class="cov8" title="1">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS users (
                        id UUID PRIMARY KEY,
                        email TEXT NOT NULL,
                        full_name TEXT,
                        organisation_id UUID REFERENCES organisations(id),
                        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                        updated_at TIMESTAMP NOT NULL DEFAULT NOW(),
                        UNIQUE(email)
                )
        `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create users table: %w", err)
        }</span>

        // Create domains table
        <span class="cov8" title="1">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS domains (
                        id SERIAL PRIMARY KEY,
                        name TEXT NOT NULL UNIQUE,
                        crawl_delay INTEGER DEFAULT 1,
                        created_at TIMESTAMP NOT NULL DEFAULT NOW()
                )
        `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create domains table: %w", err)
        }</span>

        // Create pages table
        <span class="cov8" title="1">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS pages (
                        id SERIAL PRIMARY KEY,
                        domain_id INTEGER NOT NULL REFERENCES domains(id),
                        path TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL DEFAULT NOW(),
                        UNIQUE(domain_id, path)
                )
        `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create pages table: %w", err)
        }</span>

        // Create jobs table
        <span class="cov8" title="1">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS jobs (
                        id TEXT PRIMARY KEY,
                        domain_id INTEGER NOT NULL REFERENCES domains(id),
                        user_id UUID REFERENCES users(id),
                        organisation_id UUID REFERENCES organisations(id),
                        status TEXT NOT NULL,
                        progress REAL NOT NULL,
                        sitemap_tasks INTEGER NOT NULL DEFAULT 0,
                        found_tasks INTEGER NOT NULL DEFAULT 0,
                        total_tasks INTEGER NOT NULL DEFAULT 0,
                        completed_tasks INTEGER NOT NULL DEFAULT 0,
                        failed_tasks INTEGER NOT NULL DEFAULT 0,
                        skipped_tasks INTEGER NOT NULL DEFAULT 0,
                        created_at TIMESTAMP NOT NULL,
                        started_at TIMESTAMP,
                        completed_at TIMESTAMP,
                        concurrency INTEGER NOT NULL,
                        find_links BOOLEAN NOT NULL,
                        max_pages INTEGER NOT NULL,
                        include_paths TEXT,
                        exclude_paths TEXT,
                        required_workers INTEGER DEFAULT 0,
                        error_message TEXT,
                        source_type TEXT,
                        source_detail TEXT,
                        source_info TEXT,
                        duration_seconds INTEGER GENERATED ALWAYS AS (
                                CASE 
                                        WHEN started_at IS NOT NULL AND completed_at IS NOT NULL 
                                        THEN EXTRACT(EPOCH FROM (completed_at - started_at))::INTEGER
                                        ELSE NULL
                                END
                        ) STORED
                )
        `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create jobs table: %w", err)
        }</span>

        // Create tasks table  
        <span class="cov8" title="1">_, err = db.Exec(`
                CREATE TABLE IF NOT EXISTS tasks (
                        id TEXT PRIMARY KEY,
                        job_id TEXT NOT NULL REFERENCES jobs(id),
                        page_id INTEGER NOT NULL REFERENCES pages(id),
                        path TEXT NOT NULL,
                        status TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL,
                        started_at TIMESTAMP,
                        completed_at TIMESTAMP,
                        retry_count INTEGER NOT NULL,
                        error TEXT,
                        source_type TEXT NOT NULL,
                        source_url TEXT,
                        status_code INTEGER,
                        response_time BIGINT,
                        cache_status TEXT,
                        content_type TEXT,
                        content_length BIGINT,
                        headers JSONB,
                        redirect_url TEXT,
                        dns_lookup_time INTEGER,
                        tcp_connection_time INTEGER,
                        tls_handshake_time INTEGER,
                        ttfb INTEGER,
                        content_transfer_time INTEGER,
                        second_response_time BIGINT,
                        second_cache_status TEXT,
                        second_content_length BIGINT,
                        second_headers JSONB,
                        priority_score REAL DEFAULT 1.0
                )
        `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create tasks table: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createPerformanceIndexes creates database indexes for optimal query performance
func createPerformanceIndexes(db *sql.DB) error <span class="cov8" title="1">{
        // Create basic task lookup index
        _, err := db.Exec(`CREATE INDEX IF NOT EXISTS idx_tasks_job_id ON tasks(job_id)`)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create task job_id index: %w", err)
        }</span>

        // Drop deprecated indexes if they exist
        <span class="cov8" title="1">_, err = db.Exec(`DROP INDEX IF EXISTS idx_tasks_status`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop old status index: %w", err)
        }</span>
        <span class="cov8" title="1">_, err = db.Exec(`DROP INDEX IF EXISTS idx_tasks_status_created`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop old status/created_at index: %w", err)
        }</span>
        <span class="cov8" title="1">_, err = db.Exec(`DROP INDEX IF EXISTS idx_tasks_priority`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop old priority index: %w", err)
        }</span>

        // Create optimised index for worker task claiming
        <span class="cov8" title="1">_, err = db.Exec(`CREATE INDEX IF NOT EXISTS idx_tasks_pending_claim_order ON tasks (created_at) WHERE status = 'pending'`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create optimised pending task index: %w", err)
        }</span>

        // Index for dashboard/API queries on job status and priority
        <span class="cov8" title="1">_, err = db.Exec(`CREATE INDEX IF NOT EXISTS idx_tasks_job_status_priority ON tasks(job_id, status, priority_score DESC)`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create task job/status/priority index: %w", err)
        }</span>

        // Unique constraint to prevent duplicate tasks for same job/page combination
        <span class="cov8" title="1">_, err = db.Exec(`CREATE UNIQUE INDEX IF NOT EXISTS idx_tasks_job_page_unique ON tasks(job_id, page_id)`)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create unique job/page index: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// enableRowLevelSecurity enables RLS on all tables and sets up policies
func enableRowLevelSecurity(db *sql.DB) error <span class="cov8" title="1">{
        // Enable Row-Level Security for all tables
        tables := []string{"organisations", "users", "domains", "pages", "jobs", "tasks"}
        for _, table := range tables </span><span class="cov8" title="1">{
                // Enable RLS on the table
                _, err := db.Exec(fmt.Sprintf("ALTER TABLE %s ENABLE ROW LEVEL SECURITY", table))
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to enable RLS on %s table: %w", table, err)
                }</span>
        }

        // Set up Row Level Security policies
        <span class="cov8" title="1">err := setupRLSPolicies(db)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to setup RLS policies: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupSchema creates the necessary tables in PostgreSQL
func setupSchema(db *sql.DB) error <span class="cov0" title="0">{
        // Create all core database tables
        if err := createCoreTables(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create performance indexes
        <span class="cov0" title="0">if err := createPerformanceIndexes(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Enable Row-Level Security
        <span class="cov0" title="0">if err := enableRowLevelSecurity(db); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create database triggers for automatic timestamp and progress management
        <span class="cov0" title="0">if err := setupTimestampTriggers(db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup timestamp triggers: %w", err)
        }</span>

        <span class="cov0" title="0">if err := setupProgressTriggers(db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to setup progress triggers: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupTimestampTriggers creates database triggers for automatic timestamp management
func setupTimestampTriggers(db *sql.DB) error <span class="cov0" title="0">{
        // Function to automatically set started_at when first task completes
        _, err := db.Exec(`
                CREATE OR REPLACE FUNCTION set_job_started_at()
                RETURNS TRIGGER AS $$
                BEGIN
                  -- Only set started_at if it's currently NULL and completed_tasks &gt; 0
                  -- Handle both INSERT and UPDATE operations
                  IF NEW.completed_tasks &gt; 0 AND (TG_OP = 'INSERT' OR OLD.started_at IS NULL) AND NEW.started_at IS NULL THEN
                    NEW.started_at = CURRENT_TIMESTAMP AT TIME ZONE 'UTC';
                  END IF;
                  
                  RETURN NEW;
                END;
                $$ LANGUAGE plpgsql;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create set_job_started_at function: %w", err)
        }</span>

        // Function to automatically set completed_at when job reaches 100%
        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE OR REPLACE FUNCTION set_job_completed_at()
                RETURNS TRIGGER AS $$
                BEGIN
                  -- Set completed_at when progress reaches 100% and it's not already set
                  -- Handle both INSERT and UPDATE operations
                  IF NEW.progress &gt;= 100.0 AND (TG_OP = 'INSERT' OR OLD.completed_at IS NULL) AND NEW.completed_at IS NULL THEN
                    NEW.completed_at = CURRENT_TIMESTAMP AT TIME ZONE 'UTC';
                  END IF;
                  
                  RETURN NEW;
                END;
                $$ LANGUAGE plpgsql;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create set_job_completed_at function: %w", err)
        }</span>

        // Create trigger for started_at (INSERT OR UPDATE)
        <span class="cov0" title="0">_, err = db.Exec(`
                DROP TRIGGER IF EXISTS trigger_set_job_started ON jobs;
                CREATE TRIGGER trigger_set_job_started
                  BEFORE INSERT OR UPDATE ON jobs
                  FOR EACH ROW
                  EXECUTE FUNCTION set_job_started_at();
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create started_at trigger: %w", err)
        }</span>

        // Create trigger for completed_at (INSERT OR UPDATE)
        <span class="cov0" title="0">_, err = db.Exec(`
                DROP TRIGGER IF EXISTS trigger_set_job_completed ON jobs;
                CREATE TRIGGER trigger_set_job_completed
                  BEFORE INSERT OR UPDATE ON jobs
                  FOR EACH ROW
                  EXECUTE FUNCTION set_job_completed_at();
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create completed_at trigger: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupProgressTriggers creates database triggers for automatic progress calculation
func setupProgressTriggers(db *sql.DB) error <span class="cov0" title="0">{
        // Function to automatically calculate job progress when tasks change
        _, err := db.Exec(`
                CREATE OR REPLACE FUNCTION update_job_progress()
                RETURNS TRIGGER AS $$
                DECLARE
                    job_id_to_update TEXT;
                    total_tasks INTEGER;
                    completed_count INTEGER;
                    failed_count INTEGER;
                    skipped_count INTEGER;
                    new_progress REAL;
                BEGIN
                    -- Determine which job to update
                    IF TG_OP = 'DELETE' THEN
                        job_id_to_update = OLD.job_id;
                    ELSE
                        job_id_to_update = NEW.job_id;
                    END IF;
                    
                    -- Get the total tasks for this job
                    SELECT j.total_tasks INTO total_tasks
                    FROM jobs j
                    WHERE j.id = job_id_to_update;
                    
                    -- Count completed, failed, and skipped tasks
                    SELECT 
                        COUNT(*) FILTER (WHERE status = 'completed'),
                        COUNT(*) FILTER (WHERE status = 'failed'),
                        COUNT(*) FILTER (WHERE status = 'skipped')
                    INTO completed_count, failed_count, skipped_count
                    FROM tasks
                    WHERE job_id = job_id_to_update;
                    
                    -- Calculate progress percentage (only count completed + failed, not skipped)
                    IF total_tasks &gt; 0 AND (total_tasks - skipped_count) &gt; 0 THEN
                        new_progress = (completed_count + failed_count)::REAL / (total_tasks - skipped_count)::REAL * 100.0;
                    ELSE
                        new_progress = 0.0;
                    END IF;
                    
                    -- Update the job with new counts and progress
                    UPDATE jobs
                    SET 
                        completed_tasks = completed_count,
                        failed_tasks = failed_count,
                        skipped_tasks = skipped_count,
                        progress = new_progress,
                        status = CASE 
                            WHEN new_progress &gt;= 100.0 THEN 'completed'
                            WHEN completed_count &gt; 0 OR failed_count &gt; 0 THEN 'running'
                            ELSE status
                        END
                    WHERE id = job_id_to_update;
                    
                    -- Return the appropriate record based on operation
                    IF TG_OP = 'DELETE' THEN
                        RETURN OLD;
                    ELSE
                        RETURN NEW;
                    END IF;
                END;
                $$ LANGUAGE plpgsql;
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create update_job_progress function: %w", err)
        }</span>

        // Create trigger on tasks table to update job progress
        <span class="cov0" title="0">_, err = db.Exec(`
                DROP TRIGGER IF EXISTS trigger_update_job_progress ON tasks;
                CREATE TRIGGER trigger_update_job_progress
                  AFTER INSERT OR UPDATE OR DELETE ON tasks
                  FOR EACH ROW
                  EXECUTE FUNCTION update_job_progress();
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create job progress trigger: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// setupRLSPolicies creates Row Level Security policies for user data access
func setupRLSPolicies(db *sql.DB) error <span class="cov8" title="1">{
        // Create policy for users table - users can only access their own data
        _, err := db.Exec(`
                DROP POLICY IF EXISTS "Users can access own data" ON users;
                CREATE POLICY "Users can access own data" ON users
                FOR ALL USING (auth.uid() = id);
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create users RLS policy: %w", err)
        }</span>

        // Create policy for organisations table - users can access their organisation
        <span class="cov8" title="1">_, err = db.Exec(`
                DROP POLICY IF EXISTS "Users can access own organisation" ON organisations;
                CREATE POLICY "Users can access own organisation" ON organisations
                FOR ALL USING (
                        id IN (
                                SELECT organisation_id FROM users WHERE id = auth.uid()
                        )
                );
        `)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create organisations RLS policy: %w", err)
        }</span>

        // Create policy for jobs table - organisation members can access shared jobs
        <span class="cov0" title="0">_, err = db.Exec(`
                DROP POLICY IF EXISTS "Organisation members can access jobs" ON jobs;
                CREATE POLICY "Organisation members can access jobs" ON jobs
                FOR ALL USING (
                        organisation_id IN (
                                SELECT organisation_id FROM users WHERE id = auth.uid()
                        )
                );
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create jobs RLS policy: %w", err)
        }</span>

        // Create policy for tasks table - organisation members can access tasks for their jobs
        <span class="cov0" title="0">_, err = db.Exec(`
                DROP POLICY IF EXISTS "Organisation members can access tasks" ON tasks;
                CREATE POLICY "Organisation members can access tasks" ON tasks
                FOR ALL USING (
                        job_id IN (
                                SELECT id FROM jobs WHERE organisation_id IN (
                                        SELECT organisation_id FROM users WHERE id = auth.uid()
                                )
                        )
                );
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create tasks RLS policy: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Close closes the database connection
func (db *DB) Close() error <span class="cov0" title="0">{
        return db.client.Close()
}</span>

// GetDB returns the underlying database connection
func (db *DB) GetDB() *sql.DB <span class="cov0" title="0">{
        return db.client
}</span>

// ResetSchema resets the database schema
func (db *DB) ResetSchema() error <span class="cov0" title="0">{
        log.Warn().Msg("Resetting PostgreSQL schema")

        // First drop any views that depend on the tables
        log.Debug().Msg("Dropping views")
        views := []string{"job_list", "job_dashboard", "job_status_summary", "task_status_summary"}
        for _, view := range views </span><span class="cov0" title="0">{
                _, err := db.client.Exec(fmt.Sprintf(`DROP VIEW IF EXISTS %s CASCADE`, view))
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Str("view", view).Msg("Failed to drop view (may not exist)")
                        // Don't return error for views, as they may not exist
                }</span> else<span class="cov0" title="0"> {
                        log.Debug().Str("view", view).Msg("Successfully dropped view")
                }</span>
        }

        // Drop tables in reverse order to respect foreign keys
        // Use CASCADE to handle any remaining dependencies
        <span class="cov0" title="0">tables := []string{"tasks", "jobs", "pages", "domains"}

        for _, table := range tables </span><span class="cov0" title="0">{
                log.Debug().Str("table", table).Msg("Dropping table")
                _, err := db.client.Exec(fmt.Sprintf(`DROP TABLE IF EXISTS %s CASCADE`, table))
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("table", table).Msg("Failed to drop table")
                        return fmt.Errorf("failed to drop table %s: %w", table, err)
                }</span>
                <span class="cov0" title="0">log.Debug().Str("table", table).Msg("Successfully dropped table")</span>
        }

        // Also drop any sequences that might exist
        <span class="cov0" title="0">log.Debug().Msg("Dropping sequences")
        sequences := []string{"domains_id_seq", "pages_id_seq"}
        for _, seq := range sequences </span><span class="cov0" title="0">{
                _, err := db.client.Exec(fmt.Sprintf(`DROP SEQUENCE IF EXISTS %s CASCADE`, seq))
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().Err(err).Str("sequence", seq).Msg("Failed to drop sequence (may not exist)")
                        // Don't return error for sequences, as they may not exist
                }</span>
        }

        <span class="cov0" title="0">log.Debug().Msg("Recreating schema")
        // Recreate schema
        err := setupSchema(db.client)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to recreate schema")
                return fmt.Errorf("failed to recreate schema: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().Msg("Successfully reset database schema")
        return nil</span>
}

// RecalculateJobStats recalculates all statistics for a job based on actual task records
func (db *DB) RecalculateJobStats(ctx context.Context, jobID string) error <span class="cov0" title="0">{
        _, err := db.client.ExecContext(ctx, `SELECT recalculate_job_stats($1)`, jobID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to recalculate job stats: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Serialise converts data to JSON string representation.
// It is named with British English spelling for consistency.
func Serialise(v interface{}) string <span class="cov8" title="1">{
        data, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to serialise data")
                return "{}"
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package db

import (
        "fmt"
        "strings"
)

// AugmentDSNWithTimeout adds statement_timeout to a DSN if not already present
// Supports both URL format (postgresql://...) and key=value format
func AugmentDSNWithTimeout(dsn string, timeoutMs int) string <span class="cov8" title="1">{
        if dsn == "" || strings.Contains(dsn, "statement_timeout") </span><span class="cov8" title="1">{
                return dsn
        }</span>

        <span class="cov8" title="1">if timeoutMs &lt;= 0 </span><span class="cov8" title="1">{
                timeoutMs = 60000 // Default 60 seconds
        }</span>
        <span class="cov8" title="1">timeoutStr := fmt.Sprintf("%d", timeoutMs)

        // URL format
        if strings.HasPrefix(dsn, "postgresql://") || strings.HasPrefix(dsn, "postgres://") </span><span class="cov8" title="1">{
                separator := "?"
                if strings.Contains(dsn, "?") </span><span class="cov8" title="1">{
                        separator = "&amp;"
                }</span>
                <span class="cov8" title="1">return dsn + separator + "statement_timeout=" + timeoutStr</span>
        }

        // Key=value format
        <span class="cov8" title="1">separator := " "
        return dsn + separator + "statement_timeout=" + timeoutStr</span>
}</pre>
		
		<pre class="file" id="file20" style="display: none">package db

import (
        "context"
        "time"
)

// HealthCheck contains database health information
type HealthCheck struct {
        Connected   bool          `json:"connected"`
        Latency     time.Duration `json:"latency_ms"`
        Tables      []string      `json:"tables,omitempty"`
        TablesCount int           `json:"tables_count"`
        Error       string        `json:"error,omitempty"`
}

// CheckHealth tests the database connection and returns health information
func (db *DB) CheckHealth(ctx context.Context) HealthCheck <span class="cov0" title="0">{
        result := HealthCheck{
                Connected: false,
        }

        // Test 1: Basic connectivity with timing
        startTime := time.Now()
        err := db.client.PingContext(ctx)
        result.Latency = time.Since(startTime)

        if err != nil </span><span class="cov0" title="0">{
                result.Error = err.Error()
                return result
        }</span>

        // Connection successful
        <span class="cov0" title="0">result.Connected = true

        // Test 2: List tables to verify schema
        rows, err := db.client.QueryContext(ctx, `
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public'
        `)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = "Connected but failed to list tables: " + err.Error()
                return result
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []string
        for rows.Next() </span><span class="cov0" title="0">{
                var tableName string
                if err := rows.Scan(&amp;tableName); err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">tables = append(tables, tableName)</span>
        }

        <span class="cov0" title="0">result.Tables = tables
        result.TablesCount = len(tables)

        return result</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package db

import (
        "context"
        "database/sql"
        "fmt"
        "net/url"
        "strings"

        "github.com/rs/zerolog/log"
)

// Page represents a page to be enqueued with its priority
type Page struct {
        ID       int
        Path     string
        Priority float64
}

// TransactionExecutor interface for types that can execute transactions
type TransactionExecutor interface {
        Execute(ctx context.Context, fn func(*sql.Tx) error) error
}

// CreatePageRecords finds existing pages or creates new ones for the given URLs.
// It returns the page IDs and their corresponding paths.
func CreatePageRecords(ctx context.Context, q TransactionExecutor, domainID int, domain string, urls []string) ([]int, []string, error) <span class="cov0" title="0">{
        var pageIDs []int
        var paths []string

        err := q.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                stmt, err := tx.PrepareContext(ctx, `
                        INSERT INTO pages (domain_id, path)
                        VALUES ($1, $2)
                        ON CONFLICT (domain_id, path) DO UPDATE SET path = EXCLUDED.path
                        RETURNING id
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to prepare page insert statement: %w", err)
                }</span>
                <span class="cov0" title="0">defer stmt.Close()

                for _, u := range urls </span><span class="cov0" title="0">{
                        // Normalise URL to get just the path
                        path, err := normaliseURLPath(u, domain)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warn().Err(err).Str("url", u).Msg("Skipping invalid URL")
                                continue</span>
                        }

                        // Get or create the page record
                        <span class="cov0" title="0">var pageID int
                        if err := stmt.QueryRowContext(ctx, domainID, path).Scan(&amp;pageID); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to insert/get page record: %w", err)
                        }</span>

                        <span class="cov0" title="0">pageIDs = append(pageIDs, pageID)
                        paths = append(paths, path)</span>
                }
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov0" title="0">return pageIDs, paths, nil</span>
}

func normaliseURLPath(u string, domain string) (string, error) <span class="cov0" title="0">{
        parsedURL, err := url.Parse(u)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if !parsedURL.IsAbs() </span><span class="cov0" title="0">{
                base, _ := url.Parse("https://" + domain)
                parsedURL = base.ResolveReference(parsedURL)
        }</span>
        <span class="cov0" title="0">path := parsedURL.Path
        if path == "" </span><span class="cov0" title="0">{
                path = "/"
        }</span>
        <span class="cov0" title="0">if path != "/" &amp;&amp; strings.HasSuffix(path, "/") </span><span class="cov0" title="0">{
                path = strings.TrimSuffix(path, "/")
        }</span>
        <span class="cov0" title="0">return path, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package db

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "github.com/getsentry/sentry-go"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

// DbQueue is a PostgreSQL implementation of a job queue
type DbQueue struct {
        db *DB
}

// NewDbQueue creates a PostgreSQL job queue
func NewDbQueue(db *DB) *DbQueue <span class="cov8" title="1">{
        return &amp;DbQueue{
                db: db,
        }
}</span>

// Execute runs a database operation in a transaction
func (q *DbQueue) Execute(ctx context.Context, fn func(*sql.Tx) error) error <span class="cov8" title="1">{
        // Add timeout to context if none exists
        if _, ok := ctx.Deadline(); !ok </span><span class="cov8" title="1">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithTimeout(ctx, 30*time.Second)
                defer cancel()
        }</span>
        
        // Begin transaction
        <span class="cov8" title="1">tx, err := q.db.client.BeginTx(ctx, nil)
        if err != nil </span><span class="cov8" title="1">{
                sentry.CaptureException(err)
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Run the operation
        if err := fn(tx); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Commit the transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov8" title="1">{
                sentry.CaptureException(err)
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Task represents a task in the queue
type Task struct {
        ID          string
        JobID       string
        PageID      int
        Path        string
        Status      string
        CreatedAt   time.Time
        StartedAt   time.Time
        CompletedAt time.Time
        RetryCount  int
        Error       string
        SourceType  string
        SourceURL   string

        // Result data
        StatusCode          int
        ResponseTime        int64
        CacheStatus         string
        ContentType         string
        ContentLength       int64
        Headers             []byte // Stored as JSONB
        RedirectURL         string
        DNSLookupTime       int64
        TCPConnectionTime   int64
        TLSHandshakeTime    int64
        TTFB                int64
        ContentTransferTime int64

        // Second request data
        SecondResponseTime        int64
        SecondCacheStatus         string
        SecondContentLength       int64
        SecondHeaders             []byte // Stored as JSONB
        SecondDNSLookupTime       int64
        SecondTCPConnectionTime   int64
        SecondTLSHandshakeTime    int64
        SecondTTFB                int64
        SecondContentTransferTime int64
        CacheCheckAttempts        []byte // Stored as JSONB

        // Priority
        PriorityScore float64
}

// GetNextTask gets a pending task using row-level locking
func (q *DbQueue) GetNextTask(ctx context.Context, jobID string) (*Task, error) <span class="cov8" title="1">{
        var task Task

        err := q.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                // Query for a pending task with FOR UPDATE SKIP LOCKED
                // This allows concurrent workers to each get different tasks
                query := `
                        SELECT id, job_id, page_id, path, created_at, retry_count, source_type, source_url, priority_score 
                        FROM tasks 
                        WHERE status = 'pending'
                `

                // Add job filter if specified
                args := []interface{}{}
                if jobID != "" </span><span class="cov8" title="1">{
                        query += " AND job_id = $1"
                        args = append(args, jobID)
                }</span>

                // Add ordering and locking - prioritise by priority_score DESC, then created_at ASC
                <span class="cov8" title="1">query += `
                        ORDER BY priority_score DESC, created_at ASC
                        LIMIT 1
                        FOR UPDATE SKIP LOCKED
                `

                // Execute the query
                var row *sql.Row
                if len(args) &gt; 0 </span><span class="cov8" title="1">{
                        row = tx.QueryRowContext(ctx, query, args...)
                }</span> else<span class="cov8" title="1"> {
                        row = tx.QueryRowContext(ctx, query)
                }</span>

                <span class="cov8" title="1">err := row.Scan(
                        &amp;task.ID, &amp;task.JobID, &amp;task.PageID, &amp;task.Path,
                        &amp;task.CreatedAt, &amp;task.RetryCount, &amp;task.SourceType, &amp;task.SourceURL,
                        &amp;task.PriorityScore,
                )

                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return sql.ErrNoRows
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to query task: %w", err)
                }</span>

                // Update the task status
                <span class="cov8" title="1">now := time.Now()
                _, err = tx.ExecContext(ctx, `
                        UPDATE tasks
                        SET status = 'running', started_at = $1
                        WHERE id = $2
                `, now, task.ID)

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to update task status: %w", err)
                }</span>

                <span class="cov8" title="1">task.Status = "running"
                task.StartedAt = now

                return nil</span>
        })

        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil // No tasks available
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;task, nil</span>
}

// EnqueueURLs adds multiple URLs as tasks for a job
func (q *DbQueue) EnqueueURLs(ctx context.Context, jobID string, pages []Page, sourceType string, sourceURL string) error <span class="cov8" title="1">{
        if len(pages) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return q.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                // Get job's max_pages setting and current task counts
                var maxPages int
                var currentTaskCount int
                err := tx.QueryRowContext(ctx, `
                        SELECT max_pages, 
                                   COALESCE((SELECT COUNT(*) FROM tasks WHERE job_id = $1 AND status != 'skipped'), 0)
                        FROM jobs WHERE id = $1
                `, jobID).Scan(&amp;maxPages, &amp;currentTaskCount)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get job max_pages and task count: %w", err)
                }</span>

                // Count how many tasks will be pending vs skipped
                <span class="cov8" title="1">pendingCount := 0
                skippedCount := 0
                for _, page := range pages </span><span class="cov8" title="1">{
                        if page.ID == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if maxPages == 0 || currentTaskCount+pendingCount &lt; maxPages </span><span class="cov8" title="1">{
                                pendingCount++
                        }</span> else<span class="cov0" title="0"> {
                                skippedCount++
                        }</span>
                }

                // Prepare statement for batch insert with duplicate handling
                <span class="cov8" title="1">stmt, err := tx.PrepareContext(ctx, `
                        INSERT INTO tasks (
                                id, job_id, page_id, path, status, created_at, retry_count,
                                source_type, source_url, priority_score
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                        ON CONFLICT (job_id, page_id) DO NOTHING
                `)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to prepare statement: %w", err)
                }</span>
                <span class="cov8" title="1">defer stmt.Close()

                // Insert each task with appropriate status
                now := time.Now()
                processedCount := 0
                for _, page := range pages </span><span class="cov8" title="1">{
                        if page.ID == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Determine status based on max_pages limit
                        <span class="cov8" title="1">var status string
                        if maxPages == 0 || currentTaskCount+processedCount &lt; maxPages </span><span class="cov8" title="1">{
                                status = "pending"
                                processedCount++
                        }</span> else<span class="cov0" title="0"> {
                                status = "skipped"
                        }</span>

                        <span class="cov8" title="1">taskID := uuid.New().String()
                        _, err = stmt.ExecContext(ctx,
                                taskID, jobID, page.ID, page.Path, status, now, 0, sourceType, sourceURL, page.Priority)

                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("failed to insert task: %w", err)
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        })
}

// CleanupStuckJobs finds and fixes jobs that are stuck in pending/running state
// despite having all their tasks completed
func (q *DbQueue) CleanupStuckJobs(ctx context.Context) error <span class="cov8" title="1">{
        span := sentry.StartSpan(ctx, "db.cleanup_stuck_jobs")
        defer span.Finish()

        // Define status constants for job states
        const (
                JobStatusCompleted = "completed"
                JobStatusPending   = "pending"
                JobStatusRunning   = "running"
        )

        result, err := q.db.client.ExecContext(ctx, `
                UPDATE jobs 
                SET status = $1, 
                        completed_at = COALESCE(completed_at, $2),
                        progress = 100.0
                WHERE (status = $3 OR status = $4)
                AND total_tasks &gt; 0 
                AND total_tasks = completed_tasks + failed_tasks
        `, JobStatusCompleted, time.Now(), JobStatusPending, JobStatusRunning)

        if err != nil </span><span class="cov8" title="1">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                sentry.CaptureException(err)
                return fmt.Errorf("failed to cleanup stuck jobs: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected &gt; 0 </span><span class="cov8" title="1">{
                log.Info().
                        Int64("jobs_fixed", rowsAffected).
                        Msg("Fixed stuck jobs")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// UpdateTaskStatus updates a task's status and associated metadata in a single function
// This provides a unified way to handle various task state transitions
func (q *DbQueue) UpdateTaskStatus(ctx context.Context, task *Task) error <span class="cov8" title="1">{
        if task == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("cannot update nil task")
        }</span>

        <span class="cov8" title="1">now := time.Now()

        // Set appropriate timestamps based on status if not already set
        if task.Status == "running" &amp;&amp; task.StartedAt.IsZero() </span><span class="cov8" title="1">{
                task.StartedAt = now
        }</span>
        <span class="cov8" title="1">if (task.Status == "completed" || task.Status == "failed") &amp;&amp; task.CompletedAt.IsZero() </span><span class="cov8" title="1">{
                task.CompletedAt = now
        }</span>

        // Update task in a transaction
        <span class="cov8" title="1">err := q.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                var err error

                // Use different update logic based on status
                switch task.Status </span>{
                case "running":<span class="cov8" title="1">
                        _, err = tx.ExecContext(ctx, `
                                UPDATE tasks 
                                SET status = $1, started_at = $2
                                WHERE id = $3
                        `, task.Status, task.StartedAt, task.ID)</span>

                case "completed":<span class="cov0" title="0">
                        _, err = tx.ExecContext(ctx, `
                                UPDATE tasks 
                                SET status = $1, completed_at = $2, status_code = $3, 
                                        response_time = $4, cache_status = $5, content_type = $6,
                                        content_length = $7, headers = $8, redirect_url = $9,
                                        dns_lookup_time = $10, tcp_connection_time = $11, tls_handshake_time = $12,
                                        ttfb = $13, content_transfer_time = $14,
                                        second_response_time = $15, second_cache_status = $16,
                                        second_content_length = $17, second_headers = $18,
                                        second_dns_lookup_time = $19, second_tcp_connection_time = $20,
                                        second_tls_handshake_time = $21, second_ttfb = $22,
                                        second_content_transfer_time = $23,
                                        retry_count = $24, cache_check_attempts = $25
                                WHERE id = $26
                        `, task.Status, task.CompletedAt, task.StatusCode,
                                task.ResponseTime, task.CacheStatus, task.ContentType,
                                task.ContentLength, task.Headers, task.RedirectURL,
                                task.DNSLookupTime, task.TCPConnectionTime, task.TLSHandshakeTime,
                                task.TTFB, task.ContentTransferTime,
                                task.SecondResponseTime, task.SecondCacheStatus,
                                task.SecondContentLength, task.SecondHeaders,
                                task.SecondDNSLookupTime, task.SecondTCPConnectionTime,
                                task.SecondTLSHandshakeTime, task.SecondTTFB,
                                task.SecondContentTransferTime,
                                task.RetryCount, task.CacheCheckAttempts, task.ID)</span>

                case "failed":<span class="cov8" title="1">
                        _, err = tx.ExecContext(ctx, `
                                UPDATE tasks 
                                SET status = $1, completed_at = $2, error = $3, retry_count = $4
                                WHERE id = $5
                        `, task.Status, task.CompletedAt, task.Error, task.RetryCount, task.ID)</span>

                case "skipped":<span class="cov0" title="0">
                        _, err = tx.ExecContext(ctx, `
                                UPDATE tasks 
                                SET status = $1
                                WHERE id = $2
                        `, task.Status, task.ID)</span>

                default:<span class="cov0" title="0">
                        // Generic status update
                        _, err = tx.ExecContext(ctx, `
                                UPDATE tasks 
                                SET status = $1
                                WHERE id = $2
                        `, task.Status, task.ID)</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to update task status: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package db

import (
        "database/sql"
        "fmt"
        "time"

        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

// User represents a user in the system
type User struct {
        ID             string    `json:"id"`
        Email          string    `json:"email"`
        FullName       *string   `json:"full_name,omitempty"`
        OrganisationID *string   `json:"organisation_id,omitempty"`
        CreatedAt      time.Time `json:"created_at"`
        UpdatedAt      time.Time `json:"updated_at"`
}

// Organisation represents an organisation in the system
type Organisation struct {
        ID        string    `json:"id"`
        Name      string    `json:"name"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// GetUser retrieves a user by ID
func (db *DB) GetUser(userID string) (*User, error) <span class="cov0" title="0">{
        user := &amp;User{}

        query := `
                SELECT id, email, full_name, organisation_id, created_at, updated_at
                FROM users
                WHERE id = $1
        `

        err := db.client.QueryRow(query, userID).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.FullName, &amp;user.OrganisationID,
                &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByWebhookToken retrieves a user by their webhook token
func (db *DB) GetUserByWebhookToken(webhookToken string) (*User, error) <span class="cov0" title="0">{
        user := &amp;User{}

        query := `
                SELECT id, email, full_name, organisation_id, created_at, updated_at
                FROM users
                WHERE webhook_token = $1
        `

        err := db.client.QueryRow(query, webhookToken).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.FullName, &amp;user.OrganisationID,
                &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("user not found with webhook token")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get user by webhook token: %w", err)</span>
        }

        <span class="cov0" title="0">return user, nil</span>
}

// GetOrCreateUser retrieves a user by ID, creating them if they don't exist
// This is used for auto-creating users from valid JWT tokens
func (db *DB) GetOrCreateUser(userID, email string, fullName *string) (*User, error) <span class="cov0" title="0">{
        // First try to get the existing user
        user, err := db.GetUser(userID)
        if err == nil </span><span class="cov0" title="0">{
                // User exists, return them
                return user, nil
        }</span>
        
        // User doesn't exist, auto-create them with a default organisation
        <span class="cov0" title="0">log.Info().
                Str("user_id", userID).
                Str("email", email).
                Msg("Auto-creating user from JWT token")
        
        // Determine organisation name
        orgName := "Personal Organisation"
        if fullName != nil &amp;&amp; *fullName != "" </span><span class="cov0" title="0">{
                orgName = *fullName
        }</span>
        
        // Create the user
        <span class="cov0" title="0">newUser, _, err := db.CreateUser(userID, email, fullName, orgName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to auto-create user: %w", err)
        }</span>
        
        <span class="cov0" title="0">return newUser, nil</span>
}

// CreateOrganisation creates a new organisation
func (db *DB) CreateOrganisation(name string) (*Organisation, error) <span class="cov0" title="0">{
        org := &amp;Organisation{
                ID:   uuid.New().String(),
                Name: name,
        }

        query := `
                INSERT INTO organisations (id, name, created_at, updated_at)
                VALUES ($1, $2, NOW(), NOW())
                RETURNING created_at, updated_at
        `

        err := db.client.QueryRow(query, org.ID, org.Name).Scan(
                &amp;org.CreatedAt, &amp;org.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create organisation: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("organisation_id", org.ID).
                Str("name", org.Name).
                Msg("Created new organisation")

        return org, nil</span>
}

// GetOrganisation retrieves an organisation by ID
func (db *DB) GetOrganisation(organisationID string) (*Organisation, error) <span class="cov0" title="0">{
        org := &amp;Organisation{}

        query := `
                SELECT id, name, created_at, updated_at
                FROM organisations
                WHERE id = $1
        `

        err := db.client.QueryRow(query, organisationID).Scan(
                &amp;org.ID, &amp;org.Name, &amp;org.CreatedAt, &amp;org.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("organisation not found")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get organisation: %w", err)</span>
        }

        <span class="cov0" title="0">return org, nil</span>
}

func (db *DB) GetOrganisationMembers(organisationID string) ([]*User, error) <span class="cov0" title="0">{
        query := `
                SELECT id, email, full_name, organisation_id, created_at, updated_at
                FROM users
                WHERE organisation_id = $1
                ORDER BY created_at ASC
        `

        rows, err := db.client.Query(query, organisationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get organisation members: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var users []*User
        for rows.Next() </span><span class="cov0" title="0">{
                user := &amp;User{}
                err := rows.Scan(
                        &amp;user.ID, &amp;user.Email, &amp;user.FullName, &amp;user.OrganisationID,
                        &amp;user.CreatedAt, &amp;user.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan user: %w", err)
                }</span>
                <span class="cov0" title="0">users = append(users, user)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to iterate user rows: %w", err)
        }</span>

        <span class="cov0" title="0">return users, nil</span>
}

// If user already exists, returns the existing user and their organisation
func (db *DB) CreateUser(userID, email string, fullName *string, orgName string) (*User, *Organisation, error) <span class="cov0" title="0">{
        // First check if user already exists
        existingUser, err := db.GetUser(userID)
        if err == nil </span><span class="cov0" title="0">{
                // User exists, get their organisation
                if existingUser.OrganisationID != nil </span><span class="cov0" title="0">{
                        org, err := db.GetOrganisation(*existingUser.OrganisationID)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Warn().Err(err).Str("organisation_id", *existingUser.OrganisationID).Msg("Failed to get existing user's organisation")
                                // Return user without organisation rather than failing
                                return existingUser, nil, nil
                        }</span>
                        <span class="cov0" title="0">log.Info().
                                Str("user_id", userID).
                                Str("email", email).
                                Msg("User already exists, returning existing user and organisation")
                        return existingUser, org, nil</span>
                }
                // User exists but has no organisation - this shouldn't happen but handle gracefully
                <span class="cov0" title="0">log.Info().
                        Str("user_id", userID).
                        Str("email", email).
                        Msg("User already exists but has no organisation")
                return existingUser, nil, nil</span>
        }

        // User doesn't exist, create new user and organisation
        // Start a transaction for automatic operation
        <span class="cov0" title="0">tx, err := db.client.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to start transaction: %w", err)
        }</span>
        <span class="cov0" title="0">defer tx.Rollback()

        // Create organisation first
        org := &amp;Organisation{
                ID:   uuid.New().String(),
                Name: orgName,
        }

        orgQuery := `
                INSERT INTO organisations (id, name, created_at, updated_at)
                VALUES ($1, $2, NOW(), NOW())
                RETURNING created_at, updated_at
        `

        err = tx.QueryRow(orgQuery, org.ID, org.Name).Scan(
                &amp;org.CreatedAt, &amp;org.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create organisation: %w", err)
        }</span>

        // Create user with organisation reference
        <span class="cov0" title="0">user := &amp;User{
                ID:             userID,
                Email:          email,
                FullName:       fullName,
                OrganisationID: &amp;org.ID,
        }

        userQuery := `
                INSERT INTO users (id, email, full_name, organisation_id, created_at, updated_at)
                VALUES ($1, $2, $3, $4, NOW(), NOW())
                RETURNING created_at, updated_at
        `

        err = tx.QueryRow(userQuery, user.ID, user.Email, user.FullName, user.OrganisationID).Scan(
                &amp;user.CreatedAt, &amp;user.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create user: %w", err)
        }</span>

        // Commit transaction
        <span class="cov0" title="0">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("user_id", user.ID).
                Str("email", user.Email).
                Str("organisation_id", org.ID).
                Str("organisation_name", org.Name).
                Msg("Created new user with organisation")

        return user, org, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package jobs

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/crawler"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/Harvey-AU/blue-banded-bee/internal/util"
        "github.com/getsentry/sentry-go"
        "github.com/google/uuid"
        "github.com/rs/zerolog/log"
)

// DbQueueProvider defines the interface for database operations
type DbQueueProvider interface {
        Execute(ctx context.Context, fn func(*sql.Tx) error) error
        EnqueueURLs(ctx context.Context, jobID string, pages []db.Page, sourceType string, sourceURL string) error
        CleanupStuckJobs(ctx context.Context) error
}

// JobManagerInterface defines the interface for job management operations
type JobManagerInterface interface {
        // Core job operations used by API layer
        CreateJob(ctx context.Context, options *JobOptions) (*Job, error)
        StartJob(ctx context.Context, jobID string) error
        CancelJob(ctx context.Context, jobID string) error
        GetJobStatus(ctx context.Context, jobID string) (*Job, error)
        
        // Additional job operations
        GetJob(ctx context.Context, jobID string) (*Job, error)
        EnqueueJobURLs(ctx context.Context, jobID string, pages []db.Page, sourceType string, sourceURL string) error
        
        // Job utility methods
        IsJobComplete(job *Job) bool
        CalculateJobProgress(job *Job) float64
        ValidateStatusTransition(from, to JobStatus) error
        UpdateJobStatus(ctx context.Context, jobID string, status JobStatus) error
}

// JobManager handles job creation and lifecycle management
type JobManager struct {
        db      *sql.DB
        dbQueue DbQueueProvider
        crawler CrawlerInterface

        workerPool *WorkerPool

        // Map to track which pages have been processed for each job
        processedPages map[string]struct{} // Key format: "jobID_pageID"
        pagesMutex     sync.RWMutex        // Mutex for thread-safe access
}

// NewJobManager creates a new job manager
func NewJobManager(db *sql.DB, dbQueue DbQueueProvider, crawler CrawlerInterface, workerPool *WorkerPool) *JobManager <span class="cov8" title="1">{
        return &amp;JobManager{
                db:             db,
                dbQueue:        dbQueue,
                crawler:        crawler,
                workerPool:     workerPool,
                processedPages: make(map[string]struct{}),
        }
}</span>

// handleExistingJobs checks for existing active jobs and cancels them if found
func (jm *JobManager) handleExistingJobs(ctx context.Context, domain string, organisationID *string) error <span class="cov8" title="1">{
        if organisationID == nil || *organisationID == "" </span><span class="cov8" title="1">{
                return nil // Skip check if no organisation ID
        }</span>

        <span class="cov8" title="1">var existingJobID string
        var existingJobStatus string
        var existingOrgID string

        err := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                return tx.QueryRowContext(ctx, `
                        SELECT j.id, j.status, j.organisation_id
                        FROM jobs j
                        JOIN domains d ON j.domain_id = d.id
                        WHERE d.name = $1
                        AND j.organisation_id = $2
                        AND j.status IN ('pending', 'initializing', 'running', 'paused')
                        ORDER BY j.created_at DESC
                        LIMIT 1
                `, domain, *organisationID).Scan(&amp;existingJobID, &amp;existingJobStatus, &amp;existingOrgID)
        }</span>)

        <span class="cov8" title="1">if err == nil &amp;&amp; existingJobID != "" </span><span class="cov0" title="0">{
                // Found an existing active job for the same domain and organisation
                log.Info().
                        Str("existing_job_id", existingJobID).
                        Str("existing_job_status", existingJobStatus).
                        Str("domain", domain).
                        Str("organisation_id", *organisationID).
                        Msg("Found existing active job for domain, cancelling it")

                if err := jm.CancelJob(ctx, existingJobID); err != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Err(err).
                                Str("job_id", existingJobID).
                                Msg("Failed to cancel existing job")
                        // Continue with new job creation even if cancellation fails
                }</span>
        } else<span class="cov8" title="1"> if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                // Log query error but continue with job creation
                log.Warn().
                        Err(err).
                        Str("domain", domain).
                        Msg("Error checking for existing jobs")
        }</span>

        <span class="cov8" title="1">return nil</span> // Always return nil to continue with job creation
}

// createJobObject creates a new Job instance with the given options and normalized domain
func createJobObject(options *JobOptions, normalisedDomain string) *Job <span class="cov8" title="1">{
        return &amp;Job{
                ID:              uuid.New().String(),
                Domain:          normalisedDomain,
                UserID:          options.UserID,
                OrganisationID:  options.OrganisationID,
                Status:          JobStatusPending,
                Progress:        0,
                TotalTasks:      0,
                CompletedTasks:  0,
                FoundTasks:      0,
                SitemapTasks:    0,
                FailedTasks:     0,
                CreatedAt:       time.Now().UTC(),
                Concurrency:     options.Concurrency,
                FindLinks:       options.FindLinks,
                MaxPages:        options.MaxPages,
                IncludePaths:    options.IncludePaths,
                ExcludePaths:    options.ExcludePaths,
                RequiredWorkers: options.RequiredWorkers,
                SourceType:      options.SourceType,
                SourceDetail:    options.SourceDetail,
                SourceInfo:      options.SourceInfo,
        }
}</span>

// setupJobDatabase creates domain and job records in the database
// Returns the domain ID for use in subsequent operations
func (jm *JobManager) setupJobDatabase(ctx context.Context, job *Job, normalisedDomain string) (int, error) <span class="cov8" title="1">{
        var domainID int

        err := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                // Get or create domain ID
                err := tx.QueryRow(`
                        INSERT INTO domains(name) VALUES($1) 
                        ON CONFLICT (name) DO UPDATE SET name=EXCLUDED.name 
                        RETURNING id`, normalisedDomain).Scan(&amp;domainID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get or create domain: %w", err)
                }</span>

                // Insert the job
                <span class="cov8" title="1">_, err = tx.Exec(
                        `INSERT INTO jobs (
                                id, domain_id, user_id, organisation_id, status, progress, total_tasks, completed_tasks, failed_tasks, skipped_tasks,
                                created_at, concurrency, find_links, include_paths, exclude_paths,
                                required_workers, max_pages,
                                found_tasks, sitemap_tasks, source_type, source_detail, source_info
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22)`,
                        job.ID, domainID, job.UserID, job.OrganisationID, string(job.Status), job.Progress,
                        job.TotalTasks, job.CompletedTasks, job.FailedTasks, job.SkippedTasks,
                        job.CreatedAt, job.Concurrency, job.FindLinks,
                        db.Serialise(job.IncludePaths), db.Serialise(job.ExcludePaths),
                        job.RequiredWorkers, job.MaxPages,
                        job.FoundTasks, job.SitemapTasks, job.SourceType, job.SourceDetail, job.SourceInfo,
                )
                return err</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("failed to create job: %w", err)
        }</span>

        <span class="cov8" title="1">return domainID, nil</span>
}

// validateRootURLAccess checks robots.txt rules and validates root URL access
func (jm *JobManager) validateRootURLAccess(ctx context.Context, job *Job, normalisedDomain string, rootPath string) (*crawler.RobotsRules, error) <span class="cov8" title="1">{
        var robotsRules *crawler.RobotsRules
        
        if jm.crawler != nil </span><span class="cov8" title="1">{
                // Use DiscoverSitemapsAndRobots which already includes parsing
                discoveryResult, err := jm.crawler.DiscoverSitemapsAndRobots(ctx, normalisedDomain)
                if err != nil </span><span class="cov8" title="1">{
                        log.Error().
                                Err(err).
                                Str("domain", normalisedDomain).
                                Msg("Failed to fetch robots.txt for manual URL")

                        // Update job with error
                        if updateErr := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                                _, err := tx.ExecContext(ctx, `
                                        UPDATE jobs
                                        SET status = $1, error_message = $2, completed_at = $3
                                        WHERE id = $4
                                `, JobStatusFailed, fmt.Sprintf("Failed to fetch robots.txt: %v", err), time.Now().UTC(), job.ID)
                                return err
                        }</span>); updateErr != nil <span class="cov0" title="0">{
                                log.Error().Err(updateErr).Str("job_id", job.ID).Msg("Failed to update job status")
                        }</span>
                        <span class="cov8" title="1">return nil, fmt.Errorf("failed to fetch robots.txt: %w", err)</span>
                }

                // Use the already parsed robots rules from discovery
                <span class="cov8" title="1">robotsRules = discoveryResult.RobotsRules
                
                // Store crawl delay if specified in robots.txt
                if robotsRules != nil &amp;&amp; robotsRules.CrawlDelay &gt; 0 </span><span class="cov8" title="1">{
                        jm.updateDomainCrawlDelay(ctx, normalisedDomain, robotsRules.CrawlDelay)
                }</span>
        }

        // Check if root path is allowed by robots.txt
        <span class="cov8" title="1">if robotsRules != nil &amp;&amp; !crawler.IsPathAllowed(robotsRules, rootPath) </span><span class="cov0" title="0">{
                log.Warn().
                        Str("job_id", job.ID).
                        Str("domain", normalisedDomain).
                        Str("path", rootPath).
                        Msg("Root path is disallowed by robots.txt, job cannot proceed")

                // Update job with error
                if updateErr := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                        _, err := tx.ExecContext(ctx, `
                                UPDATE jobs
                                SET status = $1, error_message = $2, completed_at = $3
                                WHERE id = $4
                        `, JobStatusFailed, "Root path (/) is disallowed by robots.txt", time.Now().UTC(), job.ID)
                        return err
                }</span>); updateErr != nil <span class="cov0" title="0">{
                        log.Error().Err(updateErr).Str("job_id", job.ID).Msg("Failed to update job status")
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("root path is disallowed by robots.txt")</span>
        }

        <span class="cov8" title="1">return robotsRules, nil</span>
}

// createManualRootTask creates page and task records for the root URL
func (jm *JobManager) createManualRootTask(ctx context.Context, job *Job, domainID int, rootPath string) error <span class="cov8" title="1">{
        err := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                var pageID int
                err := tx.QueryRowContext(ctx, `
                        INSERT INTO pages (domain_id, path)
                        VALUES ($1, $2)
                        ON CONFLICT (domain_id, path) DO UPDATE SET path = EXCLUDED.path
                        RETURNING id
                `, domainID, rootPath).Scan(&amp;pageID)

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create page record for root path: %w", err)
                }</span>

                // Enqueue the root URL with its page ID
                <span class="cov0" title="0">_, err = tx.ExecContext(ctx, `
                        INSERT INTO tasks (
                                id, job_id, page_id, path, status, created_at, retry_count,
                                source_type, source_url
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                `, uuid.New().String(), job.ID, pageID, rootPath, "pending", time.Now().UTC(), 0, "manual", "")

                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to enqueue task for root path: %w", err)
                }</span>

                <span class="cov0" title="0">jm.markPageProcessed(job.ID, pageID)
                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Msg("Failed to create and enqueue root URL")
                return err
        }</span>

        <span class="cov8" title="1">log.Info().
                Str("job_id", job.ID).
                Str("domain", job.Domain).
                Msg("Added root URL to job queue")

        return nil</span>
}

// setupJobURLDiscovery handles URL discovery for the job (sitemap or manual)
func (jm *JobManager) setupJobURLDiscovery(ctx context.Context, job *Job, options *JobOptions, domainID int, normalisedDomain string) error <span class="cov8" title="1">{
        if options.UseSitemap </span><span class="cov8" title="1">{
                // Fetch and process sitemap in a separate goroutine
                // Use detached context with timeout for background processing
                backgroundCtx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
                go func() </span><span class="cov8" title="1">{
                        defer cancel()
                        jm.processSitemap(backgroundCtx, job.ID, normalisedDomain, options.IncludePaths, options.ExcludePaths)
                }</span>()
                <span class="cov8" title="1">return nil</span>
        }

        // Manual root URL creation - process in background for consistency  
        // Use detached context with timeout for background processing
        <span class="cov8" title="1">backgroundCtx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
        go func() </span><span class="cov8" title="1">{
                defer cancel()
                rootPath := "/"
                _, err := jm.validateRootURLAccess(backgroundCtx, job, normalisedDomain, rootPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("job_id", job.ID).Msg("Failed to validate root URL access")
                        return // Error already logged and job updated by validateRootURLAccess
                }</span>

                // Create page and task records for the root URL
                <span class="cov8" title="1">if err := jm.createManualRootTask(backgroundCtx, job, domainID, rootPath); err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("job_id", job.ID).Msg("Failed to create manual root task")
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// CreateJob creates a new job with the given options
func (jm *JobManager) CreateJob(ctx context.Context, options *JobOptions) (*Job, error) <span class="cov8" title="1">{
        span := sentry.StartSpan(ctx, "manager.create_job")
        defer span.Finish()

        span.SetTag("domain", options.Domain)

        normalisedDomain := util.NormaliseDomain(options.Domain)

        // Handle any existing active jobs for the same domain and organisation
        if err := jm.handleExistingJobs(ctx, normalisedDomain, options.OrganisationID); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to handle existing jobs: %w", err)
        }</span>

        // Create a new job object
        <span class="cov8" title="1">job := createJobObject(options, normalisedDomain)

        // Setup database records for the job
        domainID, err := jm.setupJobDatabase(ctx, job, normalisedDomain)
        if err != nil </span><span class="cov0" title="0">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                sentry.CaptureException(err)
                return nil, err
        }</span>

        <span class="cov8" title="1">log.Info().
                Str("job_id", job.ID).
                Str("domain", job.Domain).
                Bool("use_sitemap", options.UseSitemap).
                Bool("find_links", options.FindLinks).
                Int("max_pages", options.MaxPages).
                Msg("Created new job")

        // Setup URL discovery (sitemap or manual root URL)
        if err := jm.setupJobURLDiscovery(ctx, job, options, domainID, normalisedDomain); err != nil </span><span class="cov0" title="0">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                return job, err // Return job even on URL discovery error (some errors are expected)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// StartJob starts a pending job
func (jm *JobManager) StartJob(ctx context.Context, jobID string) error <span class="cov8" title="1">{
        span := sentry.StartSpan(ctx, "manager.restart_job")
        defer span.Finish()

        span.SetTag("original_job_id", jobID)

        // Get the original job to copy its configuration
        originalJob, err := jm.GetJob(ctx, jobID)
        if err != nil </span><span class="cov8" title="1">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                sentry.CaptureException(err)
                return fmt.Errorf("failed to get original job: %w", err)
        }</span>

        // Only allow restarting completed, failed, or cancelled jobs
        <span class="cov8" title="1">if originalJob.Status != JobStatusCompleted &amp;&amp; originalJob.Status != JobStatusFailed &amp;&amp; originalJob.Status != JobStatusCancelled </span><span class="cov8" title="1">{
                return fmt.Errorf("job cannot be restarted: %s (only completed, failed, or cancelled jobs can be restarted)", originalJob.Status)
        }</span>

        // Create new job with same configuration
        <span class="cov8" title="1">newJobOptions := &amp;JobOptions{
                Domain:          originalJob.Domain,
                UserID:          originalJob.UserID,
                OrganisationID:  originalJob.OrganisationID,
                UseSitemap:      true, // Default to true
                Concurrency:     originalJob.Concurrency,
                FindLinks:       originalJob.FindLinks,
                MaxPages:        originalJob.MaxPages,
                IncludePaths:    originalJob.IncludePaths,
                ExcludePaths:    originalJob.ExcludePaths,
                RequiredWorkers: originalJob.RequiredWorkers,
        }

        // Create the new job
        newJob, err := jm.CreateJob(ctx, newJobOptions)
        if err != nil </span><span class="cov0" title="0">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                sentry.CaptureException(err)
                return fmt.Errorf("failed to create new job: %w", err)
        }</span>

        <span class="cov8" title="1">span.SetTag("new_job_id", newJob.ID)
        log.Info().Str("original_job_id", jobID).Str("new_job_id", newJob.ID).Msg("Created new job as restart")

        // Add new job to worker pool for processing
        if jm.workerPool != nil </span><span class="cov0" title="0">{
                jm.workerPool.AddJob(newJob.ID, newJobOptions)
        }</span>

        <span class="cov8" title="1">log.Debug().
                Str("original_job_id", jobID).
                Str("new_job_id", newJob.ID).
                Str("domain", newJob.Domain).
                Msg("Restarted job with new job ID")

        return nil</span>
}

// Helper method to check if a page has been processed for a job
func (jm *JobManager) isPageProcessed(jobID string, pageID int) bool <span class="cov0" title="0">{
        key := fmt.Sprintf("%s_%d", jobID, pageID)
        jm.pagesMutex.RLock()
        defer jm.pagesMutex.RUnlock()
        _, exists := jm.processedPages[key]
        return exists
}</span>

// Helper method to mark a page as processed for a job
func (jm *JobManager) markPageProcessed(jobID string, pageID int) <span class="cov0" title="0">{
        key := fmt.Sprintf("%s_%d", jobID, pageID)
        jm.pagesMutex.Lock()
        defer jm.pagesMutex.Unlock()
        jm.processedPages[key] = struct{}{}
}</span>

// Helper method to clear processed pages for a job (when job is completed or canceled)
func (jm *JobManager) clearProcessedPages(jobID string) <span class="cov8" title="1">{
        jm.pagesMutex.Lock()
        defer jm.pagesMutex.Unlock()

        // Find all keys that start with this job ID
        prefix := jobID + "_"
        for key := range jm.processedPages </span><span class="cov0" title="0">{
                if strings.HasPrefix(key, prefix) </span><span class="cov0" title="0">{
                        delete(jm.processedPages, key)
                }</span>
        }
}

// EnqueueJobURLs is a wrapper around dbQueue.EnqueueURLs that adds duplicate detection
func (jm *JobManager) EnqueueJobURLs(ctx context.Context, jobID string, pages []db.Page, sourceType string, sourceURL string) error <span class="cov0" title="0">{
        span := sentry.StartSpan(ctx, "manager.enqueue_job_urls")
        defer span.Finish()

        span.SetTag("job_id", jobID)
        span.SetTag("url_count", fmt.Sprintf("%d", len(pages)))

        if len(pages) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Filter out pages that have already been processed
        <span class="cov0" title="0">var filteredPages []db.Page

        for _, page := range pages </span><span class="cov0" title="0">{
                if !jm.isPageProcessed(jobID, page.ID) </span><span class="cov0" title="0">{
                        filteredPages = append(filteredPages, page)
                        // Don't mark as processed yet - we'll do that after successful enqueue
                }</span>
        }

        // If all pages were already processed, just return success
        <span class="cov0" title="0">if len(filteredPages) == 0 </span><span class="cov0" title="0">{
                log.Debug().
                        Str("job_id", jobID).
                        Int("skipped_urls", len(pages)).
                        Msg("All URLs already processed, skipping")
                return nil
        }</span>

        <span class="cov0" title="0">log.Debug().
                Str("job_id", jobID).
                Int("total_urls", len(pages)).
                Int("new_urls", len(filteredPages)).
                Int("skipped_urls", len(pages)-len(filteredPages)).
                Msg("Enqueueing filtered URLs")

        // Use the filtered lists to enqueue only new pages
        err := jm.dbQueue.EnqueueURLs(ctx, jobID, filteredPages, sourceType, sourceURL)

        // Only mark pages as processed if the enqueue was successful
        if err == nil </span><span class="cov0" title="0">{

                // Mark all successfully enqueued pages as processed
                for _, page := range filteredPages </span><span class="cov0" title="0">{
                        jm.markPageProcessed(jobID, page.ID)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Error().
                        Err(err).
                        Str("job_id", jobID).
                        Int("url_count", len(filteredPages)).
                        Msg("Failed to enqueue URLs, not marking pages as processed")
        }</span>

        <span class="cov0" title="0">return err</span>
}

// CancelJob cancels a running job
func (jm *JobManager) CancelJob(ctx context.Context, jobID string) error <span class="cov8" title="1">{
        span := sentry.StartSpan(ctx, "manager.cancel_job")
        defer span.Finish()

        span.SetTag("job_id", jobID)

        // Get the job using our new method
        job, err := jm.GetJob(ctx, jobID)
        if err != nil </span><span class="cov8" title="1">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                sentry.CaptureException(err)
                return fmt.Errorf("failed to get job: %w", err)
        }</span>

        // Check if job can be canceled
        <span class="cov8" title="1">if job.Status != JobStatusRunning &amp;&amp; job.Status != JobStatusPending &amp;&amp; job.Status != JobStatusPaused </span><span class="cov8" title="1">{
                return fmt.Errorf("job cannot be canceled: %s", job.Status)
        }</span>

        // Update job status to cancelled
        <span class="cov8" title="1">job.Status = JobStatusCancelled
        job.CompletedAt = time.Now().UTC()

        // Use dbQueue for transaction safety
        err = jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                // Update job status
                _, err := tx.ExecContext(ctx, `
                        UPDATE jobs
                        SET status = $1, completed_at = $2
                        WHERE id = $3
                `, job.Status, job.CompletedAt, job.ID)

                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Cancel pending tasks
                <span class="cov8" title="1">_, err = tx.ExecContext(ctx, `
                        UPDATE tasks
                        SET status = $1
                        WHERE job_id = $2 AND status = $3
                `, TaskStatusSkipped, job.ID, TaskStatusPending)

                return err</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                sentry.CaptureException(err)
                log.Error().Err(err).Str("job_id", job.ID).Msg("Failed to cancel job")
        }</span>

        // Remove job from worker pool
        <span class="cov8" title="1">if jm.workerPool != nil </span><span class="cov8" title="1">{
                jm.workerPool.RemoveJob(job.ID)
        }</span>

        // Clear processed pages for this job
        <span class="cov8" title="1">jm.clearProcessedPages(job.ID)

        log.Debug().
                Str("job_id", job.ID).
                Str("domain", job.Domain).
                Msg("Cancelled job")

        return nil</span>
}

// GetJob retrieves a job by ID
func (jm *JobManager) GetJob(ctx context.Context, jobID string) (*Job, error) <span class="cov8" title="1">{
        span := sentry.StartSpan(ctx, "jobs.get_job")
        defer span.Finish()

        span.SetTag("job_id", jobID)

        var job Job
        var includePaths, excludePaths []byte
        var startedAt, completedAt sql.NullTime
        var errorMessage sql.NullString

        // Use DbQueue.Execute for transactional safety
        err := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                // Query for job with domain join
                err := tx.QueryRowContext(ctx, `
                        SELECT 
                                j.id, d.name, j.status, j.progress, j.total_tasks, j.completed_tasks, j.failed_tasks, j.skipped_tasks,
                                j.created_at, j.started_at, j.completed_at, j.concurrency, j.find_links,
                                j.include_paths, j.exclude_paths, j.error_message, j.required_workers,
                                j.found_tasks, j.sitemap_tasks, j.duration_seconds, j.avg_time_per_task_seconds
                        FROM jobs j
                        JOIN domains d ON j.domain_id = d.id
                        WHERE j.id = $1
                `, jobID).Scan(
                        &amp;job.ID, &amp;job.Domain, &amp;job.Status, &amp;job.Progress, &amp;job.TotalTasks, &amp;job.CompletedTasks,
                        &amp;job.FailedTasks, &amp;job.SkippedTasks, &amp;job.CreatedAt, &amp;startedAt, &amp;completedAt, &amp;job.Concurrency,
                        &amp;job.FindLinks, &amp;includePaths, &amp;excludePaths, &amp;errorMessage, &amp;job.RequiredWorkers,
                        &amp;job.FoundTasks, &amp;job.SitemapTasks, &amp;job.DurationSeconds, &amp;job.AvgTimePerTaskSeconds,
                )
                return err
        }</span>)

        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("job not found: %s", jobID)
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                return nil, fmt.Errorf("failed to get job: %w", err)
        }</span>

        // Handle nullable fields
        <span class="cov8" title="1">if startedAt.Valid </span><span class="cov8" title="1">{
                job.StartedAt = startedAt.Time
        }</span>

        <span class="cov8" title="1">if completedAt.Valid </span><span class="cov8" title="1">{
                job.CompletedAt = completedAt.Time
        }</span>

        <span class="cov8" title="1">if errorMessage.Valid </span><span class="cov8" title="1">{
                job.ErrorMessage = errorMessage.String
        }</span>

        // Parse arrays from JSON
        <span class="cov8" title="1">if len(includePaths) &gt; 0 </span><span class="cov8" title="1">{
                err = json.Unmarshal(includePaths, &amp;job.IncludePaths)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal include paths: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if len(excludePaths) &gt; 0 </span><span class="cov8" title="1">{
                err = json.Unmarshal(excludePaths, &amp;job.ExcludePaths)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to unmarshal exclude paths: %w", err)
                }</span>
        }

        <span class="cov8" title="1">return &amp;job, nil</span>
}

// GetJobStatus gets the current status of a job
func (jm *JobManager) GetJobStatus(ctx context.Context, jobID string) (*Job, error) <span class="cov0" title="0">{
        // First cleanup any stuck jobs using dbQueue
        if err := jm.dbQueue.CleanupStuckJobs(ctx); err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to cleanup stuck jobs during status check")
                // Don't return error, continue with status check
        }</span>

        <span class="cov0" title="0">span := sentry.StartSpan(ctx, "manager.get_job_status")
        defer span.Finish()

        span.SetTag("job_id", jobID)

        job, err := jm.GetJob(ctx, jobID)
        if err != nil </span><span class="cov0" title="0">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                return nil, fmt.Errorf("failed to get job: %w", err)
        }</span>

        <span class="cov0" title="0">return job, nil</span>
}

// discoverAndParseSitemaps discovers and parses all sitemaps for a domain
func (jm *JobManager) discoverAndParseSitemaps(ctx context.Context, domain string) ([]string, *crawler.RobotsRules, error) <span class="cov0" title="0">{
        // Use the injected crawler if available, otherwise create a new one
        var sitemapCrawler CrawlerInterface
        if jm.crawler != nil </span><span class="cov0" title="0">{
                sitemapCrawler = jm.crawler
        }</span> else<span class="cov0" title="0"> {
                // Create a crawler config that allows skipping already cached URLs
                crawlerConfig := crawler.DefaultConfig()
                crawlerConfig.SkipCachedURLs = false
                sitemapCrawler = crawler.New(crawlerConfig)
        }</span>

        // Discover sitemaps and robots.txt rules for the domain
        <span class="cov0" title="0">discoveryResult, err := sitemapCrawler.DiscoverSitemapsAndRobots(ctx, domain)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("domain", domain).
                        Msg("Failed to discover sitemaps and robots rules")
                return []string{}, &amp;crawler.RobotsRules{}, err
        }</span>

        <span class="cov0" title="0">sitemaps := discoveryResult.Sitemaps
        robotsRules := discoveryResult.RobotsRules

        // Log discovered sitemaps
        log.Info().
                Str("domain", domain).
                Int("sitemap_count", len(sitemaps)).
                Msg("Sitemaps discovered")

        // Process each sitemap to extract URLs
        var urls []string
        for _, sitemapURL := range sitemaps </span><span class="cov0" title="0">{
                log.Info().
                        Str("sitemap_url", sitemapURL).
                        Msg("Processing sitemap")

                sitemapURLs, err := sitemapCrawler.ParseSitemap(ctx, sitemapURL)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn().
                                Err(err).
                                Str("sitemap_url", sitemapURL).
                                Msg("Error parsing sitemap")
                        continue</span>
                }

                <span class="cov0" title="0">log.Info().
                        Str("sitemap_url", sitemapURL).
                        Int("url_count", len(sitemapURLs)).
                        Msg("Parsed URLs from sitemap")

                urls = append(urls, sitemapURLs...)</span>
        }

        <span class="cov0" title="0">return urls, robotsRules, nil</span>
}

// filterURLsAgainstRobots filters URLs against robots.txt rules and path patterns
func (jm *JobManager) filterURLsAgainstRobots(urls []string, robotsRules *crawler.RobotsRules, includePaths, excludePaths []string) []string <span class="cov0" title="0">{
        // Use the injected crawler if available for path filtering
        var filteredURLs []string
        if jm.crawler != nil &amp;&amp; (len(includePaths) &gt; 0 || len(excludePaths) &gt; 0) </span><span class="cov0" title="0">{
                filteredURLs = jm.crawler.FilterURLs(urls, includePaths, excludePaths)
        }</span> else<span class="cov0" title="0"> {
                filteredURLs = urls
        }</span>

        // Filter URLs against robots.txt rules
        <span class="cov0" title="0">if robotsRules != nil &amp;&amp; len(robotsRules.DisallowPatterns) &gt; 0 </span><span class="cov0" title="0">{
                var allowedURLs []string
                for _, urlStr := range filteredURLs </span><span class="cov0" title="0">{
                        // Extract path from URL
                        if parsedURL, err := url.Parse(urlStr); err == nil </span><span class="cov0" title="0">{
                                path := parsedURL.Path
                                if crawler.IsPathAllowed(robotsRules, path) </span><span class="cov0" title="0">{
                                        allowedURLs = append(allowedURLs, urlStr)
                                }</span> else<span class="cov0" title="0"> {
                                        log.Debug().
                                                Str("url", urlStr).
                                                Str("path", path).
                                                Msg("URL blocked by robots.txt")
                                }</span>
                        }
                }
                <span class="cov0" title="0">log.Info().
                        Int("original_count", len(filteredURLs)).
                        Int("allowed_count", len(allowedURLs)).
                        Int("blocked_count", len(filteredURLs)-len(allowedURLs)).
                        Msg("Filtered URLs against robots.txt rules")
                return allowedURLs</span>
        }

        <span class="cov0" title="0">return filteredURLs</span>
}

// enqueueURLsForJob creates page records and enqueues URLs for a job
func (jm *JobManager) enqueueURLsForJob(ctx context.Context, jobID, domain string, urls []string, sourceType string) error <span class="cov0" title="0">{
        if len(urls) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Get domain ID from the job
        <span class="cov0" title="0">var domainID int
        err := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                return tx.QueryRowContext(ctx, `
                        SELECT domain_id FROM jobs WHERE id = $1
                `, jobID).Scan(&amp;domainID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get domain ID: %w", err)
        }</span>

        // Create page records and get their IDs
        <span class="cov0" title="0">pageIDs, paths, err := db.CreatePageRecords(ctx, jm.dbQueue, domainID, domain, urls)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create page records: %w", err)
        }</span>

        // Prepare pages with priorities
        <span class="cov0" title="0">pagesWithPriority := make([]db.Page, len(pageIDs))
        for i, pageID := range pageIDs </span><span class="cov0" title="0">{
                pagesWithPriority[i] = db.Page{
                        ID:       pageID,
                        Path:     paths[i],
                        Priority: 0.5, // Default sitemap priority
                }
                // Set homepage priority to 1.000
                if paths[i] == "/" </span><span class="cov0" title="0">{
                        pagesWithPriority[i].Priority = 1.000
                        log.Info().
                                Str("job_id", jobID).
                                Msg("Set homepage priority to 1.000")
                }</span>
        }

        // Use our wrapper function that checks for duplicates
        <span class="cov0" title="0">baseURL := fmt.Sprintf("https://%s", domain)
        if err := jm.EnqueueJobURLs(ctx, jobID, pagesWithPriority, sourceType, baseURL); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to enqueue URLs: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("job_id", jobID).
                Str("domain", domain).
                Int("url_count", len(urls)).
                Str("source_type", sourceType).
                Msg("Added URLs to job queue")

        // Recalculate job statistics after bulk operation
        if err := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx, `SELECT recalculate_job_stats($1)`, jobID)
                return err
        }</span>); err != nil <span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("job_id", jobID).
                        Msg("Failed to recalculate job stats")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// updateDomainCrawlDelay updates the domain's crawl delay from robots.txt
func (jm *JobManager) updateDomainCrawlDelay(ctx context.Context, domain string, crawlDelay int) <span class="cov8" title="1">{
        if crawlDelay &lt;= 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if err := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx, `
                        UPDATE domains
                        SET crawl_delay_seconds = $1
                        WHERE name = $2
                `, crawlDelay, domain)
                return err
        }</span>); err != nil <span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("domain", domain).
                        Int("crawl_delay", crawlDelay).
                        Msg("Failed to update domain with crawl delay")
        }</span> else<span class="cov8" title="1"> {
                log.Info().
                        Str("domain", domain).
                        Int("crawl_delay", crawlDelay).
                        Msg("Updated domain with crawl delay from robots.txt")
        }</span>
}

// IsJobComplete checks if all tasks in a job are processed
func (jm *JobManager) IsJobComplete(job *Job) bool <span class="cov8" title="1">{
        // A job is complete when all tasks are either completed, failed, or skipped
        // and the job is currently running
        if job.Status != JobStatusRunning </span><span class="cov8" title="1">{
                return false
        }</span>
        
        <span class="cov8" title="1">processedTasks := job.CompletedTasks + job.FailedTasks + job.SkippedTasks
        return processedTasks &gt;= job.TotalTasks</span>
}

// CalculateJobProgress calculates the progress percentage of a job
func (jm *JobManager) CalculateJobProgress(job *Job) float64 <span class="cov8" title="1">{
        if job.TotalTasks == 0 </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        
        <span class="cov8" title="1">processedTasks := job.CompletedTasks + job.FailedTasks + job.SkippedTasks
        return float64(processedTasks) / float64(job.TotalTasks) * 100.0</span>
}

// ValidateStatusTransition checks if a status transition is valid
func (jm *JobManager) ValidateStatusTransition(from, to JobStatus) error <span class="cov8" title="1">{
        // Allow restarts from completed/cancelled/failed states
        if to == JobStatusRunning &amp;&amp; (from == JobStatusCompleted || from == JobStatusCancelled || from == JobStatusFailed) </span><span class="cov8" title="1">{
                return nil
        }</span>
        
        // Normal forward transitions
        <span class="cov8" title="1">validTransitions := map[JobStatus][]JobStatus{
                JobStatusPending:   {JobStatusRunning, JobStatusCancelled},
                JobStatusRunning:   {JobStatusCompleted, JobStatusFailed, JobStatusCancelled},
                JobStatusCompleted: {JobStatusRunning}, // Restart
                JobStatusFailed:    {JobStatusRunning}, // Retry
                JobStatusCancelled: {JobStatusRunning}, // Restart
        }
        
        allowed, exists := validTransitions[from]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid status transition from %s to %s", from, to)
        }</span>
        
        <span class="cov8" title="1">for _, valid := range allowed </span><span class="cov8" title="1">{
                if valid == to </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        
        <span class="cov8" title="1">return fmt.Errorf("invalid status transition from %s to %s", from, to)</span>
}

// UpdateJobStatus updates the status of a job with appropriate timestamps
func (jm *JobManager) UpdateJobStatus(ctx context.Context, jobID string, status JobStatus) error <span class="cov8" title="1">{
        return jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov8" title="1">{
                var query string
                var args []interface{}

                switch status </span>{
                case JobStatusCompleted:<span class="cov8" title="1">
                        query = "UPDATE jobs SET status = $1, completed_at = $2 WHERE id = $3"
                        args = []interface{}{string(status), time.Now(), jobID}</span>
                case JobStatusRunning:<span class="cov8" title="1">
                        query = "UPDATE jobs SET status = $1, started_at = $2 WHERE id = $3"
                        args = []interface{}{string(status), time.Now(), jobID}</span>
                default:<span class="cov8" title="1">
                        query = "UPDATE jobs SET status = $1 WHERE id = $2"
                        args = []interface{}{string(status), jobID}</span>
                }

                <span class="cov8" title="1">_, err := tx.Exec(query, args...)
                return err</span>
        })
}

// updateJobWithError updates a job with an error message
func (jm *JobManager) updateJobWithError(ctx context.Context, jobID, errorMessage string) <span class="cov8" title="1">{
        if updateErr := jm.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                _, err := tx.ExecContext(ctx, `
                        UPDATE jobs
                        SET error_message = $1
                        WHERE id = $2
                `, errorMessage, jobID)
                return err
        }</span>); updateErr != nil <span class="cov8" title="1">{
                log.Error().Err(updateErr).Str("job_id", jobID).Msg("Failed to update job with error message")
        }</span>
}

// enqueueFallbackURL creates and enqueues a fallback root URL when no sitemap URLs are found
func (jm *JobManager) enqueueFallbackURL(ctx context.Context, jobID, domain string) error <span class="cov0" title="0">{
        log.Info().
                Str("job_id", jobID).
                Str("domain", domain).
                Msg("No URLs found in sitemap, falling back to root page")

        // Create fallback root URL
        rootURL := fmt.Sprintf("https://%s/", domain)
        fallbackURLs := []string{rootURL}

        if err := jm.enqueueURLsForJob(ctx, jobID, domain, fallbackURLs, "fallback"); err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("job_id", jobID).
                        Str("domain", domain).
                        Msg("Failed to enqueue fallback root URL")

                // Update job with error
                jm.updateJobWithError(ctx, jobID, fmt.Sprintf("Failed to create fallback task: %v", err))
                return err
        }</span>

        <span class="cov0" title="0">log.Info().
                Str("job_id", jobID).
                Str("domain", domain).
                Msg("Created fallback root page task - job will proceed with link discovery")
        
        return nil</span>
}

// enqueueSitemapURLs enqueues discovered sitemap URLs for processing
func (jm *JobManager) enqueueSitemapURLs(ctx context.Context, jobID, domain string, urls []string) error <span class="cov0" title="0">{
        // Log URLs for debugging
        for i, url := range urls </span><span class="cov0" title="0">{
                log.Debug().
                        Str("job_id", jobID).
                        Str("domain", domain).
                        Int("index", i).
                        Str("url", url).
                        Msg("URL from sitemap")
        }</span>

        <span class="cov0" title="0">if err := jm.enqueueURLsForJob(ctx, jobID, domain, urls, "sitemap"); err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("job_id", jobID).
                        Str("domain", domain).
                        Msg("Failed to enqueue sitemap URLs")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processSitemap fetches and processes a sitemap for a domain
func (jm *JobManager) processSitemap(ctx context.Context, jobID, domain string, includePaths, excludePaths []string) <span class="cov8" title="1">{
        // Guard against nil dependencies (e.g., in test environments)
        if jm.crawler == nil || jm.dbQueue == nil || jm.db == nil </span><span class="cov8" title="1">{
                log.Warn().
                        Str("job_id", jobID).
                        Str("domain", domain).
                        Msg("Skipping sitemap processing due to missing dependencies")
                return
        }</span>

        <span class="cov0" title="0">span := sentry.StartSpan(ctx, "manager.process_sitemap")
        defer span.Finish()

        span.SetTag("job_id", jobID)
        span.SetTag("domain", domain)

        log.Info().
                Str("job_id", jobID).
                Str("domain", domain).
                Msg("Starting sitemap processing")

        // Step 1: Discover and parse sitemaps
        urls, robotsRules, err := jm.discoverAndParseSitemaps(ctx, domain)
        if err != nil </span><span class="cov0" title="0">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                log.Error().
                        Err(err).
                        Str("job_id", jobID).
                        Str("domain", domain).
                        Msg("Failed to discover sitemaps")

                jm.updateJobWithError(ctx, jobID, fmt.Sprintf("Failed to discover sitemaps: %v", err))
                return
        }</span>

        // Step 2: Update domain crawl delay if present
        <span class="cov0" title="0">jm.updateDomainCrawlDelay(ctx, domain, robotsRules.CrawlDelay)

        // Step 3: Filter URLs against robots.txt and path patterns
        urls = jm.filterURLsAgainstRobots(urls, robotsRules, includePaths, excludePaths)

        // Step 4: Enqueue URLs or create fallback
        if len(urls) &gt; 0 </span><span class="cov0" title="0">{
                if err := jm.enqueueSitemapURLs(ctx, jobID, domain, urls); err != nil </span><span class="cov0" title="0">{
                        span.SetTag("error", "true")
                        span.SetData("error.message", err.Error())
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                if err := jm.enqueueFallbackURL(ctx, jobID, domain); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">//go:build unit || !integration

package jobs

import (
        "context"
        "database/sql"
        "time"

        "github.com/DATA-DOG/go-sqlmock"
        "github.com/Harvey-AU/blue-banded-bee/internal/crawler"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
)

// MockDbQueueWithTransaction implements DbQueueProvider for testing with sqlmock
// This helper is shared across multiple test files to avoid duplication
type MockDbQueueWithTransaction struct {
        db   *sql.DB
        mock sqlmock.Sqlmock
}

func (m *MockDbQueueWithTransaction) Execute(ctx context.Context, fn func(*sql.Tx) error) error <span class="cov8" title="1">{
        tx, err := m.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">err = fn(tx)
        if err != nil </span><span class="cov8" title="1">{
                tx.Rollback()
                return err
        }</span>
        
        <span class="cov8" title="1">return tx.Commit()</span>
}

func (m *MockDbQueueWithTransaction) EnqueueURLs(ctx context.Context, jobID string, pages []db.Page, sourceType string, sourceURL string) error <span class="cov0" title="0">{
        // Not needed for most tests - override in specific tests if needed
        return nil
}</span>

func (m *MockDbQueueWithTransaction) GetNextTask(ctx context.Context, jobIDs []string) (*db.Task, error) <span class="cov0" title="0">{
        // Not needed for most tests - override in specific tests if needed
        return nil, nil
}</span>

func (m *MockDbQueueWithTransaction) UpdateTaskStatus(ctx context.Context, taskID string, statusCode int, responseTime int, cacheStatus string, errorMsg string, contentType string) error <span class="cov0" title="0">{
        // Not needed for most tests - override in specific tests if needed
        return nil
}</span>

func (m *MockDbQueueWithTransaction) CleanupStuckJobs(ctx context.Context) error <span class="cov0" title="0">{
        // Not needed for most tests - override in specific tests if needed
        return nil
}</span>

// Helper functions for pointer creation
func intPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>

func float64Ptr(f float64) *float64 <span class="cov8" title="1">{
        return &amp;f
}</span>

// simpleDbQueueMock is a minimal mock implementation of DbQueueInterface for unit tests
type simpleDbQueueMock struct{}

func (m *simpleDbQueueMock) GetNextTask(ctx context.Context, jobID string) (*db.Task, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (m *simpleDbQueueMock) UpdateTaskStatus(ctx context.Context, task *db.Task) error <span class="cov0" title="0">{
        return nil
}</span>

func (m *simpleDbQueueMock) Execute(ctx context.Context, fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        return nil
}</span>

// simpleCrawlerMock is a minimal mock implementation of CrawlerInterface for unit tests
type simpleCrawlerMock struct{}

func (m *simpleCrawlerMock) WarmURL(ctx context.Context, url string, findLinks bool) (*crawler.CrawlResult, error) <span class="cov0" title="0">{
        return &amp;crawler.CrawlResult{
                StatusCode:  200,
                CacheStatus: "HIT",
        }, nil
}</span>

func (m *simpleCrawlerMock) DiscoverSitemapsAndRobots(ctx context.Context, domain string) (*crawler.SitemapDiscoveryResult, error) <span class="cov0" title="0">{
        return &amp;crawler.SitemapDiscoveryResult{}, nil
}</span>

func (m *simpleCrawlerMock) ParseSitemap(ctx context.Context, sitemapURL string) ([]string, error) <span class="cov0" title="0">{
        return []string{}, nil
}</span>

func (m *simpleCrawlerMock) FilterURLs(urls []string, includePaths, excludePaths []string) []string <span class="cov0" title="0">{
        return urls
}</span>

func (m *simpleCrawlerMock) GetUserAgent() string <span class="cov0" title="0">{
        return "test-agent"
}</span>

// MockWorkerPool is a minimal mock implementation of WorkerPool for testing
type MockWorkerPool struct {
        jobs           map[string]bool
        jobPerformance map[string]*JobPerformance
        stopCh         chan struct{}
        notifyCh       chan struct{}
        AddJobCalled   bool
        RemoveJobCalled bool
}

// NewMockWorkerPool creates a new mock worker pool
func NewMockWorkerPool() *MockWorkerPool <span class="cov0" title="0">{
        return &amp;MockWorkerPool{
                jobs:           make(map[string]bool),
                jobPerformance: make(map[string]*JobPerformance),
                stopCh:         make(chan struct{}),
                notifyCh:       make(chan struct{}, 1),
        }
}</span>

// AddJob simulates adding a job without database access
func (m *MockWorkerPool) AddJob(jobID string, options *JobOptions) <span class="cov0" title="0">{
        m.AddJobCalled = true
        m.jobs[jobID] = true
        m.jobPerformance[jobID] = &amp;JobPerformance{
                RecentTasks:  make([]int64, 0, 5),
                CurrentBoost: 0,
                LastCheck:    time.Now(),
        }
}</span>

// RemoveJob simulates removing a job
func (m *MockWorkerPool) RemoveJob(jobID string) <span class="cov0" title="0">{
        m.RemoveJobCalled = true
        delete(m.jobs, jobID)
        delete(m.jobPerformance, jobID)
}</pre>
		
		<pre class="file" id="file26" style="display: none">package jobs

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "math"
        "net/url"
        "runtime/debug"
        "strings"
        "sync"
        "sync/atomic"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/crawler"
        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/Harvey-AU/blue-banded-bee/internal/util"
        "github.com/getsentry/sentry-go"
        "github.com/jackc/pgx/v5"
        "github.com/rs/zerolog/log"
)

// JobPerformance tracks performance metrics for a specific job
type JobPerformance struct {
        RecentTasks  []int64   // Last 5 task response times for this job
        CurrentBoost int       // Current performance boost workers for this job
        LastCheck    time.Time // When we last evaluated this job
}

type WorkerPool struct {
        db               *sql.DB
        dbQueue          DbQueueInterface
        dbConfig         *db.Config
        crawler          CrawlerInterface
        numWorkers       int
        jobs             map[string]bool
        jobsMutex        sync.RWMutex
        stopCh           chan struct{}
        wg               sync.WaitGroup
        recoveryInterval time.Duration
        stopping         atomic.Bool
        activeJobs       sync.WaitGroup
        baseWorkerCount  int
        currentWorkers   int
        workersMutex     sync.RWMutex
        taskBatch        *TaskBatch
        batchTimer       *time.Ticker
        cleanupInterval  time.Duration
        notifyCh         chan struct{}
        jobManager       *JobManager // Reference to JobManager for duplicate checking

        // Performance scaling
        jobPerformance map[string]*JobPerformance
        perfMutex      sync.RWMutex

        // Job info cache to avoid repeated DB lookups
        jobInfoCache map[string]*JobInfo
        jobInfoMutex sync.RWMutex
}

// JobInfo caches job-specific data that doesn't change during execution
type JobInfo struct {
        DomainName  string
        FindLinks   bool
        CrawlDelay  int
        RobotsRules *crawler.RobotsRules // Cached robots.txt rules for URL filtering
}

// TaskBatch holds groups of tasks for batch processing
type TaskBatch struct {
        tasks     []*Task
        jobCounts map[string]struct {
                completed int
                failed    int
        }
        mu sync.Mutex
}

func NewWorkerPool(db *sql.DB, dbQueue DbQueueInterface, crawler CrawlerInterface, numWorkers int, dbConfig *db.Config) *WorkerPool <span class="cov8" title="1">{
        // Validate inputs
        if db == nil </span><span class="cov8" title="1">{
                panic("database connection is required")</span>
        }
        <span class="cov8" title="1">if dbQueue == nil </span><span class="cov8" title="1">{
                panic("database queue is required")</span>
        }
        <span class="cov8" title="1">if crawler == nil </span><span class="cov8" title="1">{
                panic("crawler is required")</span>
        }
        <span class="cov8" title="1">if numWorkers &lt; 1 </span><span class="cov8" title="1">{
                panic("numWorkers must be at least 1")</span>
        }
        <span class="cov8" title="1">if dbConfig == nil </span><span class="cov8" title="1">{
                panic("database configuration is required")</span>
        }

        <span class="cov8" title="1">wp := &amp;WorkerPool{
                db:              db,
                dbQueue:         dbQueue,
                dbConfig:        dbConfig,
                crawler:         crawler,
                numWorkers:      numWorkers,
                baseWorkerCount: numWorkers,
                currentWorkers:  numWorkers,
                jobs:            make(map[string]bool),

                stopCh:           make(chan struct{}),
                notifyCh:         make(chan struct{}, 1), // Buffer of 1 to prevent blocking
                recoveryInterval: 1 * time.Minute,
                taskBatch: &amp;TaskBatch{
                        tasks:     make([]*Task, 0, 50),
                        jobCounts: make(map[string]struct{ completed, failed int }),
                },
                batchTimer:      time.NewTicker(10 * time.Second),
                cleanupInterval: time.Minute,

                // Performance scaling
                jobPerformance: make(map[string]*JobPerformance),

                // Job info cache
                jobInfoCache: make(map[string]*JobInfo),
        }

        // Start the batch processor
        wp.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wp.wg.Done()
                wp.processBatches(context.Background())
        }</span>()

        // Start the notification listener
        <span class="cov8" title="1">wp.wg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer wp.wg.Done()
                wp.listenForNotifications(context.Background())
        }</span>()

        <span class="cov8" title="1">return wp</span>
}

func (wp *WorkerPool) Start(ctx context.Context) <span class="cov0" title="0">{
        log.Info().Int("workers", wp.numWorkers).Msg("Starting worker pool")

        for i := 0; i &lt; wp.numWorkers; i++ </span><span class="cov0" title="0">{
                i := i
                wp.wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wp.wg.Done()
                        wp.worker(ctx, i)
                }</span>()
        }

        // Start the recovery monitor
        <span class="cov0" title="0">wp.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wp.wg.Done()
                wp.recoveryMonitor(ctx)
        }</span>()

        // Run initial cleanup
        <span class="cov0" title="0">if err := wp.CleanupStuckJobs(ctx); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Error().Err(err).Msg("Failed to perform initial job cleanup")
        }</span>

        // Recover jobs that were running before restart
        <span class="cov0" title="0">if err := wp.recoverRunningJobs(ctx); err != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(err)
                log.Error().Err(err).Msg("Failed to recover running jobs on startup")
        }</span>

        <span class="cov0" title="0">wp.StartTaskMonitor(ctx)
        wp.StartCleanupMonitor(ctx)</span>
}

func (wp *WorkerPool) Stop() <span class="cov8" title="1">{
        // Only stop once - use atomic compare-and-swap to ensure thread safety
        if wp.stopping.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                log.Debug().Msg("Stopping worker pool")
                close(wp.stopCh)
                // Stop the batch timer to prevent leaks
                if wp.batchTimer != nil </span><span class="cov8" title="1">{
                        wp.batchTimer.Stop()
                }</span>
                <span class="cov8" title="1">wp.wg.Wait()
                log.Debug().Msg("Worker pool stopped")</span>
        }
}

// WaitForJobs waits for all active jobs to complete
func (wp *WorkerPool) WaitForJobs() <span class="cov0" title="0">{
        wp.activeJobs.Wait()
}</span>

func (wp *WorkerPool) AddJob(jobID string, options *JobOptions) <span class="cov0" title="0">{
        wp.jobsMutex.Lock()
        wp.jobs[jobID] = true
        wp.jobsMutex.Unlock()

        // Initialise performance tracking for this job
        wp.perfMutex.Lock()
        wp.jobPerformance[jobID] = &amp;JobPerformance{
                RecentTasks:  make([]int64, 0, 5),
                CurrentBoost: 0,
                LastCheck:    time.Now(),
        }
        wp.perfMutex.Unlock()

        // Cache job info to avoid repeated database lookups
        ctx := context.Background()
        var domainName string
        var crawlDelay sql.NullInt64
        var dbFindLinks bool
        
        // When options is nil (recovery mode), fetch find_links from DB
        // Otherwise use the provided options value
        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                query := `
                        SELECT d.name, d.crawl_delay_seconds, j.find_links
                        FROM domains d
                        JOIN jobs j ON j.domain_id = d.id
                        WHERE j.id = $1
                `
                return tx.QueryRowContext(ctx, query, jobID).Scan(&amp;domainName, &amp;crawlDelay, &amp;dbFindLinks)
        }</span>)

        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                // Use DB value when options is nil (recovery), otherwise use provided value
                findLinks := dbFindLinks
                if options != nil </span><span class="cov0" title="0">{
                        findLinks = options.FindLinks
                }</span>
                
                <span class="cov0" title="0">jobInfo := &amp;JobInfo{
                        DomainName: domainName,
                        FindLinks:  findLinks,
                        CrawlDelay: 0,
                }
                if crawlDelay.Valid </span><span class="cov0" title="0">{
                        jobInfo.CrawlDelay = int(crawlDelay.Int64)
                }</span>

                // Parse robots.txt to get filtering rules
                <span class="cov0" title="0">robotsRules, err := crawler.ParseRobotsTxt(ctx, domainName, wp.crawler.GetUserAgent())
                if err != nil </span><span class="cov0" title="0">{
                        log.Debug().
                                Err(err).
                                Str("domain", domainName).
                                Msg("Failed to parse robots.txt, proceeding without restrictions")
                        jobInfo.RobotsRules = &amp;crawler.RobotsRules{} // Empty rules = no restrictions
                }</span> else<span class="cov0" title="0"> {
                        jobInfo.RobotsRules = robotsRules
                }</span>

                <span class="cov0" title="0">wp.jobInfoMutex.Lock()
                wp.jobInfoCache[jobID] = jobInfo
                wp.jobInfoMutex.Unlock()

                log.Debug().
                        Str("job_id", jobID).
                        Str("domain", domainName).
                        Int("crawl_delay", jobInfo.CrawlDelay).
                        Int("disallow_patterns", len(jobInfo.RobotsRules.DisallowPatterns)).
                        Msg("Cached job info with robots rules")</span>
        } else<span class="cov0" title="0"> {
                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to cache job info")
        }</span>

        // Simple scaling: add 5 workers per job, maximum of 50 total
        <span class="cov0" title="0">wp.workersMutex.Lock()
        targetWorkers := min(wp.currentWorkers+5, 50)

        if targetWorkers &gt; wp.currentWorkers </span><span class="cov0" title="0">{
                wp.workersMutex.Unlock()
                wp.scaleWorkers(context.Background(), targetWorkers)
        }</span> else<span class="cov0" title="0"> {
                wp.workersMutex.Unlock()
        }</span>

        <span class="cov0" title="0">log.Debug().
                Str("job_id", jobID).
                Int("current_workers", wp.currentWorkers).
                Int("target_workers", targetWorkers).
                Msg("Added job to worker pool")</span>
}

func (wp *WorkerPool) RemoveJob(jobID string) <span class="cov8" title="1">{
        wp.jobsMutex.Lock()
        delete(wp.jobs, jobID)
        wp.jobsMutex.Unlock()

        // Remove performance boost for this job
        wp.perfMutex.Lock()
        var jobBoost int
        if perf, exists := wp.jobPerformance[jobID]; exists </span><span class="cov0" title="0">{
                jobBoost = perf.CurrentBoost
                delete(wp.jobPerformance, jobID)
        }</span>
        <span class="cov8" title="1">wp.perfMutex.Unlock()

        // Remove from job info cache
        wp.jobInfoMutex.Lock()
        delete(wp.jobInfoCache, jobID)
        wp.jobInfoMutex.Unlock()

        // Simple scaling: remove 5 workers per job + any performance boost, minimum of base count
        wp.workersMutex.Lock()
        targetWorkers := max(wp.currentWorkers-5-jobBoost, wp.baseWorkerCount)

        log.Debug().
                Str("job_id", jobID).
                Int("current_workers", wp.currentWorkers).
                Int("target_workers", targetWorkers).
                Int("job_boost_removed", jobBoost).
                Msg("Scaling down worker pool")

        wp.currentWorkers = targetWorkers
        // Note: We don't actually stop excess workers, they'll exit on next task completion
        wp.workersMutex.Unlock()

        log.Debug().
                Str("job_id", jobID).
                Msg("Removed job from worker pool")</span>
}

func (wp *WorkerPool) worker(ctx context.Context, workerID int) <span class="cov0" title="0">{
        log.Info().Int("worker_id", workerID).Msg("Starting worker")

        // Track consecutive no-task counts for backoff
        consecutiveNoTasks := 0
        maxSleep := 5 * time.Second         // Note: Changed from 30 to 5 seconds, to increase resonsiveness when inactive.
        baseSleep := 200 * time.Millisecond // Faster processing when active

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-wp.stopCh:<span class="cov0" title="0">
                        log.Debug().Int("worker_id", workerID).Msg("Worker received stop signal")
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Debug().Int("worker_id", workerID).Msg("Worker context cancelled")
                        return</span>
                case &lt;-wp.notifyCh:<span class="cov0" title="0">
                        // Reset backoff when notified of new tasks
                        consecutiveNoTasks = 0</span>
                default:<span class="cov0" title="0">
                        // Check if this worker should exit (we've scaled down)
                        wp.workersMutex.RLock()
                        shouldExit := workerID &gt;= wp.currentWorkers
                        wp.workersMutex.RUnlock()

                        if shouldExit </span><span class="cov0" title="0">{
                                return
                        }</span>

                        <span class="cov0" title="0">if err := wp.processNextTask(ctx); err != nil </span><span class="cov0" title="0">{
                                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                        consecutiveNoTasks++
                                        // Only log occasionally during quiet periods
                                        if consecutiveNoTasks == 1 || consecutiveNoTasks%10 == 0 </span><span class="cov0" title="0">{
                                                log.Debug().Msg("Waiting for new tasks")
                                        }</span>
                                        // Exponential backoff with a maximum
                                        <span class="cov0" title="0">sleepTime := min(time.Duration(float64(baseSleep)*math.Pow(1.5, float64(min(consecutiveNoTasks, 10)))), maxSleep)

                                        // Wait for either the backoff duration or a notification
                                        select </span>{
                                        case &lt;-time.After(sleepTime):<span class="cov0" title="0"></span>
                                        case &lt;-wp.notifyCh:<span class="cov0" title="0">
                                                consecutiveNoTasks = 0</span>
                                        case &lt;-wp.stopCh:<span class="cov0" title="0">
                                                return</span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                } else<span class="cov0" title="0"> {
                                        log.Error().Err(err).Int("worker_id", workerID).Msg("Failed to process task")
                                        time.Sleep(baseSleep)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                consecutiveNoTasks = 0
                                // Quick sleep between tasks when active
                                time.Sleep(baseSleep)
                        }</span>
                }
        }
}

// claimPendingTask attempts to claim a pending task from any active job
func (wp *WorkerPool) claimPendingTask(ctx context.Context) (*db.Task, error) <span class="cov8" title="1">{
        // Get the list of active jobs
        wp.jobsMutex.RLock()
        activeJobs := make([]string, 0, len(wp.jobs))
        for jobID := range wp.jobs </span><span class="cov8" title="1">{
                activeJobs = append(activeJobs, jobID)
        }</span>
        <span class="cov8" title="1">wp.jobsMutex.RUnlock()

        // If no active jobs, return immediately
        if len(activeJobs) == 0 </span><span class="cov8" title="1">{
                return nil, sql.ErrNoRows
        }</span>

        // Try to get a task from each active job
        <span class="cov8" title="1">for _, jobID := range activeJobs </span><span class="cov8" title="1">{
                task, err := wp.dbQueue.GetNextTask(ctx, jobID)
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        continue</span> // Try next job
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        log.Error().Err(err).Str("job_id", jobID).Msg("Error getting next pending task")
                        return nil, err // Return actual errors
                }</span>
                <span class="cov8" title="1">if task != nil </span><span class="cov8" title="1">{
                        log.Info().
                                Str("task_id", task.ID).
                                Str("job_id", task.JobID).
                                Int("page_id", task.PageID).
                                Str("path", task.Path).
                                Float64("priority", task.PriorityScore).
                                Msg("Found and claimed pending task")
                        return task, nil
                }</span>
        }

        // No tasks found in any job
        <span class="cov8" title="1">return nil, sql.ErrNoRows</span>
}

// prepareTaskForProcessing converts db.Task to jobs.Task and enriches with job info
func (wp *WorkerPool) prepareTaskForProcessing(ctx context.Context, task *db.Task) (*Task, error) <span class="cov8" title="1">{
        // Convert db.Task to jobs.Task for processing
        jobsTask := &amp;Task{
                ID:            task.ID,
                JobID:         task.JobID,
                PageID:        task.PageID,
                Path:          task.Path,
                Status:        TaskStatus(task.Status),
                CreatedAt:     task.CreatedAt,
                StartedAt:     task.StartedAt,
                RetryCount:    task.RetryCount,
                SourceType:    task.SourceType,
                SourceURL:     task.SourceURL,
                PriorityScore: task.PriorityScore,
        }

        // Get job info from cache
        wp.jobInfoMutex.RLock()
        jobInfo, exists := wp.jobInfoCache[task.JobID]
        wp.jobInfoMutex.RUnlock()

        if exists </span><span class="cov8" title="1">{
                jobsTask.DomainName = jobInfo.DomainName
                jobsTask.FindLinks = jobInfo.FindLinks
                jobsTask.CrawlDelay = jobInfo.CrawlDelay
        }</span> else<span class="cov8" title="1"> {
                // Fallback to database if not in cache (shouldn't happen normally)
                log.Warn().Str("job_id", task.JobID).Msg("Job info not in cache, querying database")

                var domainName string
                var findLinks bool
                var crawlDelay sql.NullInt64
                err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                        return tx.QueryRowContext(ctx, `
                                SELECT d.name, j.find_links, d.crawl_delay_seconds
                                FROM domains d
                                JOIN jobs j ON j.domain_id = d.id
                                WHERE j.id = $1
                        `, task.JobID).Scan(&amp;domainName, &amp;findLinks, &amp;crawlDelay)
                }</span>)

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        log.Error().Err(err).Str("job_id", task.JobID).Msg("Failed to get domain info")
                }</span> else<span class="cov8" title="1"> {
                        jobsTask.DomainName = domainName
                        jobsTask.FindLinks = findLinks
                        if crawlDelay.Valid </span><span class="cov0" title="0">{
                                jobsTask.CrawlDelay = int(crawlDelay.Int64)
                        }</span>
                }
        }

        <span class="cov8" title="1">return jobsTask, nil</span>
}

func (wp *WorkerPool) processNextTask(ctx context.Context) error <span class="cov8" title="1">{
        // Claim a pending task from active jobs
        task, err := wp.claimPendingTask(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if task != nil </span><span class="cov8" title="1">{
                // Prepare task for processing with job info
                jobsTask, err := wp.prepareTaskForProcessing(ctx, task)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("task_id", task.ID).Msg("Failed to prepare task")
                        return err
                }</span>

                        // Process the task
                        <span class="cov8" title="1">result, err := wp.processTask(ctx, jobsTask)
                        if err != nil </span><span class="cov0" title="0">{
                                return wp.handleTaskError(ctx, task, err)
                        }</span> else<span class="cov8" title="1"> {
                                return wp.handleTaskSuccess(ctx, task, result)
                        }</span>
        }

        // No tasks found in any active jobs
        <span class="cov0" title="0">return sql.ErrNoRows</span>
}

// EnqueueURLs is a wrapper that ensures all task enqueuing goes through the JobManager.
// This allows for centralised logic, such as duplicate checking, to be applied.
func (wp *WorkerPool) EnqueueURLs(ctx context.Context, jobID string, pages []db.Page, sourceType string, sourceURL string) error <span class="cov0" title="0">{
        log.Debug().
                Str("job_id", jobID).
                Str("source_type", sourceType).
                Int("url_count", len(pages)).
                Msg("EnqueueURLs called via WorkerPool, passing to JobManager")

        // The jobManager must be set for the worker pool to function correctly.
        if wp.jobManager == nil </span><span class="cov0" title="0">{
                err := fmt.Errorf("jobManager is not set on WorkerPool - cannot enqueue URLs")
                log.Error().Err(err).Msg("Failed to enqueue URLs")
                return err
        }</span>

        <span class="cov0" title="0">return wp.jobManager.EnqueueJobURLs(ctx, jobID, pages, sourceType, sourceURL)</span>
}

// StartTaskMonitor starts a background process that monitors for pending tasks
func (wp *WorkerPool) StartTaskMonitor(ctx context.Context) <span class="cov0" title="0">{
        log.Info().Msg("Starting task monitor to check for pending tasks")
        wp.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wp.wg.Done()
                ticker := time.NewTicker(30 * time.Second)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                log.Info().Msg("Task monitor stopped due to context cancellation")
                                return</span>
                        case &lt;-wp.stopCh:<span class="cov0" title="0">
                                log.Info().Msg("Task monitor stopped due to stop signal")
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                log.Debug().Msg("Task monitor checking for pending tasks")
                                if err := wp.checkForPendingTasks(ctx); err != nil </span><span class="cov0" title="0">{
                                        log.Error().Err(err).Msg("Error checking for pending tasks")
                                }</span>
                        }
                }
        }()

        <span class="cov0" title="0">log.Info().Msg("Task monitor started successfully")</span>
}

// checkForPendingTasks looks for any pending tasks and adds their jobs to the pool
func (wp *WorkerPool) checkForPendingTasks(ctx context.Context) error <span class="cov0" title="0">{
        log.Debug().Msg("Checking database for jobs with pending tasks")
        
        var jobIDs []string
        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // Query for jobs with pending tasks
                rows, err := tx.QueryContext(ctx, `
                        SELECT DISTINCT job_id FROM tasks 
                        WHERE status = $1 
                        LIMIT 100
                `, TaskStatusPending)
                
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                
                for rows.Next() </span><span class="cov0" title="0">{
                        var jobID string
                        if err := rows.Scan(&amp;jobID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">jobIDs = append(jobIDs, jobID)</span>
                }
                <span class="cov0" title="0">return rows.Err()</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to query for jobs with pending tasks")
                return err
        }</span>

        <span class="cov0" title="0">jobsFound := len(jobIDs)
        foundIDs := jobIDs
        // For each job with pending tasks, add it to the worker pool
        for _, jobID := range jobIDs </span><span class="cov0" title="0">{
                // Check if already in our active jobs
                wp.jobsMutex.RLock()
                active := wp.jobs[jobID]
                wp.jobsMutex.RUnlock()

                if !active </span><span class="cov0" title="0">{
                        // Add job to the worker pool
                        log.Info().Str("job_id", jobID).Msg("Adding job with pending tasks to worker pool")

                        // Get job options
                        var findLinks bool
                        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                                return tx.QueryRowContext(ctx, `
                                        SELECT find_links FROM jobs WHERE id = $1
                                `, jobID).Scan(&amp;findLinks)
                        }</span>)

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to get job options")
                                continue</span>
                        }

                        <span class="cov0" title="0">options := &amp;JobOptions{
                                FindLinks: findLinks,
                        }

                        wp.AddJob(jobID, options)

                        // Update job status if needed
                        err = wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                                _, err := tx.ExecContext(ctx, `
                                        UPDATE jobs SET
                                                status = $1,
                                                started_at = CASE WHEN started_at IS NULL THEN $2 ELSE started_at END
                                        WHERE id = $3 AND status = $4
                                `, JobStatusRunning, time.Now(), jobID, JobStatusPending)
                                return err
                        }</span>)

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Str("job_id", jobID).Msg("Failed to update job status")
                        }</span> else<span class="cov0" title="0"> {
                                log.Info().Str("job_id", jobID).Msg("Updated job status to running")
                        }</span>
                } else<span class="cov0" title="0"> {
                        log.Debug().Str("job_id", jobID).Msg("Job already active in worker pool")
                }</span>
        }

        <span class="cov0" title="0">if jobsFound == 0 </span><span class="cov0" title="0">{
                log.Debug().Msg("No jobs with pending tasks found")
        }</span> else<span class="cov0" title="0"> {
                log.Debug().Int("count", jobsFound).Msg("Found jobs with pending tasks")
        }</span>

        <span class="cov0" title="0">foundSet := make(map[string]struct{}, len(foundIDs))
        for _, id := range foundIDs </span><span class="cov0" title="0">{
                foundSet[id] = struct{}{}
        }</span>
        <span class="cov0" title="0">var toRemove []string
        wp.jobsMutex.RLock()
        for jobID := range wp.jobs </span><span class="cov0" title="0">{
                if _, ok := foundSet[jobID]; !ok </span><span class="cov0" title="0">{
                        toRemove = append(toRemove, jobID)
                }</span>
        }
        <span class="cov0" title="0">wp.jobsMutex.RUnlock()
        for _, id := range toRemove </span><span class="cov0" title="0">{
                log.Info().Str("job_id", id).Msg("Job has no pending tasks, removing from worker pool")
                wp.RemoveJob(id)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// SetJobManager sets the JobManager reference for duplicate task checking
func (wp *WorkerPool) SetJobManager(jm *JobManager) <span class="cov0" title="0">{
        wp.jobManager = jm
}</span>

// recoverStaleTasks checks for and resets stale tasks
func (wp *WorkerPool) recoverStaleTasks(ctx context.Context) error <span class="cov0" title="0">{
        return wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                staleTime := time.Now().Add(-TaskStaleTimeout)

                // Get stale tasks
                rows, err := tx.QueryContext(ctx, `
                        SELECT t.id, t.job_id, t.page_id, p.path, t.retry_count 
                        FROM tasks t
                        JOIN pages p ON t.page_id = p.id
                        WHERE status = $1 
                        AND started_at &lt; $2
                `, TaskStatusRunning, staleTime)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()

                for rows.Next() </span><span class="cov0" title="0">{
                        var taskID, jobID string
                        var pageID int
                        var path string
                        var retryCount int
                        if err := rows.Scan(&amp;taskID, &amp;jobID, &amp;pageID, &amp;path, &amp;retryCount); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if retryCount &gt;= MaxTaskRetries </span><span class="cov0" title="0">{
                                // Mark as failed if max retries exceeded
                                _, err = tx.ExecContext(ctx, `
                                        UPDATE tasks 
                                        SET status = $1,
                                                error = $2,
                                                completed_at = $3
                                        WHERE id = $4
                                `, TaskStatusFailed, "Max retries exceeded", time.Now(), taskID)
                        }</span> else<span class="cov0" title="0"> {
                                // Reset to pending for retry
                                _, err = tx.ExecContext(ctx, `
                                        UPDATE tasks 
                                        SET status = $1,
                                                started_at = NULL,
                                                retry_count = retry_count + 1
                                        WHERE id = $2
                                `, TaskStatusPending, taskID)
                        }</span>

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).
                                        Str("task_id", taskID).
                                        Msg("Failed to update stale task")
                        }</span>
                }

                <span class="cov0" title="0">return rows.Err()</span>
        })
}

// recoverRunningJobs finds jobs that were in 'running' state when the server shut down
// and resets their 'running' tasks to 'pending', then adds them to the worker pool
func (wp *WorkerPool) recoverRunningJobs(ctx context.Context) error <span class="cov0" title="0">{
        log.Info().Msg("Recovering jobs that were running before restart")

        var jobIDs []string
        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // Find jobs with 'running' status that have 'running' tasks
                rows, err := tx.QueryContext(ctx, `
                        SELECT DISTINCT j.id
                        FROM jobs j
                        JOIN tasks t ON j.id = t.job_id
                        WHERE j.status = $1
                        AND t.status = $2
                `, JobStatusRunning, TaskStatusRunning)
                
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer rows.Close()
                
                for rows.Next() </span><span class="cov0" title="0">{
                        var jobID string
                        if err := rows.Scan(&amp;jobID); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">jobIDs = append(jobIDs, jobID)</span>
                }
                
                <span class="cov0" title="0">return rows.Err()</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Msg("Failed to query for running jobs with running tasks")
                return err
        }</span>

        <span class="cov0" title="0">var recoveredJobs []string
        for _, jobID := range jobIDs </span><span class="cov0" title="0">{

                // Reset running tasks to pending for this job
                err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                        result, err := tx.ExecContext(ctx, `
                                UPDATE tasks 
                                SET status = $1,
                                        started_at = NULL,
                                        retry_count = retry_count + 1
                                WHERE job_id = $2 
                                AND status = $3
                        `, TaskStatusPending, jobID, TaskStatusRunning)

                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
                        log.Info().
                                Str("job_id", jobID).
                                Int64("tasks_reset", rowsAffected).
                                Msg("Reset running tasks to pending")

                        return nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("job_id", jobID).Msg("Failed to reset running tasks")
                        continue</span>
                }

                // Add job back to worker pool
                <span class="cov0" title="0">wp.AddJob(jobID, nil)
                recoveredJobs = append(recoveredJobs, jobID)

                log.Info().Str("job_id", jobID).Msg("Recovered running job and added to worker pool")</span>
        }

        <span class="cov0" title="0">if len(recoveredJobs) &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Int("count", len(recoveredJobs)).
                        Strs("job_ids", recoveredJobs).
                        Msg("Successfully recovered running jobs from restart")
        }</span> else<span class="cov0" title="0"> {
                log.Debug().Msg("No running jobs found to recover")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// recoveryMonitor periodically checks for and recovers stale tasks
func (wp *WorkerPool) recoveryMonitor(ctx context.Context) <span class="cov0" title="0">{
        ticker := time.NewTicker(wp.recoveryInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-wp.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := wp.recoverStaleTasks(ctx); err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msg("Failed to recover stale tasks")
                        }</span>
                }
        }
}

// scaleWorkers increases the worker pool size to the target number
func (wp *WorkerPool) scaleWorkers(ctx context.Context, targetWorkers int) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        log.Error().
                                Interface("panic", r).
                                Str("stack", string(debug.Stack())).
                                Msg("Recovered from panic in scaleWorkers")
                }</span>
        }()

        <span class="cov0" title="0">wp.workersMutex.Lock()
        defer wp.workersMutex.Unlock()

        if targetWorkers &lt;= wp.currentWorkers </span><span class="cov0" title="0">{
                return // No need to scale up
        }</span>

        <span class="cov0" title="0">workersToAdd := targetWorkers - wp.currentWorkers

        log.Debug().
                Int("current_workers", wp.currentWorkers).
                Int("adding_workers", workersToAdd).
                Int("target_workers", targetWorkers).
                Msg("Scaling worker pool")

        // Start additional workers
        for i := 0; i &lt; workersToAdd; i++ </span><span class="cov0" title="0">{
                workerID := wp.currentWorkers + i
                wp.wg.Add(1)
                go func(id int) </span><span class="cov0" title="0">{
                        defer wp.wg.Done()
                        wp.worker(ctx, id)
                }</span>(workerID)
        }

        <span class="cov0" title="0">wp.currentWorkers = targetWorkers</span>
}

// Batch processor goroutine
func (wp *WorkerPool) processBatches(ctx context.Context) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-wp.batchTimer.C:<span class="cov0" title="0">
                        wp.flushBatches(ctx)</span>
                case &lt;-wp.stopCh:<span class="cov8" title="1">
                        wp.flushBatches(ctx) // Final flush before shutdown
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// Flush collected tasks in a batch
func (wp *WorkerPool) flushBatches(ctx context.Context) <span class="cov8" title="1">{
        wp.taskBatch.mu.Lock()
        tasks := wp.taskBatch.tasks
        jobCounts := wp.taskBatch.jobCounts

        // Reset batches
        wp.taskBatch.tasks = make([]*Task, 0, 50)
        wp.taskBatch.jobCounts = make(map[string]struct{ completed, failed int })
        wp.taskBatch.mu.Unlock()

        if len(tasks) == 0 </span><span class="cov8" title="1">{
                return // Nothing to flush
        }</span>

        // Process the batch in a single transaction
        <span class="cov0" title="0">batchStart := time.Now()
        log.Debug().
                Int("batch_size", len(tasks)).
                Int("job_count", len(jobCounts)).
                Time("batch_update_start", batchStart).
                Msg("⏱️ TIMING: Starting batch DB update")

        // Execute everything in ONE queue operation instead of separate ones
        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // 1. Update all tasks in a single statement with CASE
                if len(tasks) &gt; 0 </span><span class="cov0" title="0">{
                        taskUpdateStart := time.Now()
                        stmt, err := tx.PrepareContext(ctx, `
                                UPDATE tasks
                                SET status = $1, 
                                        completed_at = $2,
                                        error = $3 -- Only include error (for failure reason)
                                WHERE id = $4
                        `)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">defer stmt.Close()

                        for _, task := range tasks </span><span class="cov0" title="0">{
                                if task.Status == TaskStatusCompleted || task.Status == TaskStatusFailed </span><span class="cov0" title="0">{
                                        if task.CompletedAt.IsZero() </span><span class="cov0" title="0">{
                                                task.CompletedAt = time.Now().UTC()
                                        }</span>
                                        <span class="cov0" title="0">_, err := stmt.ExecContext(ctx,
                                                task.Status, task.CompletedAt,
                                                task.Error, task.ID)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }
                        }
                        <span class="cov0" title="0">log.Debug().
                                Dur("task_update_duration_ms", time.Since(taskUpdateStart)).
                                Int("task_count", len(tasks)).
                                Msg("⏱️ TIMING: Completed batch task updates")</span>
                }

                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">batchDuration := time.Since(batchStart)
        log.Debug().
                Int("task_count", len(tasks)).
                Int("job_count", len(jobCounts)).
                Dur("batch_duration_ms", batchDuration).
                Time("batch_completed", time.Now()).
                Bool("success", err == nil).
                Msg("⏱️ TIMING: Batch DB update completed")

        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Int("task_count", len(tasks)).Msg("Failed to process task batch")
        }</span>
}

// Add new method to start the cleanup monitor
func (wp *WorkerPool) StartCleanupMonitor(ctx context.Context) <span class="cov0" title="0">{
        wp.wg.Add(1)
        go func() </span><span class="cov0" title="0">{
                defer wp.wg.Done()
                ticker := time.NewTicker(wp.cleanupInterval)
                defer ticker.Stop()

                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        case &lt;-wp.stopCh:<span class="cov0" title="0">
                                return</span>
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                if err := wp.CleanupStuckJobs(ctx); err != nil </span><span class="cov0" title="0">{
                                        log.Error().Err(err).Msg("Failed to cleanup stuck jobs")
                                }</span>
                        }
                }
        }()
        <span class="cov0" title="0">log.Info().Msg("Job cleanup monitor started")</span>
}

// CleanupStuckJobs finds and fixes jobs that are stuck in pending/running state
// despite having all their tasks completed
func (wp *WorkerPool) CleanupStuckJobs(ctx context.Context) error <span class="cov0" title="0">{
        span := sentry.StartSpan(ctx, "jobs.cleanup_stuck_jobs")
        defer span.Finish()

        var rowsAffected int64
        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                result, err := tx.ExecContext(ctx, `
                        UPDATE jobs 
                        SET status = $1, 
                                completed_at = COALESCE(completed_at, $2),
                                progress = 100.0
                        WHERE (status = $3 OR status = $4)
                        AND total_tasks &gt; 0 
                        AND total_tasks = completed_tasks + failed_tasks
                `, JobStatusCompleted, time.Now(), JobStatusPending, JobStatusRunning)
                
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">rowsAffected, err = result.RowsAffected()
                return err</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                span.SetTag("error", "true")
                span.SetData("error.message", err.Error())
                return fmt.Errorf("failed to cleanup stuck jobs: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Int64("jobs_fixed", rowsAffected).
                        Msg("Fixed stuck jobs")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// processTask processes an individual task
// constructTaskURL builds a proper URL from task path and domain information
func constructTaskURL(path, domainName string) string <span class="cov8" title="1">{
        // Check if path is already a full URL
        if strings.HasPrefix(path, "http://") || strings.HasPrefix(path, "https://") </span><span class="cov8" title="1">{
                return util.NormaliseURL(path)
        }</span> else<span class="cov8" title="1"> if domainName != "" </span><span class="cov8" title="1">{
                // Use centralized URL construction
                return util.ConstructURL(domainName, path)
        }</span> else<span class="cov8" title="1"> {
                // Fallback case - assume path is a full URL but missing protocol
                return util.NormaliseURL(path)
        }</span>
}

// applyCrawlDelay applies robots.txt crawl delay if specified for the task's domain
func applyCrawlDelay(task *Task) <span class="cov8" title="1">{
        if task.CrawlDelay &gt; 0 </span><span class="cov8" title="1">{
                log.Debug().
                        Str("task_id", task.ID).
                        Str("domain", task.DomainName).
                        Int("crawl_delay_seconds", task.CrawlDelay).
                        Msg("Applying crawl delay from robots.txt")
                time.Sleep(time.Duration(task.CrawlDelay) * time.Second)
        }</span>
}

// processDiscoveredLinks handles link processing and enqueueing for discovered URLs
func (wp *WorkerPool) processDiscoveredLinks(ctx context.Context, task *Task, result *crawler.CrawlResult, sourceURL string) <span class="cov0" title="0">{
        log.Debug().
                Str("task_id", task.ID).
                Int("total_links_found", len(result.Links["header"])+len(result.Links["footer"])+len(result.Links["body"])).
                Bool("find_links_enabled", task.FindLinks).
                Msg("Starting link processing and priority assignment")

        // Get domain ID for this job
        var domainID int
        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                return tx.QueryRowContext(ctx, `
                        SELECT domain_id FROM jobs WHERE id = $1
                `, task.JobID).Scan(&amp;domainID)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Error().
                        Err(err).
                        Str("job_id", task.JobID).
                        Msg("Failed to get domain ID for discovered links")
                return
        }</span>

        // Get robots rules from cache for URL filtering
        <span class="cov0" title="0">var robotsRules *crawler.RobotsRules
        wp.jobInfoMutex.RLock()
        if jobInfo, exists := wp.jobInfoCache[task.JobID]; exists </span><span class="cov0" title="0">{
                robotsRules = jobInfo.RobotsRules
        }</span>
        <span class="cov0" title="0">wp.jobInfoMutex.RUnlock()

        isHomepage := task.Path == "/"

        processLinkCategory := func(links []string, priority float64) </span><span class="cov0" title="0">{
                if len(links) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                // 1. Filter links for same-domain and robots.txt compliance
                <span class="cov0" title="0">var filtered []string
                var blockedCount int
                for _, link := range links </span><span class="cov0" title="0">{
                        linkURL, err := url.Parse(link)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if isSameOrSubDomain(linkURL.Hostname(), task.DomainName) </span><span class="cov0" title="0">{
                                linkURL.Fragment = ""
                                if linkURL.Path != "/" &amp;&amp; strings.HasSuffix(linkURL.Path, "/") </span><span class="cov0" title="0">{
                                        linkURL.Path = strings.TrimSuffix(linkURL.Path, "/")
                                }</span>

                                // Check robots.txt rules
                                <span class="cov0" title="0">if robotsRules != nil &amp;&amp; !crawler.IsPathAllowed(robotsRules, linkURL.Path) </span><span class="cov0" title="0">{
                                        blockedCount++
                                        log.Debug().
                                                Str("url", linkURL.String()).
                                                Str("path", linkURL.Path).
                                                Str("source", sourceURL).
                                                Msg("Link blocked by robots.txt")
                                        continue</span>
                                }

                                <span class="cov0" title="0">filtered = append(filtered, linkURL.String())</span>
                        }
                }

                <span class="cov0" title="0">if blockedCount &gt; 0 </span><span class="cov0" title="0">{
                        log.Info().
                                Str("task_id", task.ID).
                                Int("blocked_count", blockedCount).
                                Int("allowed_count", len(filtered)).
                                Msg("Filtered discovered links against robots.txt")
                }</span>

                <span class="cov0" title="0">if len(filtered) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                // 2. Create page records
                <span class="cov0" title="0">pageIDs, paths, err := db.CreatePageRecords(ctx, wp.dbQueue, domainID, task.DomainName, filtered)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to create page records for links")
                        return
                }</span>

                // 3. Create a slice of db.Page for enqueuing
                <span class="cov0" title="0">pagesToEnqueue := make([]db.Page, len(pageIDs))
                for i := range pageIDs </span><span class="cov0" title="0">{
                        pagesToEnqueue[i] = db.Page{
                                ID:   pageIDs[i],
                                Path: paths[i],
                                // Priority will be set by the caller of processLinkCategory
                        }
                }</span>

                // 4. Enqueue new tasks
                <span class="cov0" title="0">if err := wp.EnqueueURLs(ctx, task.JobID, pagesToEnqueue, "link", sourceURL); err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to enqueue discovered links")
                        return // Stop if enqueuing fails
                }</span>

                // 5. Update priorities for the newly created tasks
                <span class="cov0" title="0">if err := wp.updateTaskPriorities(ctx, task.JobID, domainID, priority, paths); err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Failed to update task priorities for discovered links")
                }</span>
        }

        // Apply priorities based on page type and link category
        <span class="cov0" title="0">if isHomepage </span><span class="cov0" title="0">{
                log.Debug().Str("task_id", task.ID).Msg("Processing links from HOMEPAGE")
                processLinkCategory(result.Links["header"], 1.000)
                processLinkCategory(result.Links["footer"], 0.990)
                processLinkCategory(result.Links["body"], task.PriorityScore*0.9) // Children of homepage
        }</span> else<span class="cov0" title="0"> {
                log.Debug().Str("task_id", task.ID).Msg("Processing links from regular page")
                // For all other pages, only process body links
                processLinkCategory(result.Links["body"], task.PriorityScore*0.9) // Children of other pages
        }</span>
}

// handleTaskError processes task failures with appropriate retry logic and status updates
func (wp *WorkerPool) handleTaskError(ctx context.Context, task *db.Task, taskErr error) error <span class="cov0" title="0">{
        now := time.Now()
        
        // Check if this is a blocking error (403/429)
        if isBlockingError(taskErr) </span><span class="cov0" title="0">{
                // For blocking errors, only retry twice (less aggressive)
                if task.RetryCount &lt; 2 </span><span class="cov0" title="0">{
                        task.RetryCount++
                        task.Status = string(TaskStatusPending)
                        task.StartedAt = time.Time{} // Reset started time
                        log.Warn().
                                Err(taskErr).
                                Str("task_id", task.ID).
                                Int("retry_count", task.RetryCount).
                                Msg("Task blocked (403/429), limited retry scheduled")
                }</span> else<span class="cov0" title="0"> {
                        // Mark as permanently failed after 2 retries
                        task.Status = string(TaskStatusFailed)
                        task.CompletedAt = now
                        task.Error = taskErr.Error()
                        log.Error().
                                Err(taskErr).
                                Str("task_id", task.ID).
                                Int("retry_count", task.RetryCount).
                                Msg("Task blocked permanently after 2 retries")
                }</span>
        } else<span class="cov0" title="0"> if isRetryableError(taskErr) &amp;&amp; task.RetryCount &lt; MaxTaskRetries </span><span class="cov0" title="0">{
                // For other retryable errors, use normal retry limit
                task.RetryCount++
                task.Status = string(TaskStatusPending)
                task.StartedAt = time.Time{} // Reset started time
                log.Warn().
                        Err(taskErr).
                        Str("task_id", task.ID).
                        Int("retry_count", task.RetryCount).
                        Msg("Task failed with retryable error, scheduling retry")
        }</span> else<span class="cov0" title="0"> {
                // Mark as permanently failed
                task.Status = string(TaskStatusFailed)
                task.CompletedAt = now
                task.Error = taskErr.Error()
                log.Error().
                        Err(taskErr).
                        Str("task_id", task.ID).
                        Int("retry_count", task.RetryCount).
                        Msg("Task failed permanently")
        }</span>
        
        // Update task status in database
        <span class="cov0" title="0">updErr := wp.dbQueue.UpdateTaskStatus(ctx, task)
        if updErr != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(updErr)
                log.Error().Err(updErr).Str("task_id", task.ID).Msg("Failed to mark task as failed")
        }</span>
        
        <span class="cov0" title="0">return updErr</span>
}

// handleTaskSuccess processes successful task completion with metrics and database updates
func (wp *WorkerPool) handleTaskSuccess(ctx context.Context, task *db.Task, result *crawler.CrawlResult) error <span class="cov8" title="1">{
        now := time.Now()
        
        // Mark as completed with basic metrics
        task.Status = string(TaskStatusCompleted)
        task.CompletedAt = now
        task.StatusCode = result.StatusCode
        task.ResponseTime = result.ResponseTime
        task.CacheStatus = result.CacheStatus
        task.ContentType = result.ContentType
        task.ContentLength = result.ContentLength
        task.RedirectURL = result.RedirectURL

        // Performance metrics
        task.DNSLookupTime = result.Performance.DNSLookupTime
        task.TCPConnectionTime = result.Performance.TCPConnectionTime
        task.TLSHandshakeTime = result.Performance.TLSHandshakeTime
        task.TTFB = result.Performance.TTFB
        task.ContentTransferTime = result.Performance.ContentTransferTime

        // Second request metrics
        task.SecondResponseTime = result.SecondResponseTime
        task.SecondCacheStatus = result.SecondCacheStatus
        if result.SecondPerformance != nil </span><span class="cov8" title="1">{
                task.SecondContentLength = result.SecondContentLength
                task.SecondDNSLookupTime = result.SecondPerformance.DNSLookupTime
                task.SecondTCPConnectionTime = result.SecondPerformance.TCPConnectionTime
                task.SecondTLSHandshakeTime = result.SecondPerformance.TLSHandshakeTime
                task.SecondTTFB = result.SecondPerformance.TTFB
                task.SecondContentTransferTime = result.SecondPerformance.ContentTransferTime
        }</span>

        // Marshal JSONB fields
        <span class="cov8" title="1">var err error
        task.Headers, err = json.Marshal(result.Headers)
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Err(err).Str("task_id", task.ID).Msg("Failed to marshal headers")
        }</span>
        <span class="cov8" title="1">if result.SecondHeaders != nil </span><span class="cov0" title="0">{
                task.SecondHeaders, err = json.Marshal(result.SecondHeaders)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("task_id", task.ID).Msg("Failed to marshal second headers")
                }</span>
        }
        <span class="cov8" title="1">if result.CacheCheckAttempts != nil </span><span class="cov0" title="0">{
                task.CacheCheckAttempts, err = json.Marshal(result.CacheCheckAttempts)
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Str("task_id", task.ID).Msg("Failed to marshal cache check attempts")
                }</span>
        }

        // Update task status in database
        <span class="cov8" title="1">updErr := wp.dbQueue.UpdateTaskStatus(ctx, task)
        if updErr != nil </span><span class="cov0" title="0">{
                sentry.CaptureException(updErr)
                log.Error().Err(updErr).Str("task_id", task.ID).Msg("Failed to mark task as completed")
        }</span>

        // Evaluate job performance for scaling
        <span class="cov8" title="1">if result.ResponseTime &gt; 0 </span><span class="cov8" title="1">{
                wp.evaluateJobPerformance(task.JobID, result.ResponseTime)
        }</span>
        
        <span class="cov8" title="1">return updErr</span>
}

func (wp *WorkerPool) processTask(ctx context.Context, task *Task) (*crawler.CrawlResult, error) <span class="cov8" title="1">{
        // Construct a proper URL for processing
        urlStr := constructTaskURL(task.Path, task.DomainName)

        log.Info().Str("url", urlStr).Str("task_id", task.ID).Msg("Starting URL warm")

        // Apply crawl delay if specified for this domain
        applyCrawlDelay(task)

        result, err := wp.crawler.WarmURL(ctx, urlStr, task.FindLinks)
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Str("task_id", task.ID).Msg("Crawler failed")
                return result, fmt.Errorf("crawler error: %w", err)
        }</span>
        <span class="cov8" title="1">log.Info().
                Int("status_code", result.StatusCode).
                Str("task_id", task.ID).
                Int("links_found", len(result.Links)).
                Str("content_type", result.ContentType).
                Msg("Crawler completed")

        // Process discovered links if find_links is enabled
        if task.FindLinks &amp;&amp; len(result.Links) &gt; 0 </span><span class="cov0" title="0">{
                wp.processDiscoveredLinks(ctx, task, result, urlStr)
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// isRetryableError checks if an error should trigger a retry
func isRetryableError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errorStr := strings.ToLower(err.Error())

        // Network/timeout errors that should be retried
        networkErrors := strings.Contains(errorStr, "timeout") ||
                strings.Contains(errorStr, "deadline exceeded") ||
                strings.Contains(errorStr, "connection") ||
                strings.Contains(errorStr, "network") ||
                strings.Contains(errorStr, "temporary") ||
                strings.Contains(errorStr, "reset by peer") ||
                strings.Contains(errorStr, "broken pipe") ||
                strings.Contains(errorStr, "unexpected eof")

        // Server errors that should be retried (likely due to load/temporary issues)
        serverErrors := strings.Contains(errorStr, "internal server error") ||
                strings.Contains(errorStr, "bad gateway") ||
                strings.Contains(errorStr, "service unavailable") ||
                strings.Contains(errorStr, "gateway timeout") ||
                strings.Contains(errorStr, "502") ||
                strings.Contains(errorStr, "503") ||
                strings.Contains(errorStr, "504") ||
                strings.Contains(errorStr, "500")

        return networkErrors || serverErrors</span>
}

// isBlockingError checks if an error indicates we're being blocked
func isBlockingError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errorStr := strings.ToLower(err.Error())

        // Blocking/rate limit errors that need special handling
        return strings.Contains(errorStr, "403") ||
                strings.Contains(errorStr, "forbidden") ||
                strings.Contains(errorStr, "429") ||
                strings.Contains(errorStr, "too many requests") ||
                strings.Contains(errorStr, "rate limit")</span>
}

// Helper function to check if a hostname is the same domain or a subdomain of the target domain
// Handles www prefix variations (www.test.com vs test.com)
func isSameOrSubDomain(hostname, targetDomain string) bool <span class="cov0" title="0">{
        // Normalise both domains by removing www prefix
        hostname = strings.ToLower(hostname)
        targetDomain = strings.ToLower(targetDomain)

        // Remove www. prefix if present
        normalisedHostname := strings.TrimPrefix(hostname, "www.")
        normalisedTarget := strings.TrimPrefix(targetDomain, "www.")

        // Direct match (after normalization)
        if normalisedHostname == normalisedTarget </span><span class="cov0" title="0">{
                return true
        }</span>

        // Original direct match (before normalization)
        <span class="cov0" title="0">if hostname == targetDomain </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if hostname ends with .targetDomain (subdomain check)
        <span class="cov0" title="0">if strings.HasSuffix(hostname, "."+targetDomain) </span><span class="cov0" title="0">{
                return true
        }</span>

        // Check if hostname ends with .normalisedTarget (subdomain check without www)
        <span class="cov0" title="0">if strings.HasSuffix(hostname, "."+normalisedTarget) </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// updateTaskPriorities updates the priority scores for tasks of linked pages
func (wp *WorkerPool) updateTaskPriorities(ctx context.Context, jobID string, domainID int, newPriority float64, paths []string) error <span class="cov0" title="0">{
        if len(paths) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var rowsAffected int64
        err := wp.dbQueue.Execute(ctx, func(tx *sql.Tx) error </span><span class="cov0" title="0">{
                // Update all task priorities in a single query
                result, err := tx.ExecContext(ctx, `
                        UPDATE tasks t
                        SET priority_score = $1
                        FROM pages p
                        WHERE t.page_id = p.id
                        AND t.job_id = $2
                        AND p.domain_id = $3
                        AND p.path = ANY($4)
                        AND t.priority_score &lt; $1
                `, newPriority, jobID, domainID, paths)
                
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                
                <span class="cov0" title="0">rowsAffected, err = result.RowsAffected()
                return err</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update task priorities: %w", err)
        }</span>

        <span class="cov0" title="0">if rowsAffected &gt; 0 </span><span class="cov0" title="0">{
                log.Info().
                        Str("job_id", jobID).
                        Int64("tasks_updated", rowsAffected).
                        Float64("new_priority", newPriority).
                        Msg("Updated task priorities for discovered links")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// evaluateJobPerformance checks if a job needs performance scaling
func (wp *WorkerPool) evaluateJobPerformance(jobID string, responseTime int64) <span class="cov8" title="1">{
        wp.perfMutex.Lock()
        defer wp.perfMutex.Unlock()

        perf, exists := wp.jobPerformance[jobID]
        if !exists </span><span class="cov8" title="1">{
                return // Job not tracked
        }</span>

        // Add response time to recent tasks (sliding window of 5)
        <span class="cov0" title="0">perf.RecentTasks = append(perf.RecentTasks, responseTime)
        if len(perf.RecentTasks) &gt; 5 </span><span class="cov0" title="0">{
                perf.RecentTasks = perf.RecentTasks[1:] // Remove oldest
        }</span>

        // Only evaluate after we have at least 3 tasks
        <span class="cov0" title="0">if len(perf.RecentTasks) &lt; 3 </span><span class="cov0" title="0">{
                return
        }</span>

        // Calculate average response time
        <span class="cov0" title="0">var total int64
        for _, rt := range perf.RecentTasks </span><span class="cov0" title="0">{
                total += rt
        }</span>
        <span class="cov0" title="0">avgResponseTime := total / int64(len(perf.RecentTasks))

        // Determine needed boost workers based on performance tiers
        var neededBoost int
        switch </span>{
        case avgResponseTime &gt;= 4000:<span class="cov0" title="0"> // 4000ms+
                neededBoost = 20</span>
        case avgResponseTime &gt;= 3000:<span class="cov0" title="0"> // 3000-4000ms
                neededBoost = 15</span>
        case avgResponseTime &gt;= 2000:<span class="cov0" title="0"> // 2000-3000ms
                neededBoost = 10</span>
        case avgResponseTime &gt;= 1000:<span class="cov0" title="0"> // 1000-2000ms
                neededBoost = 5</span>
        default:<span class="cov0" title="0"> // 0-1000ms
                neededBoost = 0</span>
        }

        // Check if boost needs to change
        <span class="cov0" title="0">if neededBoost != perf.CurrentBoost </span><span class="cov0" title="0">{
                boostDiff := neededBoost - perf.CurrentBoost

                log.Info().
                        Str("job_id", jobID).
                        Int64("avg_response_time", avgResponseTime).
                        Int("old_boost", perf.CurrentBoost).
                        Int("new_boost", neededBoost).
                        Int("boost_diff", boostDiff).
                        Msg("Job performance scaling triggered")

                // Update current boost
                perf.CurrentBoost = neededBoost
                perf.LastCheck = time.Now()

                // Apply scaling to worker pool
                if boostDiff &gt; 0 </span><span class="cov0" title="0">{
                        // Need more workers
                        wp.workersMutex.Lock()
                        targetWorkers := wp.currentWorkers + boostDiff
                        if targetWorkers &gt; 50 </span><span class="cov0" title="0">{ // Respect global max
                                targetWorkers = 50
                                perf.CurrentBoost = perf.CurrentBoost - (wp.currentWorkers + boostDiff - 50) // Adjust boost to actual
                        }</span>
                        <span class="cov0" title="0">wp.workersMutex.Unlock()

                        if targetWorkers &gt; wp.currentWorkers </span><span class="cov0" title="0">{
                                // Use detached context with timeout for worker scaling
                                scalingCtx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
                                go func() </span><span class="cov0" title="0">{
                                        defer cancel()
                                        wp.scaleWorkers(scalingCtx, targetWorkers)
                                }</span>()
                        }
                }
                // Note: For scaling down (boostDiff &lt; 0), we let workers naturally exit
                // when they check shouldExit in the worker loop
        }
}

// Helper function to check if a URL points to a document
func isDocumentLink(path string) bool <span class="cov0" title="0">{
        lower := strings.ToLower(path)
        return strings.HasSuffix(lower, ".pdf") ||
                strings.HasSuffix(lower, ".doc") ||
                strings.HasSuffix(lower, ".docx") ||
                strings.HasSuffix(lower, ".xls") ||
                strings.HasSuffix(lower, ".xlsx") ||
                strings.HasSuffix(lower, ".ppt") ||
                strings.HasSuffix(lower, ".pptx")
}</span>

// listenForNotifications sets up PostgreSQL LISTEN/NOTIFY
func (wp *WorkerPool) listenForNotifications(ctx context.Context) <span class="cov8" title="1">{
        var conn *pgx.Conn
        var err error

        connect := func() (*pgx.Conn, error) </span><span class="cov8" title="1">{
                c, err := pgx.Connect(ctx, wp.dbConfig.ConnectionString())
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">_, err = c.Exec(ctx, "LISTEN new_tasks")
                if err != nil </span><span class="cov0" title="0">{
                        c.Close(ctx)
                        return nil, err
                }</span>
                <span class="cov0" title="0">return c, nil</span>
        }

        <span class="cov8" title="1">conn, err = connect()
        if err != nil </span><span class="cov8" title="1">{
                log.Error().Err(err).Msg("Failed to connect for notifications initially")
                return
        }</span>
        <span class="cov0" title="0">defer conn.Close(ctx)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-wp.stopCh:<span class="cov0" title="0">
                        log.Debug().Msg("Notification listener received stop signal.")
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        log.Debug().Msg("Notification listener context cancelled.")
                        return</span>
                default:<span class="cov0" title="0"></span>
                        // Non-blocking check for stop signal before waiting for notification
                }

                <span class="cov0" title="0">notification, err := conn.WaitForNotification(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if ctx.Err() != nil || wp.stopping.Load() </span><span class="cov0" title="0">{
                                return // Context cancelled or pool is stopping
                        }</span>
                        <span class="cov0" title="0">log.Error().Err(err).Msg("Error waiting for notification, reconnecting...")
                        conn.Close(ctx)
                        time.Sleep(5 * time.Second) // Wait before reconnecting

                        conn, err = connect()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error().Err(err).Msg("Failed to reconnect for notifications")
                                continue</span>
                        }
                        <span class="cov0" title="0">continue</span>
                }

                <span class="cov0" title="0">log.Debug().Str("channel", notification.Channel).Msg("Received database notification")
                // Notify workers of new tasks (non-blocking)
                select </span>{
                case wp.notifyCh &lt;- struct{}{}:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel already has notification pending
                }
        }
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package mocks

import (
        "context"
        "net/http"

        "github.com/Harvey-AU/blue-banded-bee/internal/auth"
        "github.com/stretchr/testify/mock"
)

// MockAuthClient is a mock implementation of an authentication client
type MockAuthClient struct {
        mock.Mock
}

// ValidateToken mocks JWT token validation
func (m *MockAuthClient) ValidateToken(ctx context.Context, token string) (*AuthUser, error) <span class="cov0" title="0">{
        args := m.Called(ctx, token)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*AuthUser), args.Error(1)</span>
}

// RefreshToken mocks token refresh functionality
func (m *MockAuthClient) RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, refreshToken)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*TokenResponse), args.Error(1)</span>
}

// GetUserClaims mocks extracting user claims from JWT token
func (m *MockAuthClient) GetUserClaims(ctx context.Context, token string) (*UserClaims, error) <span class="cov0" title="0">{
        args := m.Called(ctx, token)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*UserClaims), args.Error(1)</span>
}

// CheckPermissions mocks organisation role permission checks
func (m *MockAuthClient) CheckPermissions(ctx context.Context, userID string, orgID string, permission string) (bool, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID, orgID, permission)
        return args.Bool(0), args.Error(1)
}</span>

// CreateUser mocks user registration functionality
func (m *MockAuthClient) CreateUser(ctx context.Context, email string, password string, metadata map[string]interface{}) (*AuthUser, error) <span class="cov0" title="0">{
        args := m.Called(ctx, email, password, metadata)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*AuthUser), args.Error(1)</span>
}

// SignIn mocks user sign-in functionality
func (m *MockAuthClient) SignIn(ctx context.Context, email string, password string) (*TokenResponse, error) <span class="cov0" title="0">{
        args := m.Called(ctx, email, password)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*TokenResponse), args.Error(1)</span>
}

// SignOut mocks user sign-out functionality
func (m *MockAuthClient) SignOut(ctx context.Context, token string) error <span class="cov0" title="0">{
        args := m.Called(ctx, token)
        return args.Error(0)
}</span>

// AuthUser represents an authenticated user for testing
type AuthUser struct {
        ID           string                 `json:"id"`
        Email        string                 `json:"email"`
        FullName     string                 `json:"full_name,omitempty"`
        Metadata     map[string]interface{} `json:"user_metadata,omitempty"`
        AppMetadata  map[string]interface{} `json:"app_metadata,omitempty"`
        CreatedAt    string                 `json:"created_at"`
        UpdatedAt    string                 `json:"updated_at"`
        LastSignInAt string                 `json:"last_sign_in_at,omitempty"`
}

// TokenResponse represents authentication tokens for testing
type TokenResponse struct {
        AccessToken      string   `json:"access_token"`
        TokenType        string   `json:"token_type"`
        ExpiresIn        int      `json:"expires_in"`
        RefreshToken     string   `json:"refresh_token,omitempty"`
        User             *AuthUser `json:"user,omitempty"`
}

// UserClaims represents JWT token claims for testing
type UserClaims struct {
        Sub           string                 `json:"sub"`           // User ID
        Email         string                 `json:"email"`         // User email
        EmailVerified bool                   `json:"email_verified"`
        Role          string                 `json:"role,omitempty"`
        UserMetadata  map[string]interface{} `json:"user_metadata,omitempty"`
        AppMetadata   map[string]interface{} `json:"app_metadata,omitempty"`
        Aud           string                 `json:"aud"`           // Audience
        Iss           string                 `json:"iss"`           // Issuer
        Iat           int64                  `json:"iat"`           // Issued at
        Exp           int64                  `json:"exp"`           // Expires at
}

// MockSupabaseClient is a mock for Supabase authentication client
type MockSupabaseClient struct {
        mock.Mock
}

// Auth mocks the Auth method to return auth client
func (m *MockSupabaseClient) Auth() *MockAuthClient <span class="cov0" title="0">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*MockAuthClient)</span>
}

// MockAuthMiddleware is a mock for authentication middleware testing
type MockAuthMiddleware struct {
        mock.Mock
}

// Middleware mocks the authentication middleware handler
func (m *MockAuthMiddleware) Middleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        args := m.Called(next)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return args.Get(0).(http.Handler)</span>
}

// ExtractTokenFromRequest mocks token extraction from HTTP request
func (m *MockAuthMiddleware) ExtractTokenFromRequest(r *http.Request) (string, error) <span class="cov0" title="0">{
        args := m.Called(r)
        return args.String(0), args.Error(1)
}</span>

// SetUserInContext mocks setting user context in HTTP request
func (m *MockAuthMiddleware) SetUserInContext(r *http.Request, user *AuthUser) *http.Request <span class="cov0" title="0">{
        args := m.Called(r, user)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Request)</span>
}

// AuthClientInterface defines the interface for authentication client operations
type AuthClientInterface interface {
        ValidateToken(ctx context.Context, token string) (*AuthUser, error)
        RefreshToken(ctx context.Context, refreshToken string) (*TokenResponse, error)
        GetUserClaims(ctx context.Context, token string) (*UserClaims, error)
        CheckPermissions(ctx context.Context, userID string, orgID string, permission string) (bool, error)
        CreateUser(ctx context.Context, email string, password string, metadata map[string]interface{}) (*AuthUser, error)
        SignIn(ctx context.Context, email string, password string) (*TokenResponse, error)
        SignOut(ctx context.Context, token string) error
}

// NewMockAuthConfig creates a mock auth configuration for testing
func NewMockAuthConfig() *auth.Config <span class="cov0" title="0">{
        return &amp;auth.Config{
                SupabaseURL:     "https://test.supabase.co",
                SupabaseAnonKey: "test_anon_key",
                JWTSecret:       "test_jwt_secret",
        }
}</pre>
		
		<pre class="file" id="file28" style="display: none">package mocks

import (
        "context"

        "github.com/Harvey-AU/blue-banded-bee/internal/crawler"
        "github.com/stretchr/testify/mock"
)

// MockCrawler is a mock implementation of the Crawler
type MockCrawler struct {
        mock.Mock
}

// WarmURL mocks the WarmURL method
func (m *MockCrawler) WarmURL(ctx context.Context, url string, findLinks bool) (*crawler.CrawlResult, error) <span class="cov0" title="0">{
        args := m.Called(ctx, url, findLinks)

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*crawler.CrawlResult), args.Error(1)</span>
}

// DiscoverSitemapsAndRobots mocks the DiscoverSitemapsAndRobots method
func (m *MockCrawler) DiscoverSitemapsAndRobots(ctx context.Context, domain string) (*crawler.SitemapDiscoveryResult, error) <span class="cov8" title="1">{
        args := m.Called(ctx, domain)

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov8" title="1">return args.Get(0).(*crawler.SitemapDiscoveryResult), args.Error(1)</span>
}

// ParseSitemap mocks the ParseSitemap method
func (m *MockCrawler) ParseSitemap(ctx context.Context, sitemapURL string) ([]string, error) <span class="cov0" title="0">{
        args := m.Called(ctx, sitemapURL)

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).([]string), args.Error(1)</span>
}

// FilterURLs mocks the FilterURLs method
func (m *MockCrawler) FilterURLs(urls []string, includePaths, excludePaths []string) []string <span class="cov0" title="0">{
        args := m.Called(urls, includePaths, excludePaths)

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return args.Get(0).([]string)</span>
}

// GetUserAgent mocks the GetUserAgent method
func (m *MockCrawler) GetUserAgent() string <span class="cov0" title="0">{
        args := m.Called()
        return args.String(0)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package mocks

import (
        "context"
        "database/sql"
        "time"

        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/stretchr/testify/mock"
)

// MockDB is a mock implementation of the database interface
type MockDB struct {
        mock.Mock
}

// GetDB mocks the GetDB method to return underlying *sql.DB
func (m *MockDB) GetDB() *sql.DB <span class="cov0" title="0">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*sql.DB)</span>
}

// Close mocks the Close method for database connection cleanup
func (m *MockDB) Close() error <span class="cov0" title="0">{
        args := m.Called()
        return args.Error(0)
}</span>

// GetConfig mocks the GetConfig method to return database configuration
func (m *MockDB) GetConfig() *db.Config <span class="cov0" title="0">{
        args := m.Called()
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.Config)</span>
}

// RecalculateJobStats mocks the RecalculateJobStats method
func (m *MockDB) RecalculateJobStats(ctx context.Context, jobID string) error <span class="cov0" title="0">{
        args := m.Called(ctx, jobID)
        return args.Error(0)
}</span>

// ResetSchema mocks the ResetSchema method for testing database resets
func (m *MockDB) ResetSchema() error <span class="cov0" title="0">{
        args := m.Called()
        return args.Error(0)
}</span>

// GetOrCreateUser mocks the GetOrCreateUser method
func (m *MockDB) GetOrCreateUser(userID, email string, orgID *string) (*db.User, error) <span class="cov0" title="0">{
        args := m.Called(userID, email, orgID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.User), args.Error(1)</span>
}

// GetUser mocks retrieving a user by ID
func (m *MockDB) GetUser(userID string) (*db.User, error) <span class="cov0" title="0">{
        args := m.Called(userID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.User), args.Error(1)</span>
}

// CreateUser mocks creating a user and organisation
func (m *MockDB) CreateUser(userID, email string, fullName *string, orgName string) (*db.User, *db.Organisation, error) <span class="cov0" title="0">{
        args := m.Called(userID, email, fullName, orgName)
        var user *db.User
        var org *db.Organisation
        if u := args.Get(0); u != nil </span><span class="cov0" title="0">{
                user = u.(*db.User)
        }</span>
        <span class="cov0" title="0">if o := args.Get(1); o != nil </span><span class="cov0" title="0">{
                org = o.(*db.Organisation)
        }</span>
        <span class="cov0" title="0">return user, org, args.Error(2)</span>
}

// GetOrganisation mocks retrieving an organisation by ID
func (m *MockDB) GetOrganisation(organisationID string) (*db.Organisation, error) <span class="cov0" title="0">{
        args := m.Called(organisationID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.Organisation), args.Error(1)</span>
}

// ListJobs mocks listing jobs with pagination and filters
func (m *MockDB) ListJobs(organisationID string, limit, offset int, status, dateRange string) ([]db.JobWithDomain, int, error) <span class="cov0" title="0">{
        args := m.Called(organisationID, limit, offset, status, dateRange)
        var jobs []db.JobWithDomain
        if v := args.Get(0); v != nil </span><span class="cov0" title="0">{
                jobs = v.([]db.JobWithDomain)
        }</span>
        <span class="cov0" title="0">total := 0
        if v := args.Get(1); v != nil </span><span class="cov0" title="0">{
                total = v.(int)
        }</span>
        <span class="cov0" title="0">return jobs, total, args.Error(2)</span>
}

// GetJobStats mocks the GetJobStats method
func (m *MockDB) GetJobStats(organisationID string, startDate, endDate *time.Time) (*db.JobStats, error) <span class="cov0" title="0">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.JobStats), args.Error(1)</span>
}

// GetJobActivity mocks the GetJobActivity method
func (m *MockDB) GetJobActivity(organisationID string, startDate, endDate *time.Time) ([]db.ActivityPoint, error) <span class="cov0" title="0">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]db.ActivityPoint), args.Error(1)</span>
}

// GetSlowPages mocks the GetSlowPages method
func (m *MockDB) GetSlowPages(organisationID string, startDate, endDate *time.Time) ([]db.SlowPage, error) <span class="cov0" title="0">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]db.SlowPage), args.Error(1)</span>
}

// GetExternalRedirects mocks the GetExternalRedirects method
func (m *MockDB) GetExternalRedirects(organisationID string, startDate, endDate *time.Time) ([]db.ExternalRedirect, error) <span class="cov0" title="0">{
        args := m.Called(organisationID, startDate, endDate)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]db.ExternalRedirect), args.Error(1)</span>
}

// GetUserByWebhookToken mocks the GetUserByWebhookToken method
func (m *MockDB) GetUserByWebhookToken(token string) (*db.User, error) <span class="cov0" title="0">{
        args := m.Called(token)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.User), args.Error(1)</span>
}</pre>
		
		<pre class="file" id="file30" style="display: none">package mocks

import (
        "context"
        "database/sql"

        "github.com/Harvey-AU/blue-banded-bee/internal/db"
        "github.com/stretchr/testify/mock"
)

// MockDbQueue is a mock implementation of DbQueueProvider
type MockDbQueue struct {
        mock.Mock
}

// Execute mocks the Execute method
func (m *MockDbQueue) Execute(ctx context.Context, fn func(*sql.Tx) error) error <span class="cov0" title="0">{
        args := m.Called(ctx, fn)

        // If the test wants to execute the function, it can provide a nil error
        // This allows us to test the transaction logic
        if args.Error(0) == nil &amp;&amp; fn != nil </span><span class="cov0" title="0">{
                // Create a dummy transaction for the function to use
                // In real tests, we might want to pass a mock transaction
                return fn(nil)
        }</span>

        <span class="cov0" title="0">return args.Error(0)</span>
}

// EnqueueURLs mocks the EnqueueURLs method
func (m *MockDbQueue) EnqueueURLs(ctx context.Context, jobID string, pages []db.Page, sourceType string, sourceURL string) error <span class="cov0" title="0">{
        args := m.Called(ctx, jobID, pages, sourceType, sourceURL)
        return args.Error(0)
}</span>

// CleanupStuckJobs mocks the CleanupStuckJobs method
func (m *MockDbQueue) CleanupStuckJobs(ctx context.Context) error <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.Error(0)
}</span>

// CreatePageRecords mocks the CreatePageRecords method
func (m *MockDbQueue) CreatePageRecords(ctx context.Context, dbQueue *db.DbQueue, domainID int, domain string, urls []string) ([]int, []string, error) <span class="cov0" title="0">{
        args := m.Called(ctx, dbQueue, domainID, domain, urls)

        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, nil, args.Error(2)
        }</span>

        <span class="cov0" title="0">return args.Get(0).([]int), args.Get(1).([]string), args.Error(2)</span>
}

// GetNextTask mocks the GetNextTask method
func (m *MockDbQueue) GetNextTask(ctx context.Context, jobID string) (*db.Task, error) <span class="cov8" title="1">{
        args := m.Called(ctx, jobID)
        if args.Get(0) == nil </span><span class="cov8" title="1">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*db.Task), args.Error(1)</span>
}

// UpdateTaskStatus mocks the UpdateTaskStatus method
func (m *MockDbQueue) UpdateTaskStatus(ctx context.Context, task *db.Task) error <span class="cov0" title="0">{
        args := m.Called(ctx, task)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package mocks

import (
        "net/http"
        "time"

        "github.com/stretchr/testify/mock"
)

// MockHTTPClient is a mock implementation of HTTP client interface
type MockHTTPClient struct {
        mock.Mock
}

// Do mocks the Do method of http.Client
func (m *MockHTTPClient) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        args := m.Called(req)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Get mocks the Get method of http.Client
func (m *MockHTTPClient) Get(url string) (*http.Response, error) <span class="cov0" title="0">{
        args := m.Called(url)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Post mocks the Post method of http.Client
func (m *MockHTTPClient) Post(url, contentType string, body interface{}) (*http.Response, error) <span class="cov0" title="0">{
        args := m.Called(url, contentType, body)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// PostForm mocks the PostForm method of http.Client
func (m *MockHTTPClient) PostForm(url string, data interface{}) (*http.Response, error) <span class="cov0" title="0">{
        args := m.Called(url, data)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// Head mocks the Head method of http.Client
func (m *MockHTTPClient) Head(url string) (*http.Response, error) <span class="cov0" title="0">{
        args := m.Called(url)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// MockRoundTripper is a mock implementation of http.RoundTripper interface
type MockRoundTripper struct {
        mock.Mock
}

// RoundTrip mocks the RoundTrip method of http.RoundTripper
func (m *MockRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        args := m.Called(req)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// HTTPClientInterface defines the interface for HTTP client operations
type HTTPClientInterface interface {
        Do(req *http.Request) (*http.Response, error)
        Get(url string) (*http.Response, error)
        Post(url, contentType string, body interface{}) (*http.Response, error)
        PostForm(url string, data interface{}) (*http.Response, error)
        Head(url string) (*http.Response, error)
}

// MockTransport is a mock implementation for HTTP transport testing
type MockTransport struct {
        mock.Mock
}

// RoundTrip implements http.RoundTripper interface for transport mocking
func (m *MockTransport) RoundTrip(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        args := m.Called(req)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*http.Response), args.Error(1)</span>
}

// NewMockHTTPClientWithTimeout creates a mock HTTP client with timeout configuration
func NewMockHTTPClientWithTimeout(timeout time.Duration) *MockHTTPClient <span class="cov0" title="0">{
        client := &amp;MockHTTPClient{}
        // Pre-configure common expectations if needed
        return client
}</span>

// CreateMockResponse creates a mock HTTP response for testing
func CreateMockResponse(statusCode int, body string, headers map[string]string) *http.Response <span class="cov0" title="0">{
        resp := &amp;http.Response{
                StatusCode: statusCode,
                Header:     make(http.Header),
        }
        
        // Add headers if provided
        for key, value := range headers </span><span class="cov0" title="0">{
                resp.Header.Set(key, value)
        }</span>
        
        <span class="cov0" title="0">return resp</span>
}</pre>
		
		<pre class="file" id="file32" style="display: none">package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"
)

// MockWorkerPool is a mock implementation of WorkerPool
type MockWorkerPool struct {
        mock.Mock
}

// Start mocks the Start method
func (m *MockWorkerPool) Start(ctx context.Context) error <span class="cov0" title="0">{
        args := m.Called(ctx)
        return args.Error(0)
}</span>

// Stop mocks the Stop method
func (m *MockWorkerPool) Stop() error <span class="cov0" title="0">{
        args := m.Called()
        return args.Error(0)
}</span>

// CancelJobTasks mocks the CancelJobTasks method
func (m *MockWorkerPool) CancelJobTasks(jobID string) error <span class="cov0" title="0">{
        args := m.Called(jobID)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package testutil

import (
        "os"
        "path/filepath"
        "testing"

        "github.com/joho/godotenv"
)

// LoadTestEnv loads the .env.test file and sets DATABASE_URL from TEST_DATABASE_URL
func LoadTestEnv(t *testing.T) <span class="cov0" title="0">{
        t.Helper()

        // If DATABASE_URL is already set (e.g., in CI), use it
        if os.Getenv("DATABASE_URL") != "" </span><span class="cov0" title="0">{
                t.Log("DATABASE_URL already set in environment")
                return
        }</span>

        // Find .env.test file (might be in parent directories during test runs)
        <span class="cov0" title="0">envPath := findEnvTestFile()
        if envPath == "" </span><span class="cov0" title="0">{
                t.Log("Warning: .env.test file not found, using environment variables as-is")
                return
        }</span>

        // Load .env.test
        <span class="cov0" title="0">envMap, err := godotenv.Read(envPath)
        if err != nil </span><span class="cov0" title="0">{
                t.Logf("Warning: Failed to read %s: %v", envPath, err)
                return
        }</span>

        // If TEST_DATABASE_URL exists, set it as DATABASE_URL
        <span class="cov0" title="0">if testDBURL, exists := envMap["TEST_DATABASE_URL"]; exists </span><span class="cov0" title="0">{
                os.Setenv("DATABASE_URL", testDBURL)
                t.Log("DATABASE_URL set from TEST_DATABASE_URL in .env.test")
        }</span>
}

// findEnvTestFile searches for .env.test in current and parent directories
func findEnvTestFile() string <span class="cov0" title="0">{
        // Start from current directory
        dir, _ := os.Getwd()

        // Search up to 5 levels up
        for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                envPath := filepath.Join(dir, ".env.test")
                if _, err := os.Stat(envPath); err == nil </span><span class="cov0" title="0">{
                        return envPath
                }</span>

                // Move to parent directory
                <span class="cov0" title="0">parent := filepath.Dir(dir)
                if parent == dir </span><span class="cov0" title="0">{
                        break</span> // Reached root
                }
                <span class="cov0" title="0">dir = parent</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package util

import (
        "net/url"
        "strings"

        "github.com/rs/zerolog/log"
)

// NormaliseDomain removes http/https prefix and www. from domain
func NormaliseDomain(domain string) string <span class="cov8" title="1">{
        // Remove http:// or https:// prefix if present
        domain = strings.TrimPrefix(domain, "http://")
        domain = strings.TrimPrefix(domain, "https://")

        // Remove www. prefix if present
        domain = strings.TrimPrefix(domain, "www.")

        // Remove trailing slash if present
        domain = strings.TrimSuffix(domain, "/")

        return domain
}</span>

// NormaliseURL ensures a URL has proper https:// scheme and validates format
func NormaliseURL(rawURL string) string <span class="cov8" title="1">{
        // Clean up the URL by trimming spaces
        rawURL = strings.TrimSpace(rawURL)

        // Skip empty URLs
        if rawURL == "" </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Convert http:// to https://
        <span class="cov8" title="1">if strings.HasPrefix(rawURL, "http://") </span><span class="cov8" title="1">{
                rawURL = strings.Replace(rawURL, "http://", "https://", 1)
        }</span>

        // Add https:// prefix if missing
        <span class="cov8" title="1">if !strings.HasPrefix(rawURL, "https://") </span><span class="cov8" title="1">{
                rawURL = "https://" + rawURL
        }</span>

        // Validate URL format
        <span class="cov8" title="1">parsedURL, err := url.Parse(rawURL)
        if err != nil || parsedURL.Scheme == "" || parsedURL.Host == "" </span><span class="cov8" title="1">{
                log.Debug().Str("url", rawURL).Err(err).Msg("Invalid URL format")
                return ""
        }</span>

        // Ensure no duplicate schemes (like https://http://example.com)
        <span class="cov8" title="1">hostPart := parsedURL.Host
        if strings.Contains(hostPart, "://") </span><span class="cov0" title="0">{
                log.Debug().Str("url", rawURL).Msg("URL contains embedded scheme in host part, fixing")
                // Extract the domain part after the embedded scheme
                parts := strings.SplitN(hostPart, "://", 2)
                if len(parts) == 2 </span><span class="cov0" title="0">{
                        parsedURL.Host = parts[1]
                        rawURL = parsedURL.String()
                }</span>
        }

        <span class="cov8" title="1">return rawURL</span>
}

// ExtractPathFromURL extracts just the path component from a full URL
func ExtractPathFromURL(fullURL string) string <span class="cov8" title="1">{
        // Remove any protocol and domain to get just the path
        path := fullURL
        // Strip common prefixes
        path = strings.TrimPrefix(path, "http://")
        path = strings.TrimPrefix(path, "https://")
        path = strings.TrimPrefix(path, "www.")

        // Find the first slash after the domain name
        domainEnd := strings.Index(path, "/")
        if domainEnd != -1 </span><span class="cov8" title="1">{
                // Extract just the path part
                path = path[domainEnd:]
        }</span> else<span class="cov8" title="1"> {
                // If no path found, use root path
                path = "/"
        }</span>

        <span class="cov8" title="1">return path</span>
}

// ConstructURL builds a proper URL from domain and path components
func ConstructURL(domain, path string) string <span class="cov8" title="1">{
        // Normalise the domain
        normalisedDomain := NormaliseDomain(domain)

        // Ensure path starts with /
        if !strings.HasPrefix(path, "/") </span><span class="cov8" title="1">{
                path = "/" + path
        }</span>

        // Construct the full URL
        <span class="cov8" title="1">return "https://" + normalisedDomain + path</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
