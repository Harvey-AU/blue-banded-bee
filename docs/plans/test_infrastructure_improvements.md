# Test Infrastructure Improvement Plan

## Executive Summary

This document outlines specific, actionable improvements for the project's testing infrastructure. While the current foundation is solid, these changes will address key architectural flaws, reduce test flakiness, and improve developer productivity by making tests more reliable, maintainable, and clear.

This is not a "nice to have" initiative; these fixes target fundamental issues that directly impact the stability of the codebase and the efficiency of the development process.

## 1. Enable Authentication Middleware Testing

**Problem:**
The core authentication middleware (`internal/api/auth_middleware.go`) is currently untestable in isolation because it depends on a concrete `auth.Client` implementation. The entire test file `internal/api/auth_middleware_test.go` is disabled with `t.Skip()`, providing a false sense of security.

**Solution:**
Decouple the middleware from the concrete implementation by introducing an interface.

**Actionable Steps:**
1.  **Define `AuthClient` Interface:** In the `internal/auth` package, create an interface that abstracts the methods required by the middleware (e.g., `ValidateToken`, `ExtractTokenFromRequest`).
    ```go
    // internal/auth/auth.go
    type AuthClient interface {
        ValidateToken(ctx context.Context, token string) (*UserClaims, error)
        ExtractTokenFromRequest(r *http.Request) (string, error)
        // ... other methods
    }
    ```
2.  **Update Middleware Dependency:** Modify the `api.Server` or the middleware constructor to accept the `AuthClient` interface instead of the concrete `*auth.Client`.
3.  **Update Mock:** Ensure the `MockAuthClient` in `auth_middleware_test.go` correctly implements the new interface.
4.  **Enable Test:** Remove the `t.Skip()` call in `TestAuthMiddleware` to activate the existing, well-structured test cases.

**Expected Outcome:**
-   The authentication middleware will have comprehensive, isolated unit tests.
-   A critical architectural flaw will be resolved, promoting better design patterns elsewhere.

## 2. Standardise Mocking and Dependency Injection

**Problem:**
Tests are inconsistent in how they handle dependencies. Some use `nil` pointers (`TestDatabaseHealthCheck_NoDatabase`), others use empty structs (`TestNewHandler`), and a few use proper mocks (`TestCreateJob_Integration`). This leads to confusion and tests that don't properly verify behavior, only pointer assignment.

**Solution:**
Standardise on using interfaces and mocks for all dependencies.

**Actionable Steps:**
1.  **Define Interfaces for Dependencies:** Create interfaces for core dependencies like `db.DB` and `jobs.JobManager` if they don't already exist. These interfaces should only include the methods used by the consumers (e.g., the API handlers).
2.  **Use `testify/mock` Consistently:** Refactor tests that use `nil` or empty structs to use mocks generated by `testify/mock`.
3.  **Verify Behavior, Not State:** Update tests to verify that the correct methods are called on the mocks with the expected arguments.

**Example Refactor (`TestDatabaseHealthCheck`):**
```go
// Before: Relies on a nil pointer check
handler := &Handler{DB: nil}
// ...

// After: Verifies behavior with a mock
mockDB := &mocks.MockDB{}
mockDB.On("PingContext", mock.Anything).Return(errors.New("connection failed"))
handler := &Handler{DB: mockDB}
// ...
mockDB.AssertExpectations(t)
```

**Expected Outcome:**
-   Tests will be more robust and less prone to passing incorrectly.
-   Tests will clearly document the interactions between components.
-   The codebase will be more maintainable and easier to refactor.

## 3. Isolate Integration Tests with Test Helpers

**Problem:**
The integration tests in `internal/api/jobs_integration_test.go` have a fragile setup. Both a `TestMain` function and individual test functions manage the database setup and teardown, creating a high risk of state leakage between tests, leading to flaky and unreliable results.

**Solution:**
Remove the package-level `TestMain` and create a test helper that provides a completely isolated database instance for each test function.

**Actionable Steps:**
1.  **Create a Test Helper:** In a `testutil` package, create a function that sets up a fresh test database and returns both the database connection and a teardown function.
    ```go
    // internal/testutil/db.go
    func NewTestDB(t *testing.T) (*db.DB, func()) {
        testDB, err := db.SetupTestDB()
        require.NoError(t, err)

        teardown := func() {
            db.TeardownTestDB(testDB)
        }
        return testDB, teardown
    }
    ```
2.  **Remove `TestMain`:** Delete the `TestMain` function from `jobs_integration_test.go`.
3.  **Refactor Tests:** Update each integration test to use the new helper, ensuring the teardown function is called via `defer`.
    ```go
    // internal/api/jobs_integration_test.go
    func TestCreateJob_Integration(t *testing.T) {
        testDB, teardown := testutil.NewTestDB(t)
        defer teardown()

        // ... rest of test
    }
    ```

**Expected Outcome:**
-   Integration tests will be fully isolated, eliminating flaky tests caused by shared state.
-   Test code will be cleaner and boilerplate for setup/teardown will be significantly reduced.
