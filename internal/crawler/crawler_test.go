package crawler

import (
	"context"
	"net"
	"net/http"
	"net/http/httptest"
	"os"
	"strings"
	"testing"
	"time"
)

// testConfig returns a config suitable for tests with SSRF checks disabled
// to allow httptest.NewServer (127.0.0.1) to work
func testConfig() *Config {
	cfg := DefaultConfig()
	cfg.SkipSSRFCheck = true
	return cfg
}

func TestWarmURL(t *testing.T) {
	// Create a test server
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("CF-Cache-Status", "HIT")
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("Hello, World!"))
	}))
	defer ts.Close()

	crawler := New(testConfig())
	result, err := crawler.WarmURL(context.Background(), ts.URL, false)
	if err != nil {
		t.Errorf("Expected no error, got %v", err)
	}

	if result.StatusCode != http.StatusOK {
		t.Errorf("Expected status code %d, got %d", http.StatusOK, result.StatusCode)
	}

	if result.CacheStatus != "HIT" {
		t.Errorf("Expected cache status HIT, got %s", result.CacheStatus)
	}

	// Check that performance metrics are captured
	if result.Performance.TTFB == 0 {
		t.Log("Warning: TTFB not captured (may be too fast for local test)")
	}
	if result.Performance.TCPConnectionTime == 0 {
		t.Log("Warning: TCP connection time not captured (may be reused connection)")
	}
}

func TestPerformanceMetrics(t *testing.T) {
	// Create a test server with a small delay to ensure metrics are captured
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(10 * time.Millisecond)        // Small delay to ensure measurable times
		w.Header().Set("CF-Cache-Status", "HIT") // Use HIT to avoid cache warming loop
		w.WriteHeader(http.StatusOK)
		_, _ = w.Write([]byte("Performance test response"))
	}))
	defer ts.Close()

	crawler := New(testConfig())
	result, err := crawler.WarmURL(context.Background(), ts.URL, false)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Log all performance metrics
	t.Logf("Performance Metrics:")
	t.Logf("  DNS Lookup: %dms", result.Performance.DNSLookupTime)
	t.Logf("  TCP Connection: %dms", result.Performance.TCPConnectionTime)
	t.Logf("  TLS Handshake: %dms", result.Performance.TLSHandshakeTime)
	t.Logf("  TTFB: %dms", result.Performance.TTFB)
	t.Logf("  Content Transfer: %dms", result.Performance.ContentTransferTime)
	t.Logf("  Total Response Time: %dms", result.ResponseTime)

	// Verify that at least TTFB is captured (should always be > 0 with delay)
	if result.Performance.TTFB == 0 {
		t.Error("TTFB should be greater than 0")
	}

	// Verify total response time is reasonable
	if result.ResponseTime < 10 {
		t.Error("Response time should be at least 10ms due to server delay")
	}
}

func TestPerformanceMetricsWithRealURL(t *testing.T) {
	// Skip in CI or if no internet connection
	if testing.Short() || os.Getenv("CI") != "" {
		t.Skip("Skipping test that requires internet connection (unreliable in CI)")
	}

	// Use a real HTTPS URL to test DNS, TCP, and TLS metrics
	crawler := New(nil)
	result, err := crawler.WarmURL(context.Background(), "https://httpbin.org/status/200", false)
	if err != nil {
		t.Fatalf("Expected no error, got %v", err)
	}

	// Log all performance metrics
	t.Logf("Performance Metrics for HTTPS request:")
	t.Logf("  DNS Lookup: %dms", result.Performance.DNSLookupTime)
	t.Logf("  TCP Connection: %dms", result.Performance.TCPConnectionTime)
	t.Logf("  TLS Handshake: %dms", result.Performance.TLSHandshakeTime)
	t.Logf("  TTFB: %dms", result.Performance.TTFB)
	t.Logf("  Content Transfer: %dms", result.Performance.ContentTransferTime)
	t.Logf("  Total Response Time: %dms", result.ResponseTime)

	// For a real HTTPS request, we should capture at least some of these
	if result.Performance.DNSLookupTime == 0 &&
		result.Performance.TCPConnectionTime == 0 &&
		result.Performance.TLSHandshakeTime == 0 {
		t.Log("Warning: No connection metrics captured - connection might be reused")
	}

	// TTFB should always be captured
	if result.Performance.TTFB == 0 {
		t.Error("TTFB should be greater than 0 for real request")
	}
}

func TestWarmURLError(t *testing.T) {
	crawler := New(nil)
	// Use a malformed URL instead
	result, err := crawler.WarmURL(context.Background(), "not-a-valid-url", false)

	if err == nil {
		t.Error("Expected error for invalid URL, got nil")
	}

	if result.Error == "" {
		t.Error("Expected error message in result, got empty string")
	}
}

func TestWarmURLWithDifferentStatuses(t *testing.T) {
	tests := []struct {
		name       string
		statusCode int
		wantError  bool
	}{
		{"success", http.StatusOK, false},
		{"not found", http.StatusNotFound, true},
		{"server error", http.StatusInternalServerError, true},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				w.WriteHeader(tt.statusCode)
				_, _ = w.Write([]byte("status check"))
			}))
			defer ts.Close()

			crawler := New(testConfig())
			result, err := crawler.WarmURL(context.Background(), ts.URL, false)

			if (err != nil) != tt.wantError {
				t.Errorf("WarmURL() error = %v, wantError %v", err, tt.wantError)
			}
			if result.StatusCode != tt.statusCode {
				t.Errorf("WarmURL() status = %v, want %v", result.StatusCode, tt.statusCode)
			}
		})
	}
}

func TestWarmURLContextCancellation(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	crawler := New(testConfig())

	// Create a test server that delays
	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(100 * time.Millisecond)
		w.WriteHeader(http.StatusOK)
	}))
	defer ts.Close()

	// Cancel context immediately
	cancel()

	// Should fail due to cancelled context
	_, err := crawler.WarmURL(ctx, ts.URL, false)
	if err == nil {
		t.Error("Expected error due to cancelled context, got nil")
	}
}

func TestWarmURLWithTimeout(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond)
	defer cancel()

	crawler := New(testConfig())

	ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		time.Sleep(100 * time.Millisecond)
		w.WriteHeader(http.StatusOK)
	}))
	defer ts.Close()

	_, err := crawler.WarmURL(ctx, ts.URL, false)
	if err == nil {
		t.Error("Expected timeout error, got nil")
	}
}

func TestNormaliseCacheStatus(t *testing.T) {
	tests := []struct {
		name     string
		input    string
		expected string
	}{
		// Empty input
		{"empty string", "", ""},

		// CloudFront formats (3% market share) - verified Dec 2025
		{"cloudfront hit", "Hit from cloudfront", "HIT"},
		{"cloudfront miss", "Miss from cloudfront", "MISS"},
		{"cloudfront refresh hit", "RefreshHit from cloudfront", "HIT"},
		{"cloudfront lambda generated", "LambdaGeneratedResponse from cloudfront", "BYPASS"},
		{"cloudfront error", "Error from cloudfront", "BYPASS"},
		{"cloudfront case insensitive", "MISS FROM CLOUDFRONT", "MISS"},
		{"cloudfront mixed case", "hit FROM CloudFront", "HIT"},

		// Akamai formats (3% market share) - verified Dec 2025
		{"akamai hit", "TCP_HIT", "HIT"},
		{"akamai miss", "TCP_MISS", "MISS"},
		{"akamai refresh hit", "TCP_REFRESH_HIT", "HIT"},
		{"akamai refresh miss", "TCP_REFRESH_MISS", "MISS"},
		{"akamai expired hit", "TCP_EXPIRED_HIT", "HIT"},
		{"akamai expired miss", "TCP_EXPIRED_MISS", "MISS"},
		{"akamai mem hit", "TCP_MEM_HIT", "HIT"},
		{"akamai ims hit", "TCP_IMS_HIT", "HIT"},
		{"akamai negative hit", "TCP_NEGATIVE_HIT", "HIT"},
		{"akamai refresh fail hit", "TCP_REFRESH_FAIL_HIT", "HIT"},
		{"akamai denied", "TCP_DENIED", "BYPASS"},
		{"akamai cookie deny", "TCP_COOKIE_DENY", "BYPASS"},
		{"akamai lowercase", "tcp_hit", "HIT"},
		{"akamai from child", "TCP_HIT from child", "HIT"},
		{"akamai from parent", "TCP_MISS from child, TCP_HIT from parent", "HIT"},

		// Azure CDN formats (~2% market share) - same TCP_ prefix as Akamai
		{"azure remote hit", "TCP_REMOTE_HIT", "HIT"},
		{"azure uncacheable", "UNCACHEABLE", "BYPASS"},
		{"azure uncacheable lowercase", "uncacheable", "BYPASS"},

		// Fastly shielding formats (12% market share) - verified Dec 2025
		{"fastly shield hit hit", "HIT, HIT", "HIT"},
		{"fastly shield miss hit", "MISS, HIT", "HIT"},
		{"fastly shield hit miss", "HIT, MISS", "MISS"},
		{"fastly shield miss miss", "MISS, MISS", "MISS"},

		// Cloudflare formats (64% market share) - verified Dec 2025
		{"cloudflare none", "NONE", "BYPASS"},
		{"cloudflare unknown", "UNKNOWN", "BYPASS"},
		{"cloudflare updating", "UPDATING", "UPDATING"},

		// RFC 9211 Cache-Status format (Netlify ~1%, future CDNs)
		{"netlify hit", `"Netlify Edge"; hit`, "HIT"},
		{"netlify hit no space", `"Netlify Edge";hit`, "HIT"},
		{"netlify miss", `"Netlify Edge"; fwd=miss`, "MISS"},
		{"netlify uri miss", `"Netlify Edge"; fwd=uri-miss`, "MISS"},
		{"netlify vary miss", `"Netlify Edge"; fwd=vary-miss`, "MISS"},
		{"netlify stale", `"Netlify Edge"; fwd=stale`, "MISS"},
		{"rfc9211 multi cache hit", `"Origin"; fwd=miss, "CDN"; hit`, "HIT"},
		{"rfc9211 with ttl", `ExampleCache; hit; ttl=30`, "HIT"},

		// Standard formats (Cloudflare 64%, Fastly 12%, Vercel ~1%, KeyCDN <1%)
		{"standard hit", "HIT", "HIT"},
		{"standard miss", "MISS", "MISS"},
		{"standard dynamic", "DYNAMIC", "DYNAMIC"},
		{"standard bypass", "BYPASS", "BYPASS"},
		{"standard expired", "EXPIRED", "EXPIRED"},
		{"standard stale", "STALE", "STALE"},
		{"standard revalidated", "REVALIDATED", "REVALIDATED"},
		{"vercel prerender", "PRERENDER", "PRERENDER"},
		{"fastly pass", "PASS", "PASS"},

		// Preserve unknown formats
		{"unknown format", "SOME_CUSTOM_VALUE", "SOME_CUSTOM_VALUE"},

		// Mixed case standard formats - normalise to uppercase
		{"mixed case hit", "Hit", "HIT"},
		{"lowercase miss", "miss", "MISS"},
		{"mixed case dynamic", "Dynamic", "DYNAMIC"},
		{"lowercase stale", "stale", "STALE"},

		// Whitespace handling
		{"leading spaces", "  HIT", "HIT"},
		{"trailing spaces", "MISS  ", "MISS"},
		{"both spaces", "  DYNAMIC  ", "DYNAMIC"},
		{"spaces only", "   ", ""},

		// TCP_ edge cases without HIT/MISS
		{"tcp client refresh", "TCP_CLIENT_REFRESH", "BYPASS"},
		{"tcp swapfail", "TCP_SWAPFAIL", "BYPASS"},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := normaliseCacheStatus(tt.input)
			if result != tt.expected {
				t.Errorf("normaliseCacheStatus(%q) = %q, want %q", tt.input, result, tt.expected)
			}
		})
	}
}

// TestIsPrivateOrLocalIP tests the SSRF protection IP classification
func TestIsPrivateOrLocalIP(t *testing.T) {
	tests := []struct {
		name     string
		ip       string
		expected bool
	}{
		// Loopback addresses
		{"ipv4 loopback", "127.0.0.1", true},
		{"ipv4 loopback alt", "127.0.0.2", true},
		{"ipv6 loopback", "::1", true},

		// Private ranges
		{"10.x.x.x", "10.0.0.1", true},
		{"10.x.x.x end", "10.255.255.255", true},
		{"172.16.x.x", "172.16.0.1", true},
		{"172.31.x.x", "172.31.255.255", true},
		{"192.168.x.x", "192.168.1.1", true},
		{"192.168.x.x end", "192.168.255.255", true},

		// Link-local
		{"ipv4 link-local", "169.254.1.1", true},
		{"ipv6 link-local", "fe80::1", true},

		// Unspecified
		{"ipv4 unspecified", "0.0.0.0", true},
		{"ipv6 unspecified", "::", true},

		// Public IPs (should NOT be blocked)
		{"google dns", "8.8.8.8", false},
		{"cloudflare dns", "1.1.1.1", false},
		{"public ip", "203.0.113.1", false},
		{"public ipv6", "2001:4860:4860::8888", false},

		// Edge cases - just outside private ranges
		{"172.15.x.x", "172.15.255.255", false},
		{"172.32.x.x", "172.32.0.1", false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ip := net.ParseIP(tt.ip)
			if ip == nil {
				t.Fatalf("Failed to parse IP: %s", tt.ip)
			}
			result := isPrivateOrLocalIP(ip)
			if result != tt.expected {
				t.Errorf("isPrivateOrLocalIP(%s) = %v, want %v", tt.ip, result, tt.expected)
			}
		})
	}
}

// TestSSRFProtection tests that ssrfSafeDialContext blocks connections to private/local IPs.
// Note: SSRF protection happens at connection time via the custom DialContext,
// not at URL validation time (which prevents DNS rebinding attacks).
func TestSSRFProtection(t *testing.T) {
	ctx := context.Background()

	// Get the SSRF-safe dialer
	dialFunc := ssrfSafeDialContext()

	// Test blocking localhost - dial should fail for private IPs
	_, err := dialFunc(ctx, "tcp", "127.0.0.1:80")
	if err == nil {
		t.Error("Expected error for 127.0.0.1, got nil")
	}
	if err != nil && !strings.Contains(err.Error(), "blocked connection to private/local IP") {
		t.Errorf("Expected SSRF blocking error, got: %v", err)
	}

	// Test blocking private network IPs
	_, err = dialFunc(ctx, "tcp", "10.0.0.1:80")
	if err == nil {
		t.Error("Expected error for 10.0.0.1, got nil")
	}

	_, err = dialFunc(ctx, "tcp", "192.168.1.1:80")
	if err == nil {
		t.Error("Expected error for 192.168.1.1, got nil")
	}

	// Test that validateCrawlRequest only validates URL format (SSRF moved to DialContext)
	_, err = validateCrawlRequest(ctx, "https://example.com/page", false)
	if err != nil {
		t.Errorf("Expected no error for valid URL, got %v", err)
	}

	// Invalid URLs should still fail validation
	_, err = validateCrawlRequest(ctx, "not-a-valid-url", false)
	if err == nil {
		t.Error("Expected error for invalid URL, got nil")
	}
}
